// control_flow_test.fg â€” Loops, conditionals, pattern matching, error handling

@test
define test_if_else_basic() {
    let mut result = ""
    if true { result = "yes" } else { result = "no" }
    assert_eq(result, "yes")

    if false { result = "bad" } else { result = "good" }
    assert_eq(result, "good")
}

@test
define test_if_else_chaining() {
    fn classify(n) {
        if n < 0 { return "negative" }
        otherwise if n == 0 { return "zero" }
        otherwise { return "positive" }
    }
    assert_eq(classify(-5), "negative")
    assert_eq(classify(0), "zero")
    assert_eq(classify(5), "positive")
}

@test
define test_while_loop() {
    let mut sum = 0
    let mut i = 0
    while i < 10 {
        i += 1
        sum += i
    }
    assert_eq(sum, 55)
}

@test
define test_while_break() {
    let mut i = 0
    while true {
        i += 1
        if i == 5 { break }
    }
    assert_eq(i, 5)
}

@test
define test_while_continue() {
    let mut sum = 0
    let mut i = 0
    while i < 10 {
        i += 1
        if i % 2 == 0 { continue }
        sum += i
    }
    assert_eq(sum, 25)
}

@test
define test_for_in_array() {
    let mut sum = 0
    for x in [1, 2, 3, 4, 5] {
        sum += x
    }
    assert_eq(sum, 15)
}

@test
define test_for_in_range() {
    let mut sum = 0
    for i in range(1, 6) {
        sum += i
    }
    assert_eq(sum, 15)
}

@test
define test_for_in_object() {
    let obj = { a: 1, b: 2, c: 3 }
    let mut total = 0
    for key, val in obj {
        total += val
    }
    assert_eq(total, 6)
}

@test
define test_for_with_break() {
    let mut last = 0
    for i in range(100) {
        last = i
        if i == 5 { break }
    }
    assert_eq(last, 5)
}

@test
define test_nested_loops() {
    let mut sum = 0
    for i in range(3) {
        for j in range(3) {
            sum += 1
        }
    }
    assert_eq(sum, 9)
}

@test
define test_match_literal_patterns() {
    fn describe(x) {
        match x {
            1 => return "one"
            2 => return "two"
            3 => return "three"
            _ => return "other"
        }
    }
    assert_eq(describe(1), "one")
    assert_eq(describe(2), "two")
    assert_eq(describe(99), "other")
}

@test
define test_match_adt_types() {
    type Color = Red | Green | Blue
    fn name(c) {
        match c {
            Red => return "red"
            Green => return "green"
            Blue => return "blue"
        }
    }
    assert_eq(name(Red), "red")
    assert_eq(name(Blue), "blue")
}

@test
define test_match_constructor_with_fields() {
    type Shape = Circle(Float) | Rect(Float, Float)
    fn area(s) {
        match s {
            Circle(r) => return 3.14 * r * r
            Rect(w, h) => return w * h
        }
    }
    assert(area(Rect(3.0, 4.0)) == 12.0)
}

@test
define test_try_catch() {
    let mut caught = ""
    try {
        let x = 1 / 0
    } catch err {
        caught = err
    }
    assert(len(caught) > 0)
}

@test
define test_try_catch_no_error() {
    let mut caught = "none"
    try {
        let x = 42
    } catch err {
        caught = err
    }
    assert_eq(caught, "none")
}

@test
define test_when_guards() {
    let mut label = ""
    let age = 5
    when age {
        < 13 -> { label = "child" }
        < 20 -> { label = "teen" }
        else -> { label = "adult" }
    }
    assert_eq(label, "child")

    let age2 = 15
    when age2 {
        < 13 -> { label = "child" }
        < 20 -> { label = "teen" }
        else -> { label = "adult" }
    }
    assert_eq(label, "teen")

    let age3 = 30
    when age3 {
        < 13 -> { label = "child" }
        < 20 -> { label = "teen" }
        else -> { label = "adult" }
    }
    assert_eq(label, "adult")
}

@test
define test_safe_block() {
    safe { let x = 1 / 0 }
    assert(true)
}

@test
define test_must_on_ok() {
    let x = must Ok(42)
    assert_eq(x, 42)
}

@test
define test_retry_block() {
    let mut count = 0
    retry 3 times {
        count += 1
        if count < 3 {
            let x = 1 / 0
        }
    }
    assert_eq(count, 3)
}

@test
define test_boolean_operators() {
    assert(true && true)
    assert(!(true && false))
    assert(true || false)
    assert(!(false || false))
    assert(!false)
    assert(!!true)
}

@test
define test_comparison_operators() {
    assert(1 < 2)
    assert(2 > 1)
    assert(5 <= 5)
    assert(5 >= 5)
    assert(3 == 3)
    assert(3 != 4)
    // String ordering not yet supported
    assert("hello" == "hello")
    assert("hello" != "world")
}

@test
define test_return_from_nested_scope() {
    fn find_first_even(arr) {
        for x in arr {
            if x % 2 == 0 {
                return x
            }
        }
        return -1
    }
    assert_eq(find_first_even([1, 3, 4, 5]), 4)
    assert_eq(find_first_even([1, 3, 5]), -1)
}
