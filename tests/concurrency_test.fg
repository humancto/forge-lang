// concurrency_test.fg â€” Spawn, await, channels, and concurrency tests

@test
define test_spawn_fire_and_forget() {
    spawn { let x = 1 + 1 }
    assert(true)
}

@test
define test_spawn_returns_handle() {
    let h = spawn { return 42 }
    assert_eq(typeof(h), "TaskHandle")
}

@test
define test_await_gets_value() {
    let h = spawn { return 42 }
    let v = await h
    assert_eq(v, 42)
}

@test
define test_await_string_result() {
    let h = spawn { return "hello" }
    let v = await h
    assert_eq(v, "hello")
}

@test
define test_await_non_handle_passthrough() {
    let v = await 42
    assert_eq(v, 42)
    let s = await "hello"
    assert_eq(s, "hello")
}

@test
define test_multiple_spawns() {
    let a = spawn { return 10 }
    let b = spawn { return 20 }
    let va = await a
    let vb = await b
    assert_eq(va + vb, 30)
}

@test
define test_spawn_with_computation() {
    let h = spawn {
        let mut sum = 0
        for i in range(1, 11) {
            sum = sum + i
        }
        return sum
    }
    let v = await h
    assert_eq(v, 55)
}

@test
define test_spawn_returns_complex_values() {
    let h1 = spawn { return { name: "test", value: 42 } }
    let h2 = spawn { return [1, 2, 3] }
    let h3 = spawn { return Some(99) }

    let obj = await h1
    assert_eq(obj.name, "test")
    assert_eq(obj.value, 42)

    let arr = await h2
    assert_eq(len(arr), 3)

    let opt = await h3
    assert(is_some(opt))
    assert_eq(unwrap(opt), 99)
}

@test
define test_spawn_error_isolation() {
    spawn { let x = 1 / 0 }
    let y = 42
    assert_eq(y, 42)
}

@test
define test_channel_send_receive() {
    let ch = channel()
    spawn {
        send(ch, 42)
    }
    let val = receive(ch)
    assert_eq(val, 42)
}

@test
define test_channel_multiple_messages() {
    let ch = channel()
    spawn {
        send(ch, 1)
        send(ch, 2)
        send(ch, 3)
    }
    let a = receive(ch)
    let b = receive(ch)
    let c = receive(ch)
    assert_eq(a + b + c, 6)
}
