// collections_extended_test.fg â€” New collection operations

@test
define test_sum_integers() {
    assert_eq(sum([1, 2, 3, 4, 5]), 15)
    assert_eq(sum([100]), 100)
}

@test
define test_sum_floats() {
    assert_eq(sum([1.5, 2.5]), 4.0)
}

@test
define test_min_of() {
    assert_eq(min_of([3, 1, 4, 1, 5]), 1)
    assert_eq(min_of([42]), 42)
    assert_eq(min_of([3.14, 2.71, 1.41]), 1.41)
}

@test
define test_max_of() {
    assert_eq(max_of([3, 1, 4, 1, 5]), 5)
    assert_eq(max_of([42]), 42)
    assert_eq(max_of([3.14, 2.71, 1.41]), 3.14)
}

@test
define test_any_predicate() {
    assert(any([1, 2, 3], fn(x) { return x > 2 }))
    assert(!any([1, 2, 3], fn(x) { return x > 5 }))
}

@test
define test_all_predicate() {
    assert(all([2, 4, 6], fn(x) { return x % 2 == 0 }))
    assert(!all([1, 2, 3], fn(x) { return x > 1 }))
}

@test
define test_unique() {
    assert_eq(unique([1, 2, 2, 3, 3, 3]), [1, 2, 3])
    assert_eq(unique(["a", "b", "a"]), ["a", "b"])
    assert_eq(unique([]), [])
}

@test
define test_zip() {
    let result = zip([1, 2, 3], ["a", "b", "c"])
    assert_eq(len(result), 3)
    assert_eq(result[0], [1, "a"])
    assert_eq(result[2], [3, "c"])
}

@test
define test_zip_uneven() {
    let result = zip([1, 2], ["a", "b", "c"])
    assert_eq(len(result), 2)
}

@test
define test_flatten() {
    assert_eq(flatten([[1, 2], [3, 4]]), [1, 2, 3, 4])
    assert_eq(flatten([[1], [], [2, 3]]), [1, 2, 3])
    assert_eq(flatten([1, [2, 3], 4]), [1, 2, 3, 4])
}

@test
define test_group_by() {
    let groups = group_by([1, 2, 3, 4, 5, 6], fn(x) {
        if x % 2 == 0 { return "even" }
        return "odd"
    })
    assert_eq(len(groups.even), 3)
    assert_eq(len(groups.odd), 3)
}

@test
define test_chunk() {
    let result = chunk([1, 2, 3, 4, 5], 2)
    assert_eq(len(result), 3)
    assert_eq(result[0], [1, 2])
    assert_eq(result[1], [3, 4])
    assert_eq(result[2], [5])
}

@test
define test_slice_array() {
    assert_eq(slice([1, 2, 3, 4, 5], 1, 3), [2, 3])
    assert_eq(slice([1, 2, 3], 0), [1, 2, 3])
    assert_eq(slice([1, 2, 3, 4], -2), [3, 4])
}

@test
define test_sort_custom_comparator() {
    let sorted = sort([3, 1, 4, 1, 5], fn(a, b) {
        if a < b { return -1 }
        if a > b { return 1 }
        return 0
    })
    assert_eq(sorted, [1, 1, 3, 4, 5])
}

@test
define test_sort_descending() {
    let sorted = sort([3, 1, 4, 1, 5], fn(a, b) {
        if a > b { return -1 }
        if a < b { return 1 }
        return 0
    })
    assert_eq(sorted, [5, 4, 3, 1, 1])
}

@test
define test_sort_default() {
    assert_eq(sort([3, 1, 4, 1, 5]), [1, 1, 3, 4, 5])
    assert_eq(sort(["c", "a", "b"]), ["a", "b", "c"])
}

@test
define test_method_syntax_collections() {
    let arr = [1, 2, 3, 4, 5]
    assert(arr.any(fn(x) { return x == 3 }))
    assert(arr.all(fn(x) { return x > 0 }))
    assert_eq(arr.sum(), 15)
    assert_eq(arr.min_of(), 1)
    assert_eq(arr.max_of(), 5)
}
