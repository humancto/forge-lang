<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Forge Language Specification</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Complete language specification for the Forge programming language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/forge-9ecd375c.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-7ed87d68.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-cb066ca3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Forge Language Specification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/humancto/forge-lang" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This document is the formal specification for the <strong>Forge</strong> programming language, version <strong>0.3.3</strong>.</p>
<p>Forge is an internet-native, general-purpose programming language implemented in Rust. It is designed for application-layer work: web services, scripts, data pipelines, prototypes, and tooling. Forge ships with built-in support for HTTP clients and servers, databases (SQLite and PostgreSQL), cryptography, JSON, CSV, terminal UI, AI/LLM integration, and more — eliminating the need for third-party packages for common internet-oriented tasks.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>Forge is guided by three core principles:</p>
<ol>
<li>
<p><strong>Internet-native.</strong> The operations developers perform most frequently — HTTP requests, database queries, JSON parsing, cryptographic hashing — are built into the language and its standard library. A REST API server is four lines. A database query is two.</p>
</li>
<li>
<p><strong>Dual syntax.</strong> Every construct in Forge has two spellings: a <em>classic syntax</em> familiar to developers who have written JavaScript, Python, Rust, or Go; and a <em>natural-language syntax</em> that reads like English prose. Both forms compile to identical internal representations and may be mixed freely within the same source file.</p>
</li>
<li>
<p><strong>Batteries included.</strong> Forge ships 16 standard library modules with over 230 functions, 30 interactive tutorials, a built-in test runner, a formatter, an LSP server, and a project scaffolding tool. A single <code>cargo install</code> provides a complete development environment.</p>
</li>
</ol>
<h2 id="language-overview"><a class="header" href="#language-overview">Language Overview</a></h2>
<p>Forge is dynamically typed at runtime with optional type annotations (gradual typing). It supports first-class functions, closures, algebraic data types, pattern matching, Result/Option error handling, structural interfaces, composition via delegation, async/await concurrency, and channels. Programs are executed top-to-bottom without requiring a <code>main</code> function.</p>
<p>The default execution engine is a tree-walking interpreter. A bytecode VM (<code>--vm</code>) and a JIT compiler (<code>--jit</code>) are available for performance-critical workloads but support fewer features.</p>
<h2 id="how-to-read-this-specification"><a class="header" href="#how-to-read-this-specification">How to Read This Specification</a></h2>
<p>This specification is organized into five parts:</p>
<ul>
<li><strong>Part I: Language Core</strong> covers lexical structure, types, expressions, statements, the type system, error handling, and concurrency.</li>
<li><strong>Part II: Standard Library</strong> documents each of the 16 built-in modules.</li>
<li><strong>Part III: Built-in Functions</strong> catalogs all globally available functions.</li>
<li><strong>Part IV: Dual Syntax Reference</strong> provides the complete mapping between classic and natural syntax forms.</li>
<li><strong>Part V: Runtime and Internals</strong> describes the interpreter, bytecode VM, JIT compiler, and HTTP server runtime.</li>
</ul>
<p>Grammar rules are presented in block quotes using an informal EBNF notation. Code examples use <code>forge</code> syntax highlighting. Where both classic and natural syntax exist for a construct, both forms are shown.</p>
<h2 id="notation-conventions"><a class="header" href="#notation-conventions">Notation Conventions</a></h2>
<p>Throughout this specification:</p>
<ul>
<li><code>monospace</code> text in prose refers to keywords, operators, or identifiers.</li>
<li>Code blocks labeled <code>forge</code> contain valid Forge source code.</li>
<li>Grammar productions use <code>→</code> for derivation, <code>|</code> for alternatives, <code>[ ]</code> for optional elements, and <code>{ }</code> for zero-or-more repetition.</li>
<li>The term “implementation-defined” means the behavior is determined by the specific execution engine (interpreter, VM, or JIT).</li>
</ul>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><strong>Source code:</strong> <a href="https://github.com/humancto/forge-lang">https://github.com/humancto/forge-lang</a></li>
<li><strong>Website and book:</strong> <a href="https://humancto.github.io/forge-lang/">https://humancto.github.io/forge-lang/</a></li>
</ul>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<p>Forge was created by <strong>Archith Rapaka / HumanCTO</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lexical-structure"><a class="header" href="#lexical-structure">Lexical Structure</a></h1>
<p>This chapter defines the lexical grammar of Forge: how source text is decomposed into a sequence of tokens. The lexer (tokenizer) reads UTF-8 encoded source text and produces a flat stream of tokens that the parser consumes.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>A Forge source file is a sequence of Unicode characters encoded as UTF-8. The lexer processes this character stream left-to-right, greedily matching the longest valid token at each position. The resulting token stream consists of:</p>
<ul>
<li><strong>Keywords</strong> — reserved words with special meaning (e.g., <code>let</code>, <code>fn</code>, <code>set</code>, <code>define</code>)</li>
<li><strong>Identifiers</strong> — user-defined names for variables, functions, types, and fields</li>
<li><strong>Literals</strong> — integer, float, string, boolean, and null values</li>
<li><strong>Operators</strong> — arithmetic, comparison, logical, assignment, and special operators</li>
<li><strong>Punctuation</strong> — delimiters and separators (<code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>[</code>, <code>]</code>, <code>,</code>, <code>:</code>, <code>;</code>)</li>
<li><strong>Comments</strong> — line comments and block comments, discarded during tokenization</li>
<li><strong>Newlines</strong> — significant for statement termination</li>
<li><strong>Decorators</strong> — <code>@</code> prefixed annotations</li>
</ul>
<h2 id="whitespace-and-line-termination"><a class="header" href="#whitespace-and-line-termination">Whitespace and Line Termination</a></h2>
<p>Spaces (U+0020) and horizontal tabs (U+0009) are whitespace characters. They separate tokens but are otherwise insignificant and are not included in the token stream.</p>
<p>Newline characters (U+000A, and the sequence U+000D U+000A) serve as statement terminators. Unlike whitespace, newlines are emitted as <code>Newline</code> tokens because Forge uses newlines (rather than semicolons) to separate statements. Semicolons (<code>;</code>) are recognized as explicit statement terminators but are not required.</p>
<h2 id="tokenization-order"><a class="header" href="#tokenization-order">Tokenization Order</a></h2>
<p>When the lexer encounters a character sequence, it applies the following precedence:</p>
<ol>
<li>Skip whitespace (spaces and tabs).</li>
<li>If the character begins a comment (<code>//</code> or <code>/*</code>), consume the entire comment.</li>
<li>If the character is a newline, emit a <code>Newline</code> token.</li>
<li>If the character is a digit, lex a numeric literal (integer or float).</li>
<li>If the character is <code>"</code>, lex a string literal (or <code>"""</code> for raw strings).</li>
<li>If the character is a letter or underscore, lex an identifier or keyword.</li>
<li>Otherwise, lex an operator or punctuation token.</li>
</ol>
<p>Each token carries a span consisting of the line number, column number, byte offset, and byte length within the source text.</p>
<h2 id="subsections"><a class="header" href="#subsections">Subsections</a></h2>
<p>The following subsections define each lexical element in detail:</p>
<ul>
<li><a href="#source-text">Source Text</a> — encoding, file extension, line endings</li>
<li><a href="#keywords">Keywords</a> — complete keyword list with dual-syntax mappings</li>
<li><a href="#identifiers">Identifiers</a> — naming rules and special identifiers</li>
<li><a href="#literals">Literals</a> — numeric, string, boolean, null, array, and object literals</li>
<li><a href="#operators-and-punctuation">Operators and Punctuation</a> — all operator and delimiter tokens</li>
<li><a href="#comments">Comments</a> — line and block comment syntax</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="source-text"><a class="header" href="#source-text">Source Text</a></h1>
<h2 id="encoding"><a class="header" href="#encoding">Encoding</a></h2>
<p>Forge source files must be encoded in <strong>UTF-8</strong>. The lexer assumes UTF-8 input and will produce errors on invalid byte sequences. No byte-order mark (BOM) is required or expected; if present, it is treated as ordinary content and will likely cause a parse error.</p>
<h2 id="file-extension"><a class="header" href="#file-extension">File Extension</a></h2>
<p>Forge source files use the <code>.fg</code> file extension by convention. The CLI tools (<code>forge run</code>, <code>forge test</code>, <code>forge fmt</code>) expect this extension. Example:</p>
<pre><code>hello.fg
server.fg
tests/math_test.fg
</code></pre>
<h2 id="line-endings"><a class="header" href="#line-endings">Line Endings</a></h2>
<p>Forge recognizes two line ending sequences:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Sequence</th><th>Name</th><th>Unicode</th></tr>
</thead>
<tbody>
<tr><td><code>\n</code></td><td>Line feed</td><td>U+000A</td></tr>
<tr><td><code>\r\n</code></td><td>Carriage return + line feed</td><td>U+000D U+000A</td></tr>
</tbody>
</table>
</div>
<p>A bare carriage return (<code>\r</code> without a following <code>\n</code>) is not treated as a line ending. Both recognized forms are normalized to a single <code>Newline</code> token in the token stream.</p>
<h2 id="source-structure"><a class="header" href="#source-structure">Source Structure</a></h2>
<p>A Forge source file consists of a sequence of top-level statements executed in order. There is no required <code>main</code> function, module declaration, or package header. The simplest valid Forge program is:</p>
<pre><code class="language-forge">say "hello"
</code></pre>
<p>Forge programs are executed from the first statement to the last, top to bottom. Functions and type definitions are hoisted conceptually in that they can be referenced before their textual position, but side effects in top-level statements execute in source order.</p>
<h2 id="character-set"><a class="header" href="#character-set">Character Set</a></h2>
<p>Within string literals, Forge supports the full Unicode character set. Outside of string literals, the following characters are meaningful to the lexer:</p>
<ul>
<li>ASCII letters (<code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>) and underscore (<code>_</code>) begin identifiers and keywords.</li>
<li>ASCII digits (<code>0</code>-<code>9</code>) begin numeric literals.</li>
<li>Operator and punctuation characters: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>=</code>, <code>!</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>.</code>, <code>,</code>, <code>:</code>, <code>;</code>, <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>[</code>, <code>]</code>, <code>@</code>, <code>?</code>, <code>#</code>.</li>
<li>The double-quote character (<code>"</code>) begins string literals.</li>
<li>Whitespace characters: space (U+0020), horizontal tab (U+0009).</li>
<li>Line terminators: line feed (U+000A), carriage return (U+000D).</li>
</ul>
<p>All other characters outside of string literals are lexer errors.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="keywords"><a class="header" href="#keywords">Keywords</a></h1>
<p>Keywords are reserved identifiers with special syntactic meaning. A keyword cannot be used as a variable name, function name, or type name.</p>
<p>Forge’s keyword set is organized into five categories: classic keywords (familiar from other languages), natural-language keywords (Forge’s English-like alternatives), innovation keywords (unique to Forge), error handling keywords, and type keywords.</p>
<h2 id="classic-keywords"><a class="header" href="#classic-keywords">Classic Keywords</a></h2>
<p>These keywords provide syntax familiar to developers coming from Rust, JavaScript, Go, or Python.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>let</code></td><td>Variable declaration</td></tr>
<tr><td><code>mut</code></td><td>Mutable variable modifier</td></tr>
<tr><td><code>fn</code></td><td>Function declaration</td></tr>
<tr><td><code>return</code></td><td>Return from function</td></tr>
<tr><td><code>if</code></td><td>Conditional branch</td></tr>
<tr><td><code>else</code></td><td>Alternative branch</td></tr>
<tr><td><code>match</code></td><td>Pattern matching</td></tr>
<tr><td><code>for</code></td><td>For loop</td></tr>
<tr><td><code>in</code></td><td>Iterator binding (used with <code>for</code>)</td></tr>
<tr><td><code>while</code></td><td>While loop</td></tr>
<tr><td><code>loop</code></td><td>Infinite loop</td></tr>
<tr><td><code>break</code></td><td>Exit a loop</td></tr>
<tr><td><code>continue</code></td><td>Skip to next loop iteration</td></tr>
<tr><td><code>struct</code></td><td>Struct type definition</td></tr>
<tr><td><code>type</code></td><td>Algebraic data type definition</td></tr>
<tr><td><code>interface</code></td><td>Interface definition</td></tr>
<tr><td><code>impl</code></td><td>Method block / interface implementation</td></tr>
<tr><td><code>pub</code></td><td>Public visibility modifier</td></tr>
<tr><td><code>import</code></td><td>Module import</td></tr>
<tr><td><code>spawn</code></td><td>Spawn a concurrent task</td></tr>
<tr><td><code>true</code></td><td>Boolean literal true</td></tr>
<tr><td><code>false</code></td><td>Boolean literal false</td></tr>
<tr><td><code>null</code></td><td>Null literal</td></tr>
<tr><td><code>async</code></td><td>Async function declaration</td></tr>
<tr><td><code>await</code></td><td>Await an async expression</td></tr>
<tr><td><code>yield</code></td><td>Yield a value from a generator</td></tr>
</tbody>
</table>
</div>
<h2 id="natural-language-keywords"><a class="header" href="#natural-language-keywords">Natural-Language Keywords</a></h2>
<p>These keywords provide English-like alternatives to classic syntax. Each natural keyword maps to an equivalent classic construct.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Natural Keyword</th><th>Classic Equivalent</th><th>Usage</th></tr>
</thead>
<tbody>
<tr><td><code>set</code></td><td><code>let</code></td><td><code>set x to 5</code></td></tr>
<tr><td><code>to</code></td><td><code>=</code></td><td>Used with <code>set</code> and <code>change</code></td></tr>
<tr><td><code>change</code></td><td>(reassignment)</td><td><code>change x to 10</code></td></tr>
<tr><td><code>define</code></td><td><code>fn</code></td><td><code>define greet(name) { }</code></td></tr>
<tr><td><code>otherwise</code></td><td><code>else</code></td><td><code>} otherwise { }</code></td></tr>
<tr><td><code>nah</code></td><td><code>else</code></td><td><code>} nah { }</code> (informal)</td></tr>
<tr><td><code>each</code></td><td>(loop modifier)</td><td><code>for each x in items { }</code></td></tr>
<tr><td><code>repeat</code></td><td>(counted loop)</td><td><code>repeat 5 times { }</code></td></tr>
<tr><td><code>times</code></td><td>(loop count)</td><td>Used with <code>repeat</code></td></tr>
<tr><td><code>grab</code></td><td>(fetch)</td><td><code>grab resp from "url"</code></td></tr>
<tr><td><code>from</code></td><td>(source)</td><td>Used with <code>grab</code> and <code>unpack</code></td></tr>
<tr><td><code>wait</code></td><td>(sleep)</td><td><code>wait 2 seconds</code></td></tr>
<tr><td><code>seconds</code></td><td>(time unit)</td><td>Used with <code>wait</code> and <code>timeout</code></td></tr>
<tr><td><code>say</code></td><td><code>println</code></td><td><code>say "hello"</code></td></tr>
<tr><td><code>yell</code></td><td>(uppercase print)</td><td><code>yell "hello"</code> prints <code>HELLO</code></td></tr>
<tr><td><code>whisper</code></td><td>(lowercase print)</td><td><code>whisper "HELLO"</code> prints <code>hello</code></td></tr>
<tr><td><code>thing</code></td><td><code>struct</code></td><td><code>thing Person { }</code></td></tr>
<tr><td><code>power</code></td><td><code>interface</code></td><td><code>power Describable { }</code></td></tr>
<tr><td><code>give</code></td><td><code>impl</code></td><td><code>give Person { }</code></td></tr>
<tr><td><code>craft</code></td><td>(constructor)</td><td><code>craft Person { name: "A" }</code></td></tr>
<tr><td><code>the</code></td><td>(connector)</td><td><code>give X the power Y { }</code></td></tr>
<tr><td><code>forge</code></td><td><code>async</code></td><td><code>forge fetch_data() { }</code></td></tr>
<tr><td><code>hold</code></td><td><code>await</code></td><td><code>hold expr</code></td></tr>
<tr><td><code>emit</code></td><td><code>yield</code></td><td><code>emit value</code></td></tr>
<tr><td><code>unpack</code></td><td>(destructure)</td><td><code>unpack {a, b} from obj</code></td></tr>
</tbody>
</table>
</div>
<h2 id="dual-syntax-mapping"><a class="header" href="#dual-syntax-mapping">Dual Syntax Mapping</a></h2>
<p>The following table shows equivalent forms for the most common constructs:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Construct</th><th>Classic</th><th>Natural</th></tr>
</thead>
<tbody>
<tr><td>Variable</td><td><code>let x = 5</code></td><td><code>set x to 5</code></td></tr>
<tr><td>Mutable variable</td><td><code>let mut x = 0</code></td><td><code>set mut x to 0</code></td></tr>
<tr><td>Reassignment</td><td><code>x = 10</code></td><td><code>change x to 10</code></td></tr>
<tr><td>Function</td><td><code>fn add(a, b) { }</code></td><td><code>define add(a, b) { }</code></td></tr>
<tr><td>Else branch</td><td><code>else { }</code></td><td><code>otherwise { }</code> / <code>nah { }</code></td></tr>
<tr><td>Struct definition</td><td><code>struct Point { }</code></td><td><code>thing Point { }</code></td></tr>
<tr><td>Interface</td><td><code>interface I { }</code></td><td><code>power I { }</code></td></tr>
<tr><td>Impl block</td><td><code>impl T { }</code></td><td><code>give T { }</code></td></tr>
<tr><td>Impl for interface</td><td><code>impl I for T { }</code></td><td><code>give T the power I { }</code></td></tr>
<tr><td>Constructor</td><td><code>Point { x: 1 }</code></td><td><code>craft Point { x: 1 }</code></td></tr>
<tr><td>Async function</td><td><code>async fn f() { }</code></td><td><code>forge f() { }</code></td></tr>
<tr><td>Await</td><td><code>await expr</code></td><td><code>hold expr</code></td></tr>
<tr><td>Yield</td><td><code>yield value</code></td><td><code>emit value</code></td></tr>
<tr><td>Destructure</td><td><code>let {a, b} = obj</code></td><td><code>unpack {a, b} from obj</code></td></tr>
</tbody>
</table>
</div>
<h2 id="innovation-keywords"><a class="header" href="#innovation-keywords">Innovation Keywords</a></h2>
<p>These keywords introduce constructs unique to Forge that have no direct equivalent in other mainstream languages.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>when</code></td><td>Guard expression (multi-way conditional)</td><td><code>when age { &lt; 13 -&gt; "kid" }</code></td></tr>
<tr><td><code>unless</code></td><td>Postfix negative conditional</td><td><code>expr unless condition</code></td></tr>
<tr><td><code>until</code></td><td>Postfix loop-until</td><td><code>expr until condition</code></td></tr>
<tr><td><code>must</code></td><td>Crash on error with message</td><td><code>must parse_int(s)</code></td></tr>
<tr><td><code>check</code></td><td>Declarative validation</td><td><code>check name is not empty</code></td></tr>
<tr><td><code>safe</code></td><td>Null-safe execution block</td><td><code>safe { risky_code() }</code></td></tr>
<tr><td><code>where</code></td><td>Collection filter</td><td><code>items where x &gt; 5</code></td></tr>
<tr><td><code>timeout</code></td><td>Time-limited execution</td><td><code>timeout 5 seconds { }</code></td></tr>
<tr><td><code>retry</code></td><td>Automatic retry with count</td><td><code>retry 3 times { }</code></td></tr>
<tr><td><code>schedule</code></td><td>Cron-style scheduling</td><td><code>schedule every 5 minutes { }</code></td></tr>
<tr><td><code>every</code></td><td>Used with <code>schedule</code></td><td><code>schedule every N { }</code></td></tr>
<tr><td><code>any</code></td><td>Existential quantifier</td><td><code>any x in items</code></td></tr>
<tr><td><code>ask</code></td><td>AI/LLM prompt</td><td><code>ask "summarize this"</code></td></tr>
<tr><td><code>prompt</code></td><td>Prompt template definition</td><td><code>prompt summarize() { }</code></td></tr>
<tr><td><code>transform</code></td><td>Data transformation block</td><td><code>transform data { }</code></td></tr>
<tr><td><code>table</code></td><td>Table display</td><td><code>table [...]</code></td></tr>
<tr><td><code>select</code></td><td>Query-style select</td><td><code>from X select Y</code></td></tr>
<tr><td><code>order</code></td><td>Query-style ordering</td><td><code>order by field</code></td></tr>
<tr><td><code>by</code></td><td>Used with <code>order</code> and <code>sort</code></td><td><code>order by name</code></td></tr>
<tr><td><code>limit</code></td><td>Query-style limit</td><td><code>limit 10</code></td></tr>
<tr><td><code>keep</code></td><td>Filter synonym</td><td><code>keep where condition</code></td></tr>
<tr><td><code>take</code></td><td>Take N items</td><td><code>take 5</code></td></tr>
<tr><td><code>freeze</code></td><td>Freeze/immobilize a value</td><td><code>freeze expr</code></td></tr>
<tr><td><code>watch</code></td><td>File change detection</td><td><code>watch "file.txt" { }</code></td></tr>
<tr><td><code>download</code></td><td>Download a file from URL</td><td><code>download "url" to "path"</code></td></tr>
<tr><td><code>crawl</code></td><td>Web scraping</td><td><code>crawl "url"</code></td></tr>
</tbody>
</table>
</div>
<h2 id="error-handling-keywords"><a class="header" href="#error-handling-keywords">Error Handling Keywords</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>try</code></td><td>Try block</td><td><code>try { }</code></td></tr>
<tr><td><code>catch</code></td><td>Catch block</td><td><code>catch err { }</code></td></tr>
</tbody>
</table>
</div>
<h2 id="type-keywords"><a class="header" href="#type-keywords">Type Keywords</a></h2>
<p>These identifiers are reserved as built-in type names. They are recognized by the lexer as keyword tokens, not as general identifiers.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Type</th></tr>
</thead>
<tbody>
<tr><td><code>Int</code></td><td>64-bit signed integer</td></tr>
<tr><td><code>Float</code></td><td>64-bit IEEE 754 float</td></tr>
<tr><td><code>String</code></td><td>UTF-8 string</td></tr>
<tr><td><code>Bool</code></td><td>Boolean</td></tr>
<tr><td><code>Json</code></td><td>JSON value type</td></tr>
</tbody>
</table>
</div>
<h2 id="operators-as-keywords"><a class="header" href="#operators-as-keywords">Operators as Keywords</a></h2>
<p>The following operators are lexed as keyword tokens rather than punctuation:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Keyword</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>|&gt;</code></td><td><code>Pipe</code></td><td>Pipe-forward operator</td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>PipeRight</code></td><td>Alternate pipe operator</td></tr>
<tr><td><code>...</code></td><td><code>DotDotDot</code></td><td>Spread operator</td></tr>
<tr><td><code>+=</code></td><td><code>PlusEq</code></td><td>Add-assign</td></tr>
<tr><td><code>-=</code></td><td><code>MinusEq</code></td><td>Subtract-assign</td></tr>
<tr><td><code>*=</code></td><td><code>StarEq</code></td><td>Multiply-assign</td></tr>
<tr><td><code>/=</code></td><td><code>SlashEq</code></td><td>Divide-assign</td></tr>
</tbody>
</table>
</div>
<h2 id="complete-alphabetical-index"><a class="header" href="#complete-alphabetical-index">Complete Alphabetical Index</a></h2>
<p>For reference, the complete set of keyword strings recognized by the lexer (case-sensitive):</p>
<pre><code>Int, Float, String, Bool, Json,
any, ask, async, await, break, by, catch, change, continue, craft,
crawl, define, download, each, else, emit, every, false, fn, for,
forge, freeze, from, give, grab, hold, if, impl, import, in,
interface, keep, let, limit, loop, match, mut, nah, null, order,
otherwise, power, prompt, pub, repeat, retry, return, safe, say,
schedule, seconds, select, set, spawn, struct, table, take, the,
thing, timeout, times, to, transform, true, try, type, unless,
unpack, until, wait, watch, when, where, while, whisper, yell, yield
</code></pre>
<p>All keywords are case-sensitive. <code>Let</code> and <code>LET</code> are identifiers, not keywords. The type keywords <code>Int</code>, <code>Float</code>, <code>String</code>, <code>Bool</code>, and <code>Json</code> are the only keywords that begin with an uppercase letter.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>An identifier is a name that refers to a variable, function, type, field, or module. Identifiers are the primary mechanism for binding values to names in Forge programs.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<blockquote>
<p><em>Identifier</em> → <em>IdentStart</em> <em>IdentContinue</em>*</p>
<p><em>IdentStart</em> → <code>a</code>-<code>z</code> | <code>A</code>-<code>Z</code> | <code>_</code></p>
<p><em>IdentContinue</em> → <em>IdentStart</em> | <code>0</code>-<code>9</code></p>
</blockquote>
<p>An identifier begins with an ASCII letter or underscore, followed by zero or more ASCII letters, digits, or underscores. Identifiers have no maximum length.</p>
<pre><code class="language-forge">x
name
_private
camelCase
snake_case
PascalCase
item2
MAX_RETRIES
__internal
</code></pre>
<h2 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case Sensitivity</a></h2>
<p>Identifiers are <strong>case-sensitive</strong>. The names <code>name</code>, <code>Name</code>, and <code>NAME</code> refer to three distinct bindings.</p>
<pre><code class="language-forge">let name = "alice"
let Name = "Bob"
let NAME = "CHARLIE"
say name   // alice
say Name   // Bob
say NAME   // CHARLIE
</code></pre>
<h2 id="reserved-words"><a class="header" href="#reserved-words">Reserved Words</a></h2>
<p>If an identifier matches a keyword string (see <a href="#keywords">Keywords</a>), it is lexed as that keyword token rather than as an <code>Ident</code> token. Keywords cannot be used as identifiers.</p>
<pre><code class="language-forge">// Error: 'let' is a keyword, not a valid variable name
let let = 5  // parse error
</code></pre>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h2>
<p>Forge does not enforce naming conventions, but the following are idiomatic:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Element</th><th>Convention</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Variables</td><td><code>snake_case</code></td><td><code>user_name</code></td></tr>
<tr><td>Functions</td><td><code>snake_case</code></td><td><code>get_user</code></td></tr>
<tr><td>Types (structs)</td><td><code>PascalCase</code></td><td><code>HttpRequest</code></td></tr>
<tr><td>Interfaces</td><td><code>PascalCase</code></td><td><code>Describable</code></td></tr>
<tr><td>Constants</td><td><code>UPPER_SNAKE</code></td><td><code>MAX_RETRIES</code></td></tr>
<tr><td>Modules</td><td><code>snake_case</code></td><td><code>math</code>, <code>fs</code>, <code>json</code></td></tr>
</tbody>
</table>
</div>
<h2 id="the-it-identifier"><a class="header" href="#the-it-identifier">The <code>it</code> Identifier</a></h2>
<p>The identifier <code>it</code> has special meaning inside method blocks defined with <code>give</code> (or <code>impl</code>). When used as the first parameter of a method, <code>it</code> refers to the receiver instance — the object on which the method was called.</p>
<pre><code class="language-forge">thing Person {
    name: String,
    age: Int
}

give Person {
    define greet(it) {
        return "Hi, I'm " + it.name
    }
}

set p to craft Person { name: "Alice", age: 30 }
say p.greet()  // Hi, I'm Alice
</code></pre>
<p>When <code>p.greet()</code> is called, the value of <code>p</code> is automatically bound to <code>it</code> inside the method body. The caller does not pass <code>it</code> explicitly.</p>
<p>If the first parameter of a method is <em>not</em> named <code>it</code>, the method is treated as a <strong>static method</strong> — it is called on the type itself rather than on an instance:</p>
<pre><code class="language-forge">give Person {
    define infant(name) {
        return craft Person { name: name, age: 0 }
    }
}

set baby to Person.infant("Bob")
</code></pre>
<p>Outside of method blocks, <code>it</code> has no special meaning and may be used as an ordinary identifier, though this is discouraged for clarity.</p>
<h2 id="underscore"><a class="header" href="#underscore">Underscore</a></h2>
<p>A lone underscore (<code>_</code>) is a valid identifier. By convention, it is used as a placeholder for values that are intentionally ignored:</p>
<pre><code class="language-forge">match result {
    Ok(_) =&gt; say "success"
    Err(msg) =&gt; say "error: {msg}"
}
</code></pre>
<pre><code class="language-forge">for _, value in enumerate(items) {
    say value
}
</code></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>A new <code>let</code> or <code>set</code> declaration may reuse an identifier that is already in scope. The new binding <em>shadows</em> the previous one within the inner scope:</p>
<pre><code class="language-forge">let x = 10
say x        // 10

if true {
    let x = 20
    say x    // 20 (shadows outer x)
}

say x        // 10 (outer x is unchanged)
</code></pre>
<p>Shadowing creates a new binding; it does not mutate the original variable.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="literals"><a class="header" href="#literals">Literals</a></h1>
<p>A literal is a notation for representing a fixed value in source code. Forge supports integer, float, string, raw string, boolean, null, array, and object literals.</p>
<h2 id="integer-literals"><a class="header" href="#integer-literals">Integer Literals</a></h2>
<blockquote>
<p><em>IntLiteral</em> → <em>Digit</em>+</p>
<p><em>Digit</em> → <code>0</code>-<code>9</code></p>
</blockquote>
<p>An integer literal is a sequence of one or more decimal digits. Integer literals produce values of type <code>Int</code> (64-bit signed integer).</p>
<pre><code class="language-forge">0
42
1000000
</code></pre>
<p>Negative integer values are expressed using the unary negation operator:</p>
<pre><code class="language-forge">let x = -42
</code></pre>
<p>Integer literals do not support underscores as digit separators, hexadecimal, octal, or binary notation in the current version.</p>
<h2 id="float-literals"><a class="header" href="#float-literals">Float Literals</a></h2>
<blockquote>
<p><em>FloatLiteral</em> → <em>Digit</em>+ <code>.</code> <em>Digit</em>+</p>
</blockquote>
<p>A float literal contains a decimal point with digits on both sides. Float literals produce values of type <code>Float</code> (64-bit IEEE 754 double-precision).</p>
<pre><code class="language-forge">3.14
0.5
100.0
</code></pre>
<p>A leading dot (<code>.5</code>) or trailing dot (<code>5.</code>) is not valid. Both sides of the decimal point must have at least one digit.</p>
<p>Negative float values use unary negation:</p>
<pre><code class="language-forge">let temp = -0.5
</code></pre>
<p>Scientific notation (e.g., <code>1.5e10</code>) is not supported in the current version.</p>
<h2 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h2>
<blockquote>
<p><em>StringLiteral</em> → <code>"</code> <em>StringContent</em>* <code>"</code></p>
<p><em>StringContent</em> → <em>Character</em> | <em>EscapeSequence</em> | <em>Interpolation</em></p>
<p><em>EscapeSequence</em> → <code>\n</code> | <code>\t</code> | <code>\\</code> | <code>\"</code></p>
<p><em>Interpolation</em> → <code>{</code> <em>Expression</em> <code>}</code></p>
</blockquote>
<p>A string literal is a sequence of characters enclosed in double quotes. String literals produce values of type <code>String</code> (UTF-8 encoded, immutable).</p>
<pre><code class="language-forge">"hello, world"
"line one\nline two"
"she said \"hi\""
</code></pre>
<h3 id="escape-sequences"><a class="header" href="#escape-sequences">Escape Sequences</a></h3>
<p>The following escape sequences are recognized within string literals:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Sequence</th><th>Character</th></tr>
</thead>
<tbody>
<tr><td><code>\n</code></td><td>Newline (U+000A)</td></tr>
<tr><td><code>\t</code></td><td>Horizontal tab (U+0009)</td></tr>
<tr><td><code>\\</code></td><td>Backslash (U+005C)</td></tr>
<tr><td><code>\"</code></td><td>Double quote (U+0022)</td></tr>
</tbody>
</table>
</div>
<h3 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h3>
<p>Curly braces within a string literal delimit an <em>interpolation expression</em>. The expression is evaluated at runtime, converted to a string, and inserted at that position:</p>
<pre><code class="language-forge">let name = "Forge"
let version = 3
say "Welcome to {name} v{version}!"
// Output: Welcome to Forge v3!
</code></pre>
<p>Interpolation supports arbitrary expressions, not just variable names:</p>
<pre><code class="language-forge">let x = 7
say "Seven squared is {x * x}"
say "Length: {len("hello")}"
say "Upper: {name}"
</code></pre>
<p>To include a literal <code>{</code> in a string without triggering interpolation, there is no dedicated escape sequence in the current version. Use string concatenation or a variable if needed.</p>
<h2 id="raw-string-literals"><a class="header" href="#raw-string-literals">Raw String Literals</a></h2>
<blockquote>
<p><em>RawStringLiteral</em> → <code>"""</code> <em>RawContent</em>* <code>"""</code></p>
</blockquote>
<p>A raw string literal is delimited by triple double quotes. Raw strings preserve their content exactly as written: no escape sequences are processed and no interpolation occurs.</p>
<pre><code class="language-forge">let sql = """SELECT * FROM users WHERE active = true"""

let html = """&lt;div class="container"&gt;
    &lt;h1&gt;Hello&lt;/h1&gt;
&lt;/div&gt;"""
</code></pre>
<p>Raw strings may span multiple lines. They are particularly useful for SQL queries, regular expressions, and embedded markup.</p>
<h2 id="boolean-literals"><a class="header" href="#boolean-literals">Boolean Literals</a></h2>
<blockquote>
<p><em>BoolLiteral</em> → <code>true</code> | <code>false</code></p>
</blockquote>
<p>The boolean literals <code>true</code> and <code>false</code> produce values of type <code>Bool</code>. They are keyword tokens.</p>
<pre><code class="language-forge">let active = true
let deleted = false
</code></pre>
<h2 id="null-literal"><a class="header" href="#null-literal">Null Literal</a></h2>
<blockquote>
<p><em>NullLiteral</em> → <code>null</code></p>
</blockquote>
<p>The <code>null</code> literal represents the absence of a value. It produces a value of type <code>Null</code>. It is a keyword token.</p>
<pre><code class="language-forge">let nothing = null
say typeof(nothing)  // Null
</code></pre>
<h2 id="array-literals"><a class="header" href="#array-literals">Array Literals</a></h2>
<blockquote>
<p><em>ArrayLiteral</em> → <code>[</code> ( <em>Expression</em> ( <code>,</code> <em>Expression</em> )* <code>,</code>? )? <code>]</code></p>
</blockquote>
<p>An array literal is a comma-separated list of expressions enclosed in square brackets. Arrays are ordered, heterogeneous (elements may have different types), and 0-indexed.</p>
<pre><code class="language-forge">let empty = []
let nums = [1, 2, 3]
let mixed = [1, "two", true, null]
let nested = [[1, 2], [3, 4]]
</code></pre>
<p>A trailing comma after the last element is permitted.</p>
<h2 id="object-literals"><a class="header" href="#object-literals">Object Literals</a></h2>
<blockquote>
<p><em>ObjectLiteral</em> → <code>{</code> ( <em>Field</em> ( <code>,</code> <em>Field</em> )* <code>,</code>? )? <code>}</code></p>
<p><em>Field</em> → <em>Identifier</em> <code>:</code> <em>Expression</em></p>
</blockquote>
<p>An object literal is a comma-separated list of key-value pairs enclosed in curly braces. Keys are identifiers (unquoted). Objects maintain insertion order.</p>
<pre><code class="language-forge">let empty = {}
let user = { name: "Alice", age: 30 }
let config = {
    host: "localhost",
    port: 8080,
    debug: false,
}
</code></pre>
<p>Object keys are strings at runtime, even though they appear as bare identifiers in the literal syntax. A trailing comma after the last field is permitted.</p>
<h3 id="shorthand-field-syntax"><a class="header" href="#shorthand-field-syntax">Shorthand Field Syntax</a></h3>
<p>When a variable name matches the desired key name, the value may be omitted:</p>
<pre><code class="language-forge">let name = "Alice"
let age = 30
let user = { name, age }
// Equivalent to: { name: "Alice", age: 30 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="operators-and-punctuation"><a class="header" href="#operators-and-punctuation">Operators and Punctuation</a></h1>
<p>This section defines all operator and punctuation tokens in Forge.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td>Plus</td><td><code>a + b</code></td><td>Addition; string concatenation</td></tr>
<tr><td><code>-</code></td><td>Minus</td><td><code>a - b</code></td><td>Subtraction; unary negation</td></tr>
<tr><td><code>*</code></td><td>Star</td><td><code>a * b</code></td><td>Multiplication</td></tr>
<tr><td><code>/</code></td><td>Slash</td><td><code>a / b</code></td><td>Division</td></tr>
<tr><td><code>%</code></td><td>Percent</td><td><code>a % b</code></td><td>Modulo (remainder)</td></tr>
</tbody>
</table>
</div>
<p>When both operands of <code>/</code> are integers, the result is an integer (truncating division). When either operand is a float, the result is a float.</p>
<p>The <code>+</code> operator is overloaded for string concatenation when both operands are strings.</p>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>==</code></td><td>Equal</td><td><code>a == b</code></td><td>Equality test</td></tr>
<tr><td><code>!=</code></td><td>Not equal</td><td><code>a != b</code></td><td>Inequality test</td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td><td><code>a &lt; b</code></td><td>Less-than comparison</td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td><td><code>a &gt; b</code></td><td>Greater-than comparison</td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equal</td><td><code>a &lt;= b</code></td><td>Less-than-or-equal</td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equal</td><td><code>a &gt;= b</code></td><td>Greater-than-or-equal</td></tr>
</tbody>
</table>
</div>
<p>All comparison operators return a <code>Bool</code> value. Strings are compared lexicographically.</p>
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>&amp;&amp;</code></td><td>Logical AND</td><td><code>a &amp;&amp; b</code></td><td>Short-circuit conjunction</td></tr>
<tr><td><code>||</code></td><td>Logical OR</td><td><code>a || b</code></td><td>Short-circuit disjunction</td></tr>
<tr><td><code>!</code></td><td>Logical NOT</td><td><code>!a</code></td><td>Unary boolean negation</td></tr>
</tbody>
</table>
</div>
<p>The keywords <code>and</code> and <code>or</code> are <strong>not</strong> reserved keywords in Forge. Logical operations use the symbolic <code>&amp;&amp;</code> and <code>||</code> forms exclusively. The <code>not</code> keyword is also not reserved; use the <code>!</code> prefix operator.</p>
<p>Both <code>&amp;&amp;</code> and <code>||</code> use short-circuit evaluation: the right operand is not evaluated if the result can be determined from the left operand alone.</p>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Equivalent</th></tr>
</thead>
<tbody>
<tr><td><code>=</code></td><td>Assignment</td><td><code>x = 5</code></td><td>—</td></tr>
<tr><td><code>+=</code></td><td>Add-assign</td><td><code>x += 5</code></td><td><code>x = x + 5</code></td></tr>
<tr><td><code>-=</code></td><td>Subtract-assign</td><td><code>x -= 3</code></td><td><code>x = x - 3</code></td></tr>
<tr><td><code>*=</code></td><td>Multiply-assign</td><td><code>x *= 2</code></td><td><code>x = x * 2</code></td></tr>
<tr><td><code>/=</code></td><td>Divide-assign</td><td><code>x /= 4</code></td><td><code>x = x / 4</code></td></tr>
</tbody>
</table>
</div>
<p>Assignment and compound assignment operators require the left-hand side to be a mutable variable (declared with <code>mut</code>). Compound assignment is syntactic sugar for the expanded form.</p>
<h2 id="member-access-and-navigation"><a class="header" href="#member-access-and-navigation">Member Access and Navigation</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>.</code></td><td>Dot</td><td><code>obj.field</code></td><td>Field access, method call</td></tr>
<tr><td><code>..</code></td><td>Range</td><td><code>1..10</code></td><td>Range constructor (exclusive end)</td></tr>
</tbody>
</table>
</div>
<p>The dot operator accesses fields on objects and struct instances, and invokes methods. It binds very tightly (highest precedence among binary operators).</p>
<p>The range operator <code>..</code> creates a range value from a start (inclusive) to an end (exclusive). It is used primarily with <code>for</code> loops and the <code>range()</code> built-in.</p>
<h2 id="pipe-operators"><a class="header" href="#pipe-operators">Pipe Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>|&gt;</code></td><td>Pipe</td><td><code>x |&gt; f</code></td><td>Pipe-forward: passes left as first argument to right</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Pipe right</td><td><code>x &gt;&gt; f</code></td><td>Alternate pipe operator</td></tr>
</tbody>
</table>
</div>
<p>The pipe operator passes the value on the left as the first argument to the function on the right:</p>
<pre><code class="language-forge">let result = [3, 1, 4, 1, 5]
    |&gt; sort
    |&gt; reverse
</code></pre>
<h2 id="spread-operator"><a class="header" href="#spread-operator">Spread Operator</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>...</code></td><td>Spread</td><td><code>[...arr, 4]</code></td><td>Spreads array/object elements</td></tr>
</tbody>
</table>
</div>
<p>The spread operator expands an array or object into individual elements within an array literal or object literal:</p>
<pre><code class="language-forge">let a = [1, 2, 3]
let b = [...a, 4, 5]       // [1, 2, 3, 4, 5]

let base = { x: 1, y: 2 }
let ext = { ...base, z: 3 } // { x: 1, y: 2, z: 3 }
</code></pre>
<h2 id="arrow-operators"><a class="header" href="#arrow-operators">Arrow Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>-&gt;</code></td><td>Arrow</td><td><code>&lt; 13 -&gt; "kid"</code></td><td>Arm separator in <code>when</code>/<code>match</code></td></tr>
<tr><td><code>=&gt;</code></td><td>Fat arrow</td><td><code>Ok(v) =&gt; say v</code></td><td>Arm separator in <code>match</code></td></tr>
</tbody>
</table>
</div>
<p>The thin arrow <code>-&gt;</code> is used in <code>when</code> guard arms. The fat arrow <code>=&gt;</code> is used in <code>match</code> pattern arms. Both separate a pattern/condition from its corresponding body.</p>
<h2 id="special-operators"><a class="header" href="#special-operators">Special Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>?</code></td><td>Question</td><td><code>expr?</code></td><td>Error propagation (Result/Option)</td></tr>
<tr><td><code>@</code></td><td>At</td><td><code>@test</code></td><td>Decorator prefix</td></tr>
<tr><td><code>&amp;</code></td><td>Ampersand</td><td>(reserved)</td><td>Reserved for future use</td></tr>
<tr><td><code>|</code></td><td>Bar</td><td><code>Circle(r) | Rect(w, h)</code></td><td>ADT variant separator</td></tr>
</tbody>
</table>
</div>
<p>The <code>?</code> postfix operator propagates errors: if the expression evaluates to <code>Err(e)</code>, the enclosing function returns <code>Err(e)</code> immediately. If the expression is <code>Ok(v)</code>, the <code>?</code> unwraps it to <code>v</code>.</p>
<h2 id="delimiters"><a class="header" href="#delimiters">Delimiters</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Name</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>(</code></td><td>Left paren</td><td>Function call, grouping</td></tr>
<tr><td><code>)</code></td><td>Right paren</td><td>Close function call, grouping</td></tr>
<tr><td><code>{</code></td><td>Left brace</td><td>Block, object literal, interpolation</td></tr>
<tr><td><code>}</code></td><td>Right brace</td><td>Close block, object, interpolation</td></tr>
<tr><td><code>[</code></td><td>Left bracket</td><td>Array literal, index access</td></tr>
<tr><td><code>]</code></td><td>Right bracket</td><td>Close array, index access</td></tr>
<tr><td><code>,</code></td><td>Comma</td><td>Separator in lists</td></tr>
<tr><td><code>:</code></td><td>Colon</td><td>Key-value separator, type annotation</td></tr>
<tr><td><code>;</code></td><td>Semicolon</td><td>Optional statement terminator</td></tr>
</tbody>
</table>
</div>
<h2 id="operator-precedence"><a class="header" href="#operator-precedence">Operator Precedence</a></h2>
<p>Operators are listed from highest to lowest precedence:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Precedence</th><th>Operators</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1 (highest)</td><td><code>.</code> (member access)</td><td>Left-to-right</td></tr>
<tr><td>2</td><td><code>()</code> (call), <code>[]</code> (index)</td><td>Left-to-right</td></tr>
<tr><td>3</td><td><code>!</code>, <code>-</code> (unary)</td><td>Right-to-left</td></tr>
<tr><td>4</td><td><code>*</code>, <code>/</code>, <code>%</code></td><td>Left-to-right</td></tr>
<tr><td>5</td><td><code>+</code>, <code>-</code></td><td>Left-to-right</td></tr>
<tr><td>6</td><td><code>..</code></td><td>Left-to-right</td></tr>
<tr><td>7</td><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>Left-to-right</td></tr>
<tr><td>8</td><td><code>==</code>, <code>!=</code></td><td>Left-to-right</td></tr>
<tr><td>9</td><td><code>&amp;&amp;</code></td><td>Left-to-right</td></tr>
<tr><td>10</td><td><code>||</code></td><td>Left-to-right</td></tr>
<tr><td>11</td><td><code>|&gt;</code></td><td>Left-to-right</td></tr>
<tr><td>12</td><td><code>?</code></td><td>Postfix</td></tr>
<tr><td>13 (lowest)</td><td><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></td><td>Right-to-left</td></tr>
</tbody>
</table>
</div>
<p>Parentheses may be used to override the default precedence.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Comments are annotations in source code intended for human readers. The lexer recognizes comments and discards them; they do not appear in the token stream and have no effect on program behavior.</p>
<p>Forge supports two forms of comments: line comments and block comments.</p>
<h2 id="line-comments"><a class="header" href="#line-comments">Line Comments</a></h2>
<blockquote>
<p><em>LineComment</em> → <code>//</code> <em>Character</em>* <em>Newline</em></p>
</blockquote>
<p>A line comment begins with <code>//</code> and extends to the end of the line (the next newline character or end of file). Everything after <code>//</code> on that line is ignored by the lexer.</p>
<pre><code class="language-forge">// This is a line comment
let x = 42  // This is an inline comment
</code></pre>
<p>Line comments may appear on their own line or at the end of a line containing code.</p>
<h2 id="block-comments"><a class="header" href="#block-comments">Block Comments</a></h2>
<blockquote>
<p><em>BlockComment</em> → <code>/*</code> <em>Character</em>* <code>*/</code></p>
</blockquote>
<p>A block comment begins with <code>/*</code> and ends with the next occurrence of <code>*/</code>. Block comments may span multiple lines.</p>
<pre><code class="language-forge">/* This is a block comment */

/*
  This block comment
  spans multiple lines.
*/

let x = /* inline block comment */ 42
</code></pre>
<p>Block comments do <strong>not</strong> nest. The first <code>*/</code> encountered after a <code>/*</code> ends the comment, regardless of any intervening <code>/*</code> sequences:</p>
<pre><code class="language-forge">/* outer /* inner */ this is NOT inside the comment */
</code></pre>
<p>In the example above, the comment ends at the first <code>*/</code>, and the text <code>this is NOT inside the comment */</code> would be parsed as code (and likely produce a syntax error).</p>
<h2 id="doc-comments"><a class="header" href="#doc-comments">Doc Comments</a></h2>
<p>Forge does not currently have a dedicated doc comment syntax (such as <code>///</code> or <code>/** */</code>). Documentation is written using regular line comments or block comments by convention.</p>
<h2 id="comments-in-string-literals"><a class="header" href="#comments-in-string-literals">Comments in String Literals</a></h2>
<p>Comment sequences (<code>//</code> and <code>/* */</code>) within string literals are part of the string content and are not treated as comments:</p>
<pre><code class="language-forge">let url = "https://example.com"   // The // in the string is not a comment
let msg = "use /* carefully */"    // The /* */ in the string is not a comment
</code></pre>
<h2 id="placement"><a class="header" href="#placement">Placement</a></h2>
<p>Comments may appear anywhere that whitespace is permitted. They cannot appear inside tokens (e.g., in the middle of an identifier or numeric literal).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>This chapter describes the type system of the Forge programming language.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Forge is <strong>dynamically typed</strong> at runtime: variables do not have fixed types, and any variable may hold a value of any type at any point during execution. However, Forge supports <strong>optional type annotations</strong> (gradual typing) on variable declarations, function parameters, and return types. These annotations serve as documentation and enable the optional type checker to detect certain errors before execution.</p>
<p>Every value in Forge belongs to exactly one of the following type categories:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Types</th></tr>
</thead>
<tbody>
<tr><td>Primitive</td><td><code>Int</code>, <code>Float</code>, <code>String</code>, <code>Bool</code>, <code>Null</code></td></tr>
<tr><td>Collection</td><td><code>Array</code>, <code>Object</code></td></tr>
<tr><td>Struct</td><td>User-defined via <code>struct</code> / <code>thing</code></td></tr>
<tr><td>Interface</td><td>User-defined via <code>interface</code> / <code>power</code></td></tr>
<tr><td>Function</td><td>Named functions, closures, lambdas</td></tr>
<tr><td>Algebraic (ADT)</td><td>User-defined via <code>type Name = Variant | ...</code></td></tr>
<tr><td>Result</td><td><code>Ok(value)</code>, <code>Err(message)</code></td></tr>
<tr><td>Option</td><td><code>Some(value)</code>, <code>None</code></td></tr>
</tbody>
</table>
</div>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>Type annotations use a colon after the name, followed by the type:</p>
<pre><code class="language-forge">let name: String = "Alice"
let age: Int = 30
let score: Float = 98.5
let active: Bool = true
</code></pre>
<p>Function parameters and return types may also be annotated:</p>
<pre><code class="language-forge">fn add(a: Int, b: Int) -&gt; Int {
    return a + b
}
</code></pre>
<p>When annotations are omitted, types are inferred from the assigned values. Annotations are always optional.</p>
<h2 id="type-inspection-at-runtime"><a class="header" href="#type-inspection-at-runtime">Type Inspection at Runtime</a></h2>
<p>The built-in <code>typeof()</code> function (aliased as <code>type()</code>) returns a string describing the runtime type of a value:</p>
<pre><code class="language-forge">say typeof(42)                 // Int
say typeof(3.14)               // Float
say typeof("hello")            // String
say typeof(true)               // Bool
say typeof(null)               // Null
say typeof([1, 2, 3])          // Array
say typeof({ name: "Alice" })  // Object
</code></pre>
<p>For struct instances, <code>typeof()</code> returns the struct name (e.g., <code>"Person"</code>).</p>
<h2 id="truthiness"><a class="header" href="#truthiness">Truthiness</a></h2>
<p>When a value is used in a boolean context (such as an <code>if</code> condition), Forge evaluates it as “truthy” or “falsy” according to the following rules:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Truthy?</th></tr>
</thead>
<tbody>
<tr><td><code>false</code></td><td>Falsy</td></tr>
<tr><td><code>null</code></td><td>Falsy</td></tr>
<tr><td><code>0</code> (integer zero)</td><td>Falsy</td></tr>
<tr><td><code>0.0</code> (float zero)</td><td>Falsy</td></tr>
<tr><td><code>""</code> (empty string)</td><td>Falsy</td></tr>
<tr><td><code>[]</code> (empty array)</td><td>Falsy</td></tr>
<tr><td>Everything else</td><td>Truthy</td></tr>
</tbody>
</table>
</div>
<h2 id="subsections-1"><a class="header" href="#subsections-1">Subsections</a></h2>
<p>The following subsections define each type category in detail:</p>
<ul>
<li><a href="#primitive-types">Primitive Types</a> — Int, Float, String, Bool, Null</li>
<li><a href="#collection-types">Collection Types</a> — Array, Object</li>
<li><a href="#struct-types">Struct Types</a> — <code>struct</code> / <code>thing</code> definitions</li>
<li><a href="#interface-types">Interface Types</a> — <code>interface</code> / <code>power</code> contracts</li>
<li><a href="#function-types">Function Types</a> — functions as first-class values</li>
<li><a href="#algebraic-data-types">Algebraic Data Types</a> — <code>type Name = Variant | ...</code></li>
<li><a href="#option-and-result">Option and Result</a> — <code>Option</code> and <code>Result</code> wrapper types</li>
<li><a href="#type-conversions">Type Conversions</a> — <code>str()</code>, <code>int()</code>, <code>float()</code>, <code>type()</code>, <code>typeof()</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Forge has five primitive types. Primitive values are immutable and compared by value.</p>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<p>The <code>Int</code> type represents a <strong>64-bit signed integer</strong>. Its range is -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (i.e., the range of a Rust <code>i64</code>).</p>
<pre><code class="language-forge">let x = 42
let y = -7
let z = 0
say typeof(x)  // Int
</code></pre>
<p>Integer arithmetic follows standard rules. Division between two integers produces an integer result (truncating toward zero):</p>
<pre><code class="language-forge">say 7 / 2    // 3
say -7 / 2   // -3
</code></pre>
<p>Integer overflow behavior is implementation-defined. The interpreter wraps on overflow (Rust’s default for <code>i64</code> in release mode).</p>
<h2 id="float"><a class="header" href="#float">Float</a></h2>
<p>The <code>Float</code> type represents a <strong>64-bit IEEE 754 double-precision floating-point number</strong>. This provides approximately 15-17 significant decimal digits of precision.</p>
<pre><code class="language-forge">let pi = 3.14159
let temp = -0.5
let one = 1.0
say typeof(pi)  // Float
</code></pre>
<p>When an arithmetic operation involves both an <code>Int</code> and a <code>Float</code>, the integer is implicitly promoted to a float, and the result is a <code>Float</code>:</p>
<pre><code class="language-forge">say 5 + 2.0    // 7.0
say 10 / 3.0   // 3.3333333333333335
</code></pre>
<p>Special float values (<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>) may arise from operations like division by zero on floats, but there is no literal syntax for these values.</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>The <code>String</code> type represents an immutable sequence of <strong>UTF-8 encoded characters</strong>. Strings are created using double-quoted literals and support interpolation and escape sequences (see <a href="#literals">Literals</a>).</p>
<pre><code class="language-forge">let greeting = "Hello, World!"
let empty = ""
let multiline = """This is
a raw string."""
say typeof(greeting)  // String
</code></pre>
<h3 id="key-properties"><a class="header" href="#key-properties">Key Properties</a></h3>
<ul>
<li><strong>Immutable.</strong> String operations always return new strings; the original is never modified.</li>
<li><strong>UTF-8.</strong> All strings are valid UTF-8. The <code>len()</code> function returns the number of bytes, not Unicode code points.</li>
<li><strong>Interpolation.</strong> Double-quoted strings support <code>{expr}</code> interpolation. Raw strings (<code>"""..."""</code>) do not.</li>
<li><strong>Concatenation.</strong> The <code>+</code> operator concatenates two strings.</li>
</ul>
<pre><code class="language-forge">let name = "Forge"
let version = 3
say "Welcome to {name} v{version}!"  // Welcome to Forge v3!
say "Hello" + ", " + "World!"         // Hello, World!
</code></pre>
<h3 id="string-comparison"><a class="header" href="#string-comparison">String Comparison</a></h3>
<p>Strings are compared lexicographically (byte-by-byte) using the standard comparison operators:</p>
<pre><code class="language-forge">say "apple" &lt; "banana"   // true
say "hello" == "hello"   // true
</code></pre>
<h2 id="bool"><a class="header" href="#bool">Bool</a></h2>
<p>The <code>Bool</code> type has exactly two values: <code>true</code> and <code>false</code>.</p>
<pre><code class="language-forge">let active = true
let deleted = false
say typeof(active)  // Bool
</code></pre>
<p>Boolean values result from comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) and logical operators (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>). They are the natural type for <code>if</code> conditions, <code>while</code> conditions, and other control flow predicates.</p>
<h3 id="logical-operations"><a class="header" href="#logical-operations">Logical Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>true &amp;&amp; true</code></td><td><code>true</code></td></tr>
<tr><td><code>true &amp;&amp; false</code></td><td><code>false</code></td></tr>
<tr><td><code>false || true</code></td><td><code>true</code></td></tr>
<tr><td><code>!true</code></td><td><code>false</code></td></tr>
</tbody>
</table>
</div>
<p>Both <code>&amp;&amp;</code> and <code>||</code> use short-circuit evaluation.</p>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<p>The <code>Null</code> type has exactly one value: <code>null</code>. It represents the absence of a meaningful value.</p>
<pre><code class="language-forge">let nothing = null
say typeof(nothing)  // Null
</code></pre>
<p><code>null</code> is returned by functions that have no explicit <code>return</code> statement. It is falsy in boolean contexts.</p>
<h3 id="null-vs-none"><a class="header" href="#null-vs-none">Null vs. None</a></h3>
<p>Forge distinguishes between <code>null</code> and <code>None</code>:</p>
<ul>
<li><code>null</code> is a bare value representing “no value.” It is a primitive.</li>
<li><code>None</code> is a variant of the <code>Option</code> type representing “intentionally absent.” It is a wrapper.</li>
</ul>
<p>In practice, <code>null</code> appears in dynamic code and untyped contexts, while <code>None</code> is used in the <code>Option</code>/<code>Result</code> error-handling pattern. See <a href="#option-and-result">Option and Result</a> for details.</p>
<h2 id="type-comparison-summary"><a class="header" href="#type-comparison-summary">Type Comparison Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Size</th><th>Default Value</th><th>Falsy Values</th><th>Mutable</th></tr>
</thead>
<tbody>
<tr><td><code>Int</code></td><td>64 bits</td><td>—</td><td><code>0</code></td><td>No</td></tr>
<tr><td><code>Float</code></td><td>64 bits</td><td>—</td><td><code>0.0</code></td><td>No</td></tr>
<tr><td><code>String</code></td><td>Variable</td><td>—</td><td><code>""</code></td><td>No</td></tr>
<tr><td><code>Bool</code></td><td>1 bit</td><td>—</td><td><code>false</code></td><td>No</td></tr>
<tr><td><code>Null</code></td><td>0 bits</td><td><code>null</code></td><td><code>null</code></td><td>No</td></tr>
</tbody>
</table>
</div>
<p>All primitive types are compared by value. Two integers with the same numeric value are equal regardless of how they were computed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h1>
<p>Forge has two built-in collection types: <code>Array</code> and <code>Object</code>. Both are mutable, heap-allocated, and compared by reference for identity but by value for equality.</p>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>An array is an <strong>ordered, heterogeneous, 0-indexed</strong> sequence of values. Elements may be of any type, including other arrays and objects.</p>
<h3 id="creation"><a class="header" href="#creation">Creation</a></h3>
<p>Arrays are created with square bracket literals:</p>
<pre><code class="language-forge">let empty = []
let nums = [1, 2, 3]
let mixed = [1, "two", true, null]
let nested = [[1, 2], [3, 4]]
</code></pre>
<h3 id="indexing"><a class="header" href="#indexing">Indexing</a></h3>
<p>Elements are accessed by zero-based integer index using bracket notation:</p>
<pre><code class="language-forge">let fruits = ["apple", "banana", "cherry"]
say fruits[0]   // apple
say fruits[1]   // banana
say fruits[2]   // cherry
</code></pre>
<p>Negative indices count from the end of the array:</p>
<pre><code class="language-forge">say fruits[-1]  // cherry
</code></pre>
<p>Accessing an out-of-bounds index produces a runtime error.</p>
<h3 id="mutation"><a class="header" href="#mutation">Mutation</a></h3>
<p>Arrays are mutable. Elements can be replaced by index assignment:</p>
<pre><code class="language-forge">let mut items = [1, 2, 3]
items[0] = 10
say items  // [10, 2, 3]
</code></pre>
<p>The <code>push()</code> built-in appends an element:</p>
<pre><code class="language-forge">let mut items = [1, 2]
push(items, 3)
say items  // [1, 2, 3]
</code></pre>
<p>The <code>pop()</code> built-in removes and returns the last element:</p>
<pre><code class="language-forge">let mut items = [1, 2, 3]
let last = pop(items)
say last   // 3
say items  // [1, 2]
</code></pre>
<h3 id="length"><a class="header" href="#length">Length</a></h3>
<p>The <code>len()</code> built-in returns the number of elements:</p>
<pre><code class="language-forge">say len([1, 2, 3])  // 3
say len([])          // 0
</code></pre>
<h3 id="spread"><a class="header" href="#spread">Spread</a></h3>
<p>The spread operator <code>...</code> expands an array within another array literal:</p>
<pre><code class="language-forge">let a = [1, 2, 3]
let b = [...a, 4, 5]
say b  // [1, 2, 3, 4, 5]
</code></pre>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<p>Arrays are iterable with <code>for</code>/<code>in</code>:</p>
<pre><code class="language-forge">for item in [10, 20, 30] {
    say item
}
</code></pre>
<p>With <code>enumerate()</code> for index-value pairs:</p>
<pre><code class="language-forge">for i, item in enumerate(["a", "b", "c"]) {
    say "{i}: {item}"
}
</code></pre>
<h3 id="functional-operations"><a class="header" href="#functional-operations">Functional Operations</a></h3>
<p>Arrays support <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>sort</code>, <code>reverse</code>, <code>find</code>, <code>flat_map</code>, <code>any</code>, <code>all</code>, and other functional built-ins:</p>
<pre><code class="language-forge">let nums = [1, 2, 3, 4, 5]
let doubled = map(nums, fn(x) { return x * 2 })
let evens = filter(nums, fn(x) { return x % 2 == 0 })
let sum = reduce(nums, 0, fn(acc, x) { return acc + x })
</code></pre>
<h3 id="truthiness-1"><a class="header" href="#truthiness-1">Truthiness</a></h3>
<p>An empty array <code>[]</code> is falsy. All non-empty arrays are truthy.</p>
<h2 id="object"><a class="header" href="#object">Object</a></h2>
<p>An object is an <strong>insertion-ordered map</strong> from string keys to arbitrary values. Objects are Forge’s general-purpose key-value data structure.</p>
<h3 id="creation-1"><a class="header" href="#creation-1">Creation</a></h3>
<p>Objects are created with curly brace literals:</p>
<pre><code class="language-forge">let empty = {}
let user = { name: "Alice", age: 30 }
let config = {
    host: "localhost",
    port: 8080,
    debug: false,
}
</code></pre>
<p>Keys are written as bare identifiers in the literal syntax. At runtime, they are strings.</p>
<h3 id="field-access"><a class="header" href="#field-access">Field Access</a></h3>
<p>Fields are accessed with dot notation or bracket notation:</p>
<pre><code class="language-forge">let user = { name: "Alice", age: 30 }
say user.name       // Alice
say user["age"]     // 30
</code></pre>
<p>Dot notation requires the field name to be a valid identifier. Bracket notation accepts any string expression, making it suitable for dynamic keys:</p>
<pre><code class="language-forge">let key = "name"
say user[key]  // Alice
</code></pre>
<h3 id="mutation-1"><a class="header" href="#mutation-1">Mutation</a></h3>
<p>Objects are mutable. Fields can be added, updated, or accessed dynamically:</p>
<pre><code class="language-forge">let mut obj = { x: 1 }
obj.y = 2
obj.x = 10
say obj  // { x: 10, y: 2 }
</code></pre>
<h3 id="key-operations"><a class="header" href="#key-operations">Key Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>keys(obj)</code></td><td>Returns array of keys</td></tr>
<tr><td><code>values(obj)</code></td><td>Returns array of values</td></tr>
<tr><td><code>entries(obj)</code></td><td>Returns array of <code>[key, value]</code> pairs</td></tr>
<tr><td><code>has_key(obj, k)</code></td><td>Returns true if key exists</td></tr>
<tr><td><code>len(obj)</code></td><td>Returns number of key-value pairs</td></tr>
<tr><td><code>merge(a, b)</code></td><td>Returns new object merging <code>b</code> into <code>a</code></td></tr>
<tr><td><code>pick(obj, ks)</code></td><td>Returns object with only specified keys</td></tr>
<tr><td><code>omit(obj, ks)</code></td><td>Returns object without specified keys</td></tr>
</tbody>
</table>
</div>
<h3 id="spread-1"><a class="header" href="#spread-1">Spread</a></h3>
<p>The spread operator expands an object within another object literal:</p>
<pre><code class="language-forge">let base = { x: 1, y: 2 }
let ext = { ...base, z: 3 }
say ext  // { x: 1, y: 2, z: 3 }
</code></pre>
<p>When keys conflict, later values overwrite earlier ones:</p>
<pre><code class="language-forge">let a = { x: 1, y: 2 }
let b = { ...a, x: 10 }
say b  // { x: 10, y: 2 }
</code></pre>
<h3 id="iteration-1"><a class="header" href="#iteration-1">Iteration</a></h3>
<p>Objects are iterable. A <code>for</code>/<code>in</code> loop over an object yields <code>[key, value]</code> pairs in insertion order:</p>
<pre><code class="language-forge">let user = { name: "Alice", age: 30 }
for key, value in user {
    say "{key}: {value}"
}
</code></pre>
<h3 id="truthiness-1-1"><a class="header" href="#truthiness-1-1">Truthiness</a></h3>
<p>An empty object <code>{}</code> is truthy (unlike empty arrays, which are falsy). All objects, including empty ones, are truthy.</p>
<h3 id="objects-vs-structs"><a class="header" href="#objects-vs-structs">Objects vs. Structs</a></h3>
<p>Plain objects are untyped: any object can have any set of keys. Structs (defined with <code>struct</code> or <code>thing</code>) provide named types with declared fields, type annotations, default values, and methods. Under the hood, struct instances are objects with a <code>__type__</code> field. See <a href="#struct-types">Struct Types</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="struct-types"><a class="header" href="#struct-types">Struct Types</a></h1>
<p>A struct defines a <strong>named data type</strong> with declared fields, optional type annotations, and optional default values. Structs are the primary mechanism for defining domain-specific types in Forge.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>Structs are defined with the <code>struct</code> keyword (classic syntax) or the <code>thing</code> keyword (natural syntax). Both forms are equivalent.</p>
<blockquote>
<p><em>StructDef</em> → ( <code>struct</code> | <code>thing</code> ) <em>Identifier</em> <code>{</code> <em>FieldList</em> <code>}</code></p>
<p><em>FieldList</em> → ( <em>Field</em> ( <code>,</code> <em>Field</em> )* <code>,</code>? )?</p>
<p><em>Field</em> → <em>Identifier</em> <code>:</code> <em>TypeAnnotation</em> ( <code>=</code> <em>Expression</em> )? | <code>has</code> <em>Identifier</em> <code>:</code> <em>TypeAnnotation</em></p>
</blockquote>
<pre><code class="language-forge">// Classic syntax
struct Point {
    x: Int,
    y: Int
}

// Natural syntax — identical result
thing Point {
    x: Int,
    y: Int
}
</code></pre>
<p>Field type annotations are part of the struct definition syntax. Each field has a name, a colon, and a type name.</p>
<h2 id="default-values"><a class="header" href="#default-values">Default Values</a></h2>
<p>Fields may have default values. If a field with a default is omitted during construction, the default value is used:</p>
<pre><code class="language-forge">thing Config {
    host: String = "localhost",
    port: Int = 8080,
    debug: Bool = false
}

set cfg to craft Config {}
say cfg.host   // localhost
say cfg.port   // 8080
say cfg.debug  // false
</code></pre>
<p>Fields without defaults are required — omitting them during construction produces a runtime error.</p>
<pre><code class="language-forge">set prod to craft Config { host: "api.example.com", port: 443 }
say prod.host   // api.example.com
say prod.debug  // false (default)
</code></pre>
<h2 id="construction"><a class="header" href="#construction">Construction</a></h2>
<p>There are two ways to create a struct instance:</p>
<h3 id="direct-construction-classic"><a class="header" href="#direct-construction-classic">Direct Construction (Classic)</a></h3>
<p>Use the type name followed by a field initializer block:</p>
<pre><code class="language-forge">let p = Point { x: 3, y: 4 }
</code></pre>
<h3 id="craft-construction-natural"><a class="header" href="#craft-construction-natural">Craft Construction (Natural)</a></h3>
<p>Use the <code>craft</code> keyword:</p>
<pre><code class="language-forge">set p to craft Point { x: 3, y: 4 }
</code></pre>
<p>Both forms produce the same value: an object with the declared fields plus a <code>__type__</code> field set to the struct name.</p>
<h2 id="field-access-1"><a class="header" href="#field-access-1">Field Access</a></h2>
<p>Fields are accessed with dot notation:</p>
<pre><code class="language-forge">let p = Point { x: 3, y: 4 }
say p.x  // 3
say p.y  // 4
</code></pre>
<h2 id="the-__type__-field"><a class="header" href="#the-__type__-field">The <code>__type__</code> Field</a></h2>
<p>Every struct instance has an internal <code>__type__</code> field containing the struct name as a string. This field is set automatically during construction and is used by the runtime for method dispatch, interface satisfaction checking, and <code>typeof()</code>:</p>
<pre><code class="language-forge">let p = Point { x: 3, y: 4 }
say typeof(p)  // Point
</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Methods are attached to a struct using <code>give</code> (natural) or <code>impl</code> (classic) blocks. See <a href="#method-blocks">Method Blocks</a> for full details.</p>
<pre><code class="language-forge">give Point {
    define distance(it) {
        return math.sqrt(it.x * it.x + it.y * it.y)
    }
}

let p = Point { x: 3, y: 4 }
say p.distance()  // 5.0
</code></pre>
<p>The first parameter <code>it</code> is the receiver. When <code>p.distance()</code> is called, <code>p</code> is automatically bound to <code>it</code>.</p>
<h3 id="static-methods"><a class="header" href="#static-methods">Static Methods</a></h3>
<p>If a method’s first parameter is not <code>it</code>, it is a static method called on the type rather than on an instance:</p>
<pre><code class="language-forge">give Person {
    define infant(name) {
        return craft Person { name: name, age: 0 }
    }
}

set baby to Person.infant("Bob")
</code></pre>
<h3 id="multiple-give-blocks"><a class="header" href="#multiple-give-blocks">Multiple <code>give</code> Blocks</a></h3>
<p>Multiple <code>give</code> blocks for the same type are permitted. Methods accumulate across all blocks:</p>
<pre><code class="language-forge">give Person {
    define greet(it) {
        return "Hi, I'm " + it.name
    }
}

give Person {
    define birthday(it) {
        return craft Person { name: it.name, age: it.age + 1 }
    }
}
</code></pre>
<h2 id="composition-with-has"><a class="header" href="#composition-with-has">Composition with <code>has</code></a></h2>
<p>The <code>has</code> keyword inside a struct body embeds one type within another, enabling field and method delegation:</p>
<pre><code class="language-forge">thing Address {
    street: String,
    city: String
}

thing Employee {
    name: String,
    has addr: Address
}
</code></pre>
<p>The <code>has</code> keyword provides two delegation mechanisms:</p>
<ol>
<li>
<p><strong>Field delegation.</strong> Accessing a field that does not exist on the outer type delegates to the embedded type. <code>emp.city</code> resolves to <code>emp.addr.city</code>.</p>
</li>
<li>
<p><strong>Method delegation.</strong> Calling a method that does not exist on the outer type delegates to the embedded type. <code>emp.full()</code> resolves to <code>emp.addr.full()</code>.</p>
</li>
</ol>
<pre><code class="language-forge">give Address {
    define full(it) {
        return it.street + ", " + it.city
    }
}

set emp to craft Employee {
    name: "Charlie",
    addr: craft Address { street: "123 Main St", city: "Portland" }
}

say emp.city     // Portland (delegated)
say emp.full()   // 123 Main St, Portland (delegated)
</code></pre>
<p>The explicit path (<code>emp.addr.city</code>) also works and produces the same result.</p>
<h2 id="struct-vs-object"><a class="header" href="#struct-vs-object">Struct vs. Object</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Object</th><th>Struct</th></tr>
</thead>
<tbody>
<tr><td>Type identity</td><td>None (generic <code>Object</code>)</td><td>Named (<code>__type__</code> field)</td></tr>
<tr><td>Field declarations</td><td>No</td><td>Yes, with type annotations</td></tr>
<tr><td>Default values</td><td>No</td><td>Yes</td></tr>
<tr><td>Methods</td><td>No</td><td>Yes (via <code>give</code>/<code>impl</code>)</td></tr>
<tr><td>Interface satisfaction</td><td>No</td><td>Yes (via <code>give...the power</code>)</td></tr>
<tr><td>Construction</td><td><code>{ key: value }</code></td><td><code>Name { }</code> or <code>craft Name { }</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="interface-types"><a class="header" href="#interface-types">Interface Types</a></h1>
<p>An interface (or “power” in natural syntax) defines a <strong>contract</strong>: a set of method signatures that a type must provide. Interfaces enable polymorphism in Forge — any type that satisfies an interface’s contract can be used wherever that interface is expected.</p>
<h2 id="definition-1"><a class="header" href="#definition-1">Definition</a></h2>
<p>Interfaces are defined with the <code>interface</code> keyword (classic) or the <code>power</code> keyword (natural).</p>
<blockquote>
<p><em>InterfaceDef</em> → ( <code>interface</code> | <code>power</code> ) <em>Identifier</em> <code>{</code> <em>MethodSignature</em>* <code>}</code></p>
<p><em>MethodSignature</em> → <code>fn</code> <em>Identifier</em> <code>(</code> <em>ParamList</em>? <code>)</code> ( <code>-&gt;</code> <em>Type</em> )?</p>
</blockquote>
<pre><code class="language-forge">// Classic syntax
interface Describable {
    fn describe() -&gt; String
}

// Natural syntax — identical result
power Describable {
    fn describe() -&gt; String
}
</code></pre>
<p>An interface body contains one or more method signatures. Each signature specifies the method name, parameter types, and optional return type. No method body is provided — interfaces declare <em>what</em> methods must exist, not <em>how</em> they work.</p>
<h2 id="implementing-an-interface"><a class="header" href="#implementing-an-interface">Implementing an Interface</a></h2>
<p>A type satisfies an interface by providing implementations of all required methods. This is done using <code>give ... the power ...</code> (natural) or <code>impl ... for ...</code> (classic).</p>
<pre><code class="language-forge">thing Person {
    name: String,
    age: Int
}

// Natural syntax
give Person the power Describable {
    define describe(it) {
        return it.name + " (" + str(it.age) + ")"
    }
}

// Classic syntax — identical result
impl Describable for Person {
    fn describe(it) {
        return it.name + " (" + str(it.age) + ")"
    }
}
</code></pre>
<p>The implementation block must provide a method for every signature in the interface. Missing methods produce a compile-time (definition-time) error.</p>
<h2 id="checking-satisfaction"><a class="header" href="#checking-satisfaction">Checking Satisfaction</a></h2>
<p>The <code>satisfies()</code> built-in function checks whether a value’s type satisfies a given interface at runtime:</p>
<pre><code class="language-forge">set alice to craft Person { name: "Alice", age: 30 }
say satisfies(alice, Describable)   // true
</code></pre>
<p>If a type has not implemented the interface, <code>satisfies()</code> returns <code>false</code>:</p>
<pre><code class="language-forge">thing Robot {
    id: Int
}

set r to craft Robot { id: 1 }
say satisfies(r, Describable)   // false
</code></pre>
<h2 id="multiple-interfaces"><a class="header" href="#multiple-interfaces">Multiple Interfaces</a></h2>
<p>A single type may implement multiple interfaces:</p>
<pre><code class="language-forge">power Describable {
    fn describe() -&gt; String
}

power Vocal {
    fn speak() -&gt; String
}

thing Animal {
    species: String,
    sound: String
}

give Animal the power Describable {
    define describe(it) {
        return it.species + " that says " + it.sound
    }
}

give Animal the power Vocal {
    define speak(it) {
        return it.sound + "! " + it.sound + "!"
    }
}
</code></pre>
<p>Each interface implementation is provided in a separate <code>give...the power</code> block. A type accumulates all its interface implementations.</p>
<h2 id="no-default-implementations"><a class="header" href="#no-default-implementations">No Default Implementations</a></h2>
<p>In the current version of Forge, interfaces cannot provide default method implementations. Every method in an interface must be explicitly implemented by each type that satisfies it.</p>
<h2 id="interface-inheritance"><a class="header" href="#interface-inheritance">Interface Inheritance</a></h2>
<p>Interface inheritance (one interface extending another) is not supported in the current version. Each interface is independent.</p>
<h2 id="structural-vs-nominal"><a class="header" href="#structural-vs-nominal">Structural vs. Nominal</a></h2>
<p>Forge uses a <strong>nominal</strong> approach to interface satisfaction: a type satisfies an interface only if it has been explicitly declared to do so via a <code>give...the power</code> or <code>impl...for</code> block. Simply having methods with matching names and signatures is not sufficient.</p>
<p>However, the <code>satisfies()</code> built-in performs a <strong>structural check</strong> at runtime — it verifies that the required methods actually exist on the value. This means satisfaction is ultimately determined by the presence of the declared methods, but the declaration is required to register the type-interface relationship.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="function-types"><a class="header" href="#function-types">Function Types</a></h1>
<p>Functions are <strong>first-class values</strong> in Forge. They can be stored in variables, passed as arguments, returned from other functions, and placed in data structures.</p>
<h2 id="named-functions"><a class="header" href="#named-functions">Named Functions</a></h2>
<p>A named function is declared with <code>fn</code> (classic) or <code>define</code> (natural):</p>
<pre><code class="language-forge">fn add(a, b) {
    return a + b
}

define multiply(a, b) {
    return a * b
}
</code></pre>
<p>Named functions are hoisted within their scope — they can be called before their textual definition in the source file.</p>
<h2 id="anonymous-functions-closures"><a class="header" href="#anonymous-functions-closures">Anonymous Functions (Closures)</a></h2>
<p>An anonymous function is created with the <code>fn</code> keyword in expression position:</p>
<pre><code class="language-forge">let double = fn(x) { return x * 2 }
say double(21)  // 42
</code></pre>
<p>Anonymous functions are also called closures because they capture variables from their enclosing scope.</p>
<h2 id="closure-semantics"><a class="header" href="#closure-semantics">Closure Semantics</a></h2>
<p>Closures capture variables from the enclosing scope <strong>by reference</strong>. The closure retains access to the captured variables for its entire lifetime:</p>
<pre><code class="language-forge">fn make_counter() {
    let mut count = 0
    return fn() {
        count = count + 1
        return count
    }
}

let counter = make_counter()
say counter()  // 1
say counter()  // 2
say counter()  // 3
</code></pre>
<p>Each call to <code>make_counter()</code> creates a new independent closure with its own <code>count</code> variable.</p>
<h3 id="factory-pattern"><a class="header" href="#factory-pattern">Factory Pattern</a></h3>
<p>Closures are commonly used to create specialized functions:</p>
<pre><code class="language-forge">fn make_adder(n) {
    return fn(x) {
        return x + n
    }
}

let add5 = make_adder(5)
let add10 = make_adder(10)
say add5(3)   // 8
say add10(3)  // 13
</code></pre>
<h2 id="functions-as-arguments-higher-order-functions"><a class="header" href="#functions-as-arguments-higher-order-functions">Functions as Arguments (Higher-Order Functions)</a></h2>
<p>Functions can be passed as arguments to other functions:</p>
<pre><code class="language-forge">fn apply(f, value) {
    return f(value)
}

fn square(x) { return x * x }
say apply(square, 7)  // 49
</code></pre>
<p>The built-in <code>map</code>, <code>filter</code>, <code>reduce</code>, and <code>sort</code> functions all accept function arguments:</p>
<pre><code class="language-forge">let nums = [1, 2, 3, 4, 5]
let doubled = map(nums, fn(x) { return x * 2 })
say doubled  // [2, 4, 6, 8, 10]
</code></pre>
<h2 id="functions-in-data-structures"><a class="header" href="#functions-in-data-structures">Functions in Data Structures</a></h2>
<p>Functions can be stored in arrays and objects:</p>
<pre><code class="language-forge">fn add(a, b) { return a + b }
fn sub(a, b) { return a - b }

let ops = [add, sub]
say ops[0](10, 3)  // 13
say ops[1](10, 3)  // 7
</code></pre>
<pre><code class="language-forge">let handlers = {
    greet: fn(name) { return "Hello, {name}!" },
    farewell: fn(name) { return "Goodbye, {name}!" }
}
say handlers.greet("World")  // Hello, World!
</code></pre>
<h2 id="type-annotated-functions"><a class="header" href="#type-annotated-functions">Type-Annotated Functions</a></h2>
<p>Function parameters and return values may carry type annotations:</p>
<pre><code class="language-forge">fn add(a: Int, b: Int) -&gt; Int {
    return a + b
}

fn format_price(amount: Float) -&gt; String {
    return "${amount}"
}
</code></pre>
<p>Annotations are optional and serve as documentation. The optional type checker can use them to report errors before execution.</p>
<h2 id="return-values"><a class="header" href="#return-values">Return Values</a></h2>
<p>Functions return a value via the <code>return</code> statement. If no <code>return</code> is executed, the function returns <code>null</code>:</p>
<pre><code class="language-forge">fn greet(name) {
    println("Hello, {name}!")
}

let result = greet("World")
say typeof(result)  // Null
</code></pre>
<p>A function may return early from any point:</p>
<pre><code class="language-forge">fn classify(n) {
    if n &lt; 0 { return "negative" }
    if n == 0 { return "zero" }
    return "positive"
}
</code></pre>
<h2 id="async-functions"><a class="header" href="#async-functions">Async Functions</a></h2>
<p>Async functions are declared with <code>async fn</code> (classic) or <code>forge</code> (natural):</p>
<pre><code class="language-forge">// Classic
async fn fetch_data() {
    let resp = await http.get("https://api.example.com/data")
    return resp
}

// Natural
forge fetch_data() {
    let resp = hold http.get("https://api.example.com/data")
    return resp
}
</code></pre>
<p>Async functions return a future that must be awaited with <code>await</code> (classic) or <code>hold</code> (natural). See <a href="#concurrency">Concurrency</a> for details.</p>
<h2 id="function-equality"><a class="header" href="#function-equality">Function Equality</a></h2>
<p>Functions are compared by <strong>reference identity</strong>, not by their code. Two function values are equal only if they refer to the same function object:</p>
<pre><code class="language-forge">fn f() { return 1 }
let a = f
let b = f
say a == b  // true (same function object)

let c = fn() { return 1 }
say a == c  // false (different function objects)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h1>
<p>Algebraic data types (ADTs) define a type as a fixed set of <strong>variants</strong>. Each variant may optionally carry data. ADTs enable exhaustive pattern matching — the compiler/runtime can verify that all variants are handled.</p>
<h2 id="definition-2"><a class="header" href="#definition-2">Definition</a></h2>
<p>An ADT is defined with the <code>type</code> keyword, listing variants separated by <code>|</code>:</p>
<blockquote>
<p><em>ADTDef</em> → <code>type</code> <em>Identifier</em> <code>=</code> <em>Variant</em> ( <code>|</code> <em>Variant</em> )*</p>
<p><em>Variant</em> → <em>Identifier</em> ( <code>(</code> <em>TypeList</em> <code>)</code> )?</p>
<p><em>TypeList</em> → <em>Type</em> ( <code>,</code> <em>Type</em> )*</p>
</blockquote>
<h3 id="unit-variants"><a class="header" href="#unit-variants">Unit Variants</a></h3>
<p>Variants without data fields are called unit variants:</p>
<pre><code class="language-forge">type Color = Red | Green | Blue
</code></pre>
<p>Unit variants are used as simple enumeration values:</p>
<pre><code class="language-forge">set c to Red
say c  // Red
</code></pre>
<h3 id="data-variants"><a class="header" href="#data-variants">Data Variants</a></h3>
<p>Variants may carry typed data fields:</p>
<pre><code class="language-forge">type Shape = Circle(Float) | Rect(Float, Float)
</code></pre>
<p>Data variants are constructed by calling the variant name as a function:</p>
<pre><code class="language-forge">set circle to Circle(5.0)
set rect to Rect(3.0, 4.0)
say circle  // Circle(5.0)
say rect    // Rect(3.0, 4.0)
</code></pre>
<h3 id="mixed-variants"><a class="header" href="#mixed-variants">Mixed Variants</a></h3>
<p>An ADT may freely mix unit variants and data variants:</p>
<pre><code class="language-forge">type Result = Ok(String) | Err(String) | Pending
</code></pre>
<h2 id="construction-1"><a class="header" href="#construction-1">Construction</a></h2>
<p>Unit variants are referenced by name alone:</p>
<pre><code class="language-forge">let color = Red
</code></pre>
<p>Data variants are constructed by calling the variant name with the appropriate arguments:</p>
<pre><code class="language-forge">let shape = Circle(5.0)
let rect = Rect(3.0, 4.0)
</code></pre>
<p>The number and types of arguments must match the variant definition.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>ADT values are destructured using <code>match</code> expressions. Each arm matches a variant and optionally binds its data fields to variables.</p>
<h3 id="basic-matching"><a class="header" href="#basic-matching">Basic Matching</a></h3>
<pre><code class="language-forge">type Color = Red | Green | Blue

let c = Red

match c {
    Red =&gt; say "Red!"
    Green =&gt; say "Green!"
    Blue =&gt; say "Blue!"
}
</code></pre>
<h3 id="destructuring-data-variants"><a class="header" href="#destructuring-data-variants">Destructuring Data Variants</a></h3>
<p>Data fields are bound to named variables in the match arm:</p>
<pre><code class="language-forge">type Shape = Circle(Float) | Rect(Float, Float)

define describe_shape(s) {
    match s {
        Circle(r) =&gt; {
            say "Circle with radius {r}, area = {3.14159 * r * r}"
        }
        Rect(w, h) =&gt; {
            say "Rectangle {w}x{h}, area = {w * h}"
        }
    }
}

describe_shape(Circle(5.0))
// Output: Circle with radius 5.0, area = 78.53975

describe_shape(Rect(3.0, 4.0))
// Output: Rectangle 3.0x4.0, area = 12.0
</code></pre>
<h3 id="match-as-expression"><a class="header" href="#match-as-expression">Match as Expression</a></h3>
<p><code>match</code> can be used as an expression that returns a value:</p>
<pre><code class="language-forge">let area = match shape {
    Circle(r) =&gt; 3.14159 * r * r
    Rect(w, h) =&gt; w * h
}
</code></pre>
<h3 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h3>
<p>A <code>match</code> expression on an ADT should handle all variants. If a variant is missing, the runtime will produce an error when an unhandled variant is encountered.</p>
<pre><code class="language-forge">type Color = Red | Green | Blue

// This handles all variants
match c {
    Red =&gt; say "Red!"
    Green =&gt; say "Green!"
    Blue =&gt; say "Blue!"
}
</code></pre>
<h3 id="wildcard-pattern"><a class="header" href="#wildcard-pattern">Wildcard Pattern</a></h3>
<p>The <code>_</code> pattern matches any value, serving as a catch-all:</p>
<pre><code class="language-forge">match c {
    Red =&gt; say "It's red"
    _ =&gt; say "It's not red"
}
</code></pre>
<h2 id="built-in-adts"><a class="header" href="#built-in-adts">Built-in ADTs</a></h2>
<p>Forge provides two built-in algebraic types:</p>
<ul>
<li><strong>Option</strong>: <code>Some(value) | None</code> — see <a href="#option-and-result">Option and Result</a></li>
<li><strong>Result</strong>: <code>Ok(value) | Err(message)</code> — see <a href="#option-and-result">Option and Result</a></li>
</ul>
<p>These follow the same pattern matching conventions as user-defined ADTs:</p>
<pre><code class="language-forge">let x = Some(42)

match x {
    Some(val) =&gt; say "Got: {val}"
    None =&gt; say "Nothing"
}
</code></pre>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>Variant constructors (e.g., <code>Red</code>, <code>Circle</code>, <code>Some</code>, <code>Ok</code>) are introduced into the scope where the <code>type</code> definition appears. For built-in types like <code>Option</code> and <code>Result</code>, the constructors are globally available.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="option-and-result"><a class="header" href="#option-and-result">Option and Result</a></h1>
<p>Forge provides two built-in wrapper types for representing optional values and fallible operations: <strong>Option</strong> and <strong>Result</strong>. These types enable explicit, composable error handling without exceptions.</p>
<h2 id="option-type"><a class="header" href="#option-type">Option Type</a></h2>
<p>The <code>Option</code> type represents a value that may or may not be present.</p>
<h3 id="variants"><a class="header" href="#variants">Variants</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>Some(value)</code></td><td>A value is present</td></tr>
<tr><td><code>None</code></td><td>No value is present</td></tr>
</tbody>
</table>
</div>
<h3 id="construction-2"><a class="header" href="#construction-2">Construction</a></h3>
<pre><code class="language-forge">let x = Some(42)
let y = None
</code></pre>
<p>Both <code>Some</code> and <code>None</code> are globally available constructors.</p>
<h3 id="inspection"><a class="header" href="#inspection">Inspection</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>is_some(v)</code></td><td>Returns <code>true</code> if <code>v</code> is <code>Some(...)</code></td><td><code>is_some(Some(1))</code> = true</td></tr>
<tr><td><code>is_none(v)</code></td><td>Returns <code>true</code> if <code>v</code> is <code>None</code></td><td><code>is_none(None)</code> = true</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let x = Some(42)
say is_some(x)  // true
say is_none(x)  // false

let y = None
say is_some(y)  // false
say is_none(y)  // true
</code></pre>
<h3 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h3>
<p>Option values are destructured with <code>match</code>:</p>
<pre><code class="language-forge">let value = Some(42)

match value {
    Some(v) =&gt; say "Got: {v}"
    None =&gt; say "Nothing"
}
</code></pre>
<h3 id="unwrapping"><a class="header" href="#unwrapping">Unwrapping</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>unwrap(v)</code></td><td>Returns the inner value; crashes if <code>None</code></td></tr>
<tr><td><code>unwrap_or(v, d)</code></td><td>Returns the inner value, or <code>d</code> if <code>None</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let x = Some(42)
say unwrap(x)          // 42
say unwrap_or(x, 0)    // 42

let y = None
say unwrap_or(y, 0)    // 0
// unwrap(y) would crash with an error
</code></pre>
<h2 id="result-type"><a class="header" href="#result-type">Result Type</a></h2>
<p>The <code>Result</code> type represents the outcome of an operation that may succeed or fail.</p>
<h3 id="variants-1"><a class="header" href="#variants-1">Variants</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>Ok(value)</code></td><td>Operation succeeded with <code>value</code></td></tr>
<tr><td><code>Err(message)</code></td><td>Operation failed with <code>message</code></td></tr>
</tbody>
</table>
</div>
<h3 id="construction-1-1"><a class="header" href="#construction-1-1">Construction</a></h3>
<pre><code class="language-forge">let success = Ok(42)
let failure = Err("something went wrong")
</code></pre>
<p>Result constructors accept both cases: <code>Ok(42)</code> and <code>ok(42)</code> are equivalent, as are <code>Err("msg")</code> and <code>err("msg")</code>.</p>
<h3 id="inspection-1"><a class="header" href="#inspection-1">Inspection</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>is_ok(v)</code></td><td>Returns <code>true</code> if <code>v</code> is <code>Ok(...)</code></td><td><code>is_ok(Ok(1))</code> = true</td></tr>
<tr><td><code>is_err(v)</code></td><td>Returns <code>true</code> if <code>v</code> is <code>Err(...)</code></td><td><code>is_err(Err("x"))</code> = true</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let result = Ok(42)
say is_ok(result)   // true
say is_err(result)  // false
</code></pre>
<h3 id="pattern-matching-1-1"><a class="header" href="#pattern-matching-1-1">Pattern Matching</a></h3>
<p>Result values are destructured with <code>match</code>:</p>
<pre><code class="language-forge">fn parse_number(s) {
    let n = int(s)
    if n == null {
        return Err("invalid number: {s}")
    }
    return Ok(n)
}

match parse_number("42") {
    Ok(n) =&gt; say "Parsed: {n}"
    Err(msg) =&gt; say "Error: {msg}"
}
</code></pre>
<h3 id="unwrapping-1"><a class="header" href="#unwrapping-1">Unwrapping</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>unwrap(v)</code></td><td>Returns the inner value; crashes if <code>Err</code></td></tr>
<tr><td><code>unwrap_or(v, d)</code></td><td>Returns the inner value, or <code>d</code> if <code>Err</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let result = Ok(42)
say unwrap(result)          // 42
say unwrap_or(result, 0)    // 42

let err = Err("failed")
say unwrap_or(err, 0)       // 0
</code></pre>
<h2 id="the--operator"><a class="header" href="#the--operator">The <code>?</code> Operator</a></h2>
<p>The <code>?</code> postfix operator provides concise error propagation. When applied to a <code>Result</code> value:</p>
<ul>
<li>If the value is <code>Ok(v)</code>, the <code>?</code> unwraps it to <code>v</code> and execution continues.</li>
<li>If the value is <code>Err(e)</code>, the enclosing function immediately returns <code>Err(e)</code>.</li>
</ul>
<pre><code class="language-forge">fn read_config(path) {
    if !fs.exists(path) {
        return Err("config file not found")
    }
    return Ok(fs.read(path))
}

fn start_server() {
    let config = read_config("server.toml")?
    say "Starting with config: {config}"
    return Ok(true)
}

match start_server() {
    Ok(_) =&gt; say "Server started"
    Err(msg) =&gt; say "Failed: {msg}"
}
</code></pre>
<p>The <code>?</code> operator can only be used inside functions that return <code>Result</code>. It is syntactic sugar for:</p>
<pre><code class="language-forge">let result = read_config("server.toml")
if is_err(result) {
    return result
}
let config = unwrap(result)
</code></pre>
<h2 id="the-must-keyword"><a class="header" href="#the-must-keyword">The <code>must</code> Keyword</a></h2>
<p>The <code>must</code> keyword is an assertion on Result values. It unwraps an <code>Ok</code> value or crashes the program with a clear error message on <code>Err</code>:</p>
<pre><code class="language-forge">let config = must read_config("server.toml")
</code></pre>
<p>Use <code>must</code> for errors that are truly unrecoverable — situations where the program cannot meaningfully continue (e.g., missing configuration, failed database connection).</p>
<h2 id="the-safe-block"><a class="header" href="#the-safe-block">The <code>safe</code> Block</a></h2>
<p>The <code>safe</code> block catches any errors within its body and returns <code>null</code> instead of crashing:</p>
<pre><code class="language-forge">safe {
    let result = risky_operation()
    say result
}
// If risky_operation() fails, execution continues here
</code></pre>
<p><code>safe</code> is a statement-level construct. It does not return a value and cannot be used as an expression.</p>
<h2 id="idiomatic-error-handling"><a class="header" href="#idiomatic-error-handling">Idiomatic Error Handling</a></h2>
<p>The recommended patterns for error handling in Forge, in order of preference:</p>
<ol>
<li><strong><code>?</code> for propagation.</strong> Pass errors up the call stack to a centralized handler.</li>
<li><strong><code>match</code> for handling.</strong> Explicitly handle both <code>Ok</code> and <code>Err</code> at the appropriate level.</li>
<li><strong><code>unwrap_or</code> for defaults.</strong> Provide a fallback when an error is acceptable.</li>
<li><strong><code>must</code> for fatal errors.</strong> Crash with a clear message when recovery is impossible.</li>
<li><strong><code>safe</code> for silencing.</strong> Suppress errors only when the operation is truly optional.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h1>
<p>Forge is dynamically typed and does not perform implicit type coercion between incompatible types (with the exception of <code>Int</code> to <code>Float</code> promotion in mixed arithmetic). Explicit conversion functions are provided for converting between types.</p>
<h2 id="conversion-functions"><a class="header" href="#conversion-functions">Conversion Functions</a></h2>
<h3 id="strvalue--convert-to-string"><a class="header" href="#strvalue--convert-to-string"><code>str(value)</code> — Convert to String</a></h3>
<p>Converts any value to its string representation.</p>
<pre><code class="language-forge">say str(42)       // "42"
say str(3.14)     // "3.14"
say str(true)     // "true"
say str(null)     // "null"
say str([1, 2])   // "[1, 2]"
</code></pre>
<p><code>str()</code> never fails. Every Forge value has a string representation.</p>
<h3 id="intvalue--convert-to-int"><a class="header" href="#intvalue--convert-to-int"><code>int(value)</code> — Convert to Int</a></h3>
<p>Converts a value to a 64-bit signed integer.</p>
<pre><code class="language-forge">say int("42")     // 42
say int("100")    // 100
say int(3.14)     // 3 (truncates toward zero)
say int(true)     // 1
say int(false)    // 0
</code></pre>
<p>If the input string cannot be parsed as an integer, <code>int()</code> produces a runtime error. Always validate user input before converting.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input Type</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>String</code></td><td>Parses decimal integer; error if invalid</td></tr>
<tr><td><code>Float</code></td><td>Truncates toward zero</td></tr>
<tr><td><code>Bool</code></td><td><code>true</code> = 1, <code>false</code> = 0</td></tr>
<tr><td><code>Int</code></td><td>Returns the value unchanged</td></tr>
<tr><td>Other</td><td>Runtime error</td></tr>
</tbody>
</table>
</div>
<h3 id="floatvalue--convert-to-float"><a class="header" href="#floatvalue--convert-to-float"><code>float(value)</code> — Convert to Float</a></h3>
<p>Converts a value to a 64-bit floating-point number.</p>
<pre><code class="language-forge">say float("3.14")  // 3.14
say float(42)      // 42.0
say float(true)    // 1.0
say float(false)   // 0.0
</code></pre>
<p>If the input string cannot be parsed as a float, <code>float()</code> produces a runtime error.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input Type</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>String</code></td><td>Parses decimal float; error if invalid</td></tr>
<tr><td><code>Int</code></td><td>Promotes to float (lossless for most values)</td></tr>
<tr><td><code>Bool</code></td><td><code>true</code> = 1.0, <code>false</code> = 0.0</td></tr>
<tr><td><code>Float</code></td><td>Returns the value unchanged</td></tr>
<tr><td>Other</td><td>Runtime error</td></tr>
</tbody>
</table>
</div>
<h2 id="type-inspection-functions"><a class="header" href="#type-inspection-functions">Type Inspection Functions</a></h2>
<h3 id="typeofvalue--get-type-name"><a class="header" href="#typeofvalue--get-type-name"><code>typeof(value)</code> — Get Type Name</a></h3>
<p>Returns a string describing the runtime type of a value.</p>
<pre><code class="language-forge">say typeof(42)                  // Int
say typeof(3.14)                // Float
say typeof("hello")             // String
say typeof(true)                // Bool
say typeof(null)                // Null
say typeof([1, 2, 3])           // Array
say typeof({ name: "Alice" })   // Object
</code></pre>
<p>For struct instances, <code>typeof()</code> returns the struct name:</p>
<pre><code class="language-forge">thing Point { x: Int, y: Int }
let p = Point { x: 1, y: 2 }
say typeof(p)   // Point
</code></pre>
<p>For functions:</p>
<pre><code class="language-forge">fn f() { return 1 }
say typeof(f)   // Function
</code></pre>
<h3 id="typevalue--alias-for-typeof"><a class="header" href="#typevalue--alias-for-typeof"><code>type(value)</code> — Alias for <code>typeof</code></a></h3>
<p>The <code>type()</code> function is an alias for <code>typeof()</code>. Both return identical results:</p>
<pre><code class="language-forge">let value = 3.14
if type(value) == "Float" {
    say "It's a float"
}
</code></pre>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit Conversions</a></h2>
<p>Forge performs very few implicit conversions:</p>
<h3 id="int-to-float-promotion"><a class="header" href="#int-to-float-promotion">Int-to-Float Promotion</a></h3>
<p>When an arithmetic operator has one <code>Int</code> operand and one <code>Float</code> operand, the integer is implicitly promoted to a float. The result is a <code>Float</code>:</p>
<pre><code class="language-forge">say 5 + 2.0    // 7.0 (Int promoted to Float)
say 10 / 3.0   // 3.3333333333333335
</code></pre>
<h3 id="string-interpolation-1"><a class="header" href="#string-interpolation-1">String Interpolation</a></h3>
<p>Inside string interpolation (<code>{expr}</code>), the expression result is implicitly converted to a string using the same logic as <code>str()</code>:</p>
<pre><code class="language-forge">let n = 42
say "The answer is {n}"  // "The answer is 42"
</code></pre>
<h3 id="truthiness-2"><a class="header" href="#truthiness-2">Truthiness</a></h3>
<p>When a value is used in a boolean context (e.g., <code>if</code> condition), it is evaluated for truthiness (see <a href="#types">Types</a>). This is not a type conversion — the value itself is not changed. It is a contextual interpretation.</p>
<h2 id="no-other-implicit-coercion"><a class="header" href="#no-other-implicit-coercion">No Other Implicit Coercion</a></h2>
<p>Operations between incompatible types (e.g., adding a string and an integer) produce a runtime error. Explicit conversion is required:</p>
<pre><code class="language-forge">// Error: cannot add String and Int
// say "age: " + 30

// Correct: convert explicitly
say "age: " + str(30)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>An <strong>expression</strong> is a syntactic construct that evaluates to a value. Every expression in Forge has a type and produces a result when evaluated.</p>
<p>Forge distinguishes expressions from <a href="#statements">statements</a>: expressions produce values, statements produce effects. An expression can appear anywhere a value is expected – as the right-hand side of a variable binding, as a function argument, or as the body of a <code>when</code> arm.</p>
<h2 id="expression-categories"><a class="header" href="#expression-categories">Expression Categories</a></h2>
<h3 id="literal-expressions"><a class="header" href="#literal-expressions">Literal Expressions</a></h3>
<p>Literal expressions produce values directly from source text.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Literal</th><th>Example</th><th>Value Type</th></tr>
</thead>
<tbody>
<tr><td>Integer</td><td><code>42</code></td><td><code>int</code></td></tr>
<tr><td>Float</td><td><code>3.14</code></td><td><code>float</code></td></tr>
<tr><td>String</td><td><code>"hello"</code></td><td><code>string</code></td></tr>
<tr><td>Boolean</td><td><code>true</code>, <code>false</code></td><td><code>bool</code></td></tr>
<tr><td>Null</td><td><code>null</code></td><td><code>null</code></td></tr>
<tr><td>Array</td><td><code>[1, 2, 3]</code></td><td><code>array</code></td></tr>
<tr><td>Object</td><td><code>{ name: "Forge", version: 1 }</code></td><td><code>object</code></td></tr>
</tbody>
</table>
</div>
<p>String literals support <a href="#string-interpolation-2">interpolation</a> with embedded expressions.</p>
<h3 id="identifier-expressions"><a class="header" href="#identifier-expressions">Identifier Expressions</a></h3>
<p>An identifier evaluates to the value bound to that name in the current scope.</p>
<pre><code class="language-forge">let x = 10
say x       // evaluates to 10
</code></pre>
<p>If the identifier is not in scope, evaluation produces a runtime error.</p>
<h3 id="arithmetic-expressions"><a class="header" href="#arithmetic-expressions">Arithmetic Expressions</a></h3>
<p>Binary operations on numeric values: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>. The <code>+</code> operator also performs string concatenation.</p>
<p>See <a href="#arithmetic-expressions-1">Arithmetic</a>.</p>
<h3 id="comparison-and-logical-expressions"><a class="header" href="#comparison-and-logical-expressions">Comparison and Logical Expressions</a></h3>
<p>Comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) produce boolean values. Logical operators (<code>and</code>/<code>&amp;&amp;</code>, <code>or</code>/<code>||</code>, <code>not</code>/<code>!</code>) combine boolean expressions with short-circuit evaluation.</p>
<p>See <a href="#comparison-and-logical-expressions-1">Comparison and Logical</a>.</p>
<h3 id="field-access-expressions"><a class="header" href="#field-access-expressions">Field Access Expressions</a></h3>
<p>Dot notation accesses fields on objects and struct instances. Embedded fields are resolved through delegation.</p>
<pre><code class="language-forge">let user = { name: "Alice", age: 30 }
say user.name   // "Alice"
</code></pre>
<p>See <a href="#field-access-2">Field Access</a>.</p>
<h3 id="index-expressions"><a class="header" href="#index-expressions">Index Expressions</a></h3>
<p>Bracket notation accesses elements by position in arrays or by key in objects.</p>
<pre><code class="language-forge">let items = [10, 20, 30]
say items[0]    // 10

let obj = { x: 1 }
say obj["x"]    // 1
</code></pre>
<h3 id="method-call-expressions"><a class="header" href="#method-call-expressions">Method Call Expressions</a></h3>
<p>Method calls use dot notation followed by a function call. Forge resolves methods through a multi-step dispatch chain: object fields, type method tables, embedded field delegation, then known built-in methods.</p>
<pre><code class="language-forge">let names = ["Charlie", "Alice", "Bob"]
say names.sort()    // ["Alice", "Bob", "Charlie"]
</code></pre>
<p>See <a href="#method-calls">Method Calls</a>.</p>
<h3 id="function-call-expressions"><a class="header" href="#function-call-expressions">Function Call Expressions</a></h3>
<p>A function call evaluates a callable expression and applies it to a list of argument expressions.</p>
<pre><code class="language-forge">fn square(n) { n * n }
say square(5)   // 25
</code></pre>
<h3 id="closures-and-lambdas"><a class="header" href="#closures-and-lambdas">Closures and Lambdas</a></h3>
<p>Anonymous functions that capture their enclosing environment.</p>
<pre><code class="language-forge">let double = fn(x) { x * 2 }
say double(5)   // 10
</code></pre>
<p>See <a href="#closures-and-lambdas-1">Closures and Lambdas</a>.</p>
<h3 id="when-guard-expressions"><a class="header" href="#when-guard-expressions">When Guard Expressions</a></h3>
<p>Pattern-matching on a scrutinee value using comparison operators.</p>
<pre><code class="language-forge">let label = when age {
    &lt; 13 -&gt; "child",
    &lt; 18 -&gt; "teen",
    else -&gt; "adult"
}
</code></pre>
<p>See <a href="#when-guards">When Guards</a>.</p>
<h3 id="match-expressions"><a class="header" href="#match-expressions">Match Expressions</a></h3>
<p>Structural pattern matching with destructuring of algebraic data types.</p>
<pre><code class="language-forge">match shape {
    Circle(r) =&gt; say "radius: {r}",
    Rect(w, h) =&gt; say "area: {w * h}",
    _ =&gt; say "unknown"
}
</code></pre>
<p>See <a href="#match-expressions-1">Match Expressions</a>.</p>
<h3 id="string-interpolation-expressions"><a class="header" href="#string-interpolation-expressions">String Interpolation Expressions</a></h3>
<p>Double-quoted strings with embedded expressions in <code>{...}</code> delimiters.</p>
<pre><code class="language-forge">let name = "world"
say "hello, {name}!"   // "hello, world!"
</code></pre>
<p>See <a href="#string-interpolation-2">String Interpolation</a>.</p>
<h3 id="pipeline-expressions"><a class="header" href="#pipeline-expressions">Pipeline Expressions</a></h3>
<p>The pipe operator <code>|&gt;</code> threads a value through a chain of function calls.</p>
<pre><code class="language-forge">[1, 2, 3, 4, 5]
    |&gt; filter(fn(x) { x &gt; 2 })
    |&gt; map(fn(x) { x * 10 })
</code></pre>
<h3 id="unary-expressions"><a class="header" href="#unary-expressions">Unary Expressions</a></h3>
<p>Unary operators: <code>-</code> (numeric negation) and <code>not</code>/<code>!</code> (logical negation).</p>
<pre><code class="language-forge">let x = -5
let flag = not true
</code></pre>
<h3 id="try-expressions"><a class="header" href="#try-expressions">Try Expressions</a></h3>
<p>The <code>?</code> operator propagates errors from <code>Result</code> values. If the value is <code>Err</code>, evaluation returns early from the enclosing function.</p>
<pre><code class="language-forge">let data = fs.read("config.json")?
</code></pre>
<h3 id="must-expressions"><a class="header" href="#must-expressions">Must Expressions</a></h3>
<p>The <code>must</code> keyword unwraps a <code>Result</code> or crashes with a descriptive error message.</p>
<pre><code class="language-forge">let data = must fs.read("config.json")
</code></pre>
<h3 id="struct-initialization-expressions"><a class="header" href="#struct-initialization-expressions">Struct Initialization Expressions</a></h3>
<p>Creates an instance of a named struct type.</p>
<pre><code class="language-forge">thing Point { x: int, y: int }
let p = Point { x: 10, y: 20 }
</code></pre>
<h3 id="spread-expressions"><a class="header" href="#spread-expressions">Spread Expressions</a></h3>
<p>The <code>...</code> operator expands an array or object in a literal context.</p>
<pre><code class="language-forge">let base = [1, 2, 3]
let extended = [...base, 4, 5]
</code></pre>
<h2 id="expression-evaluation-order"><a class="header" href="#expression-evaluation-order">Expression Evaluation Order</a></h2>
<p>Forge evaluates expressions left to right. In a binary expression <code>a + b</code>, <code>a</code> is evaluated before <code>b</code>. In a function call <code>f(x, y)</code>, <code>f</code> is evaluated first, then <code>x</code>, then <code>y</code>.</p>
<p>Logical operators <code>and</code>/<code>&amp;&amp;</code> and <code>or</code>/<code>||</code> use short-circuit evaluation: the right operand is not evaluated if the left operand determines the result. See <a href="#comparison-and-logical-expressions-1">Comparison and Logical</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arithmetic-expressions-1"><a class="header" href="#arithmetic-expressions-1">Arithmetic Expressions</a></h1>
<p>Arithmetic expressions perform numeric computations and string concatenation.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Operand Types</th><th>Result Type</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td>Addition</td><td><code>int + int</code></td><td><code>int</code></td></tr>
<tr><td><code>+</code></td><td>Addition</td><td><code>float + float</code></td><td><code>float</code></td></tr>
<tr><td><code>+</code></td><td>Addition</td><td><code>int + float</code> or <code>float + int</code></td><td><code>float</code></td></tr>
<tr><td><code>+</code></td><td>Concatenation</td><td><code>string + string</code></td><td><code>string</code></td></tr>
<tr><td><code>-</code></td><td>Subtraction</td><td><code>int - int</code></td><td><code>int</code></td></tr>
<tr><td><code>-</code></td><td>Subtraction</td><td><code>float - float</code></td><td><code>float</code></td></tr>
<tr><td><code>-</code></td><td>Subtraction</td><td><code>int - float</code> or <code>float - int</code></td><td><code>float</code></td></tr>
<tr><td><code>*</code></td><td>Multiplication</td><td><code>int * int</code></td><td><code>int</code></td></tr>
<tr><td><code>*</code></td><td>Multiplication</td><td><code>float * float</code></td><td><code>float</code></td></tr>
<tr><td><code>*</code></td><td>Multiplication</td><td><code>int * float</code> or <code>float - int</code></td><td><code>float</code></td></tr>
<tr><td><code>/</code></td><td>Division</td><td><code>int / int</code></td><td><code>int</code> (truncated)</td></tr>
<tr><td><code>/</code></td><td>Division</td><td><code>float / float</code></td><td><code>float</code></td></tr>
<tr><td><code>/</code></td><td>Division</td><td><code>int / float</code> or <code>float / int</code></td><td><code>float</code></td></tr>
<tr><td><code>%</code></td><td>Modulo</td><td><code>int % int</code></td><td><code>int</code></td></tr>
<tr><td><code>%</code></td><td>Modulo</td><td><code>float % float</code></td><td><code>float</code></td></tr>
</tbody>
</table>
</div>
<h2 id="integer-arithmetic"><a class="header" href="#integer-arithmetic">Integer Arithmetic</a></h2>
<p>Integer arithmetic uses 64-bit signed integers (<code>i64</code>). Operations that overflow follow Rust’s default behavior (panic in debug, wrap in release).</p>
<pre><code class="language-forge">let a = 10 + 3      // 13
let b = 10 - 3      // 7
let c = 10 * 3      // 30
let d = 10 / 3      // 3 (truncated toward zero)
let e = 10 % 3      // 1
</code></pre>
<h3 id="integer-division"><a class="header" href="#integer-division">Integer Division</a></h3>
<p>Integer division truncates toward zero. The result is always an integer when both operands are integers.</p>
<pre><code class="language-forge">say 7 / 2       // 3
say -7 / 2      // -3
say 7 / -2      // -3
</code></pre>
<h2 id="float-arithmetic"><a class="header" href="#float-arithmetic">Float Arithmetic</a></h2>
<p>Float arithmetic uses 64-bit IEEE 754 double-precision floating-point numbers (<code>f64</code>).</p>
<pre><code class="language-forge">let a = 3.14 + 2.0     // 5.14
let b = 10.0 / 3.0     // 3.3333333333333335
let c = 2.5 % 1.0      // 0.5
</code></pre>
<h2 id="mixed-arithmetic"><a class="header" href="#mixed-arithmetic">Mixed Arithmetic</a></h2>
<p>When one operand is <code>int</code> and the other is <code>float</code>, the integer is promoted to a float before the operation. The result is always <code>float</code>.</p>
<pre><code class="language-forge">say 5 + 2.0      // 7.0
say 10 / 3.0     // 3.3333333333333335
say 3 * 1.5      // 4.5
</code></pre>
<h2 id="string-concatenation"><a class="header" href="#string-concatenation">String Concatenation</a></h2>
<p>The <code>+</code> operator concatenates two strings. If one operand is a string and the other is not, the non-string operand is converted to its string representation.</p>
<pre><code class="language-forge">say "hello" + " " + "world"    // "hello world"
say "count: " + str(42)        // "count: 42"
</code></pre>
<p>For embedding expressions in strings, prefer <a href="#string-interpolation-2">string interpolation</a>:</p>
<pre><code class="language-forge">say "count: {42}"              // "count: 42"
</code></pre>
<h2 id="unary-negation"><a class="header" href="#unary-negation">Unary Negation</a></h2>
<p>The <code>-</code> prefix operator negates a numeric value.</p>
<pre><code class="language-forge">let x = 5
say -x          // -5
say -3.14       // -3.14
</code></pre>
<h2 id="operator-precedence-1"><a class="header" href="#operator-precedence-1">Operator Precedence</a></h2>
<p>Arithmetic operators follow standard mathematical precedence:</p>
<ol>
<li>Unary <code>-</code> (highest)</li>
<li><code>*</code>, <code>/</code>, <code>%</code></li>
<li><code>+</code>, <code>-</code> (lowest among arithmetic)</li>
</ol>
<p>Parentheses override precedence:</p>
<pre><code class="language-forge">say 2 + 3 * 4       // 14
say (2 + 3) * 4     // 20
</code></pre>
<p>See the <a href="#operator-precedence-3">Operator Precedence</a> appendix for the full precedence table including all operator categories.</p>
<h2 id="division-by-zero"><a class="header" href="#division-by-zero">Division by Zero</a></h2>
<p>Dividing by zero produces a runtime error:</p>
<pre><code class="language-forge">say 10 / 0      // runtime error: division by zero
</code></pre>
<p>Float division by zero follows IEEE 754 rules and may produce infinity or NaN.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comparison-and-logical-expressions-1"><a class="header" href="#comparison-and-logical-expressions-1">Comparison and Logical Expressions</a></h1>
<p>Comparison operators produce boolean values by comparing two operands. Logical operators combine boolean expressions using short-circuit evaluation.</p>
<h2 id="comparison-operators-1"><a class="header" href="#comparison-operators-1">Comparison Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Meaning</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>==</code></td><td>Equal</td><td><code>x == y</code></td></tr>
<tr><td><code>!=</code></td><td>Not equal</td><td><code>x != y</code></td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td><td><code>x &lt; y</code></td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td><td><code>x &gt; y</code></td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equal</td><td><code>x &lt;= y</code></td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equal</td><td><code>x &gt;= y</code></td></tr>
</tbody>
</table>
</div>
<h3 id="equality"><a class="header" href="#equality">Equality</a></h3>
<p>The <code>==</code> operator tests structural equality. Two values are equal if they have the same type and the same content.</p>
<pre><code class="language-forge">say 1 == 1              // true
say "abc" == "abc"      // true
say [1, 2] == [1, 2]   // true
say null == null        // true
say 1 == 1.0            // true (numeric promotion)
say 1 == "1"            // false (different types)
</code></pre>
<h3 id="numeric-comparison"><a class="header" href="#numeric-comparison">Numeric Comparison</a></h3>
<p>Integers and floats can be compared directly. When comparing an <code>int</code> with a <code>float</code>, the integer is promoted to float.</p>
<pre><code class="language-forge">say 3 &lt; 5           // true
say 3.14 &gt; 2.71     // true
say 10 &gt;= 10        // true
say 5 &lt;= 3          // false
say 1 &lt; 2.5         // true (int promoted to float)
</code></pre>
<h3 id="string-comparison-1"><a class="header" href="#string-comparison-1">String Comparison</a></h3>
<p>Strings are compared lexicographically (by Unicode code points).</p>
<pre><code class="language-forge">say "apple" &lt; "banana"      // true
say "abc" == "abc"          // true
say "a" &lt; "b"               // true
</code></pre>
<h3 id="null-comparison"><a class="header" href="#null-comparison">Null Comparison</a></h3>
<p>Only <code>null</code> is equal to <code>null</code>. Comparing <code>null</code> with any other value using <code>==</code> yields <code>false</code>.</p>
<pre><code class="language-forge">say null == null        // true
say null == 0           // false
say null == ""          // false
say null == false       // false
</code></pre>
<h2 id="logical-operators-1"><a class="header" href="#logical-operators-1">Logical Operators</a></h2>
<p>Forge supports two syntactic forms for each logical operator. Both forms are equivalent.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>&amp;&amp;</code></td><td><code>and</code></td><td>Logical AND</td></tr>
<tr><td><code>||</code></td><td><code>or</code></td><td>Logical OR</td></tr>
<tr><td><code>!</code></td><td><code>not</code></td><td>Logical NOT</td></tr>
</tbody>
</table>
</div>
<h3 id="logical-and"><a class="header" href="#logical-and">Logical AND</a></h3>
<p>Returns <code>true</code> if both operands are truthy. Uses short-circuit evaluation: if the left operand is falsy, the right operand is not evaluated.</p>
<pre><code class="language-forge">say true and true       // true
say true and false      // false
say false and true      // false (right side not evaluated)
</code></pre>
<h3 id="logical-or"><a class="header" href="#logical-or">Logical OR</a></h3>
<p>Returns <code>true</code> if either operand is truthy. Uses short-circuit evaluation: if the left operand is truthy, the right operand is not evaluated.</p>
<pre><code class="language-forge">say false or true       // true
say true or false       // true (right side not evaluated)
say false or false      // false
</code></pre>
<h3 id="logical-not"><a class="header" href="#logical-not">Logical NOT</a></h3>
<p>Returns the boolean negation of the operand. Applies truthiness rules.</p>
<pre><code class="language-forge">say not true        // false
say not false       // true
say !null           // true
say not 0           // false (0 is truthy in Forge)
</code></pre>
<h2 id="short-circuit-evaluation"><a class="header" href="#short-circuit-evaluation">Short-Circuit Evaluation</a></h2>
<p>Short-circuit evaluation means the right operand of <code>and</code>/<code>&amp;&amp;</code> or <code>or</code>/<code>||</code> is only evaluated when necessary.</p>
<pre><code class="language-forge">// The function is never called because the left side is false
false and expensive_computation()

// The function is never called because the left side is true
true or expensive_computation()
</code></pre>
<p>This is significant when the right operand has side effects:</p>
<pre><code class="language-forge">let x = null
// Safe: the right side is not evaluated when x is null
x != null and x.name == "Alice"
</code></pre>
<h2 id="truthiness-rules"><a class="header" href="#truthiness-rules">Truthiness Rules</a></h2>
<p>Forge uses the following truthiness rules when a value appears in a boolean context (such as an <code>if</code> condition or a logical operator):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Truthiness</th></tr>
</thead>
<tbody>
<tr><td><code>false</code></td><td>falsy</td></tr>
<tr><td><code>null</code></td><td>falsy</td></tr>
<tr><td>Everything else</td><td>truthy</td></tr>
</tbody>
</table>
</div>
<p>Notably, the following values are <strong>truthy</strong> (unlike some other languages):</p>
<ul>
<li><code>0</code> (zero)</li>
<li><code>""</code> (empty string)</li>
<li><code>[]</code> (empty array)</li>
<li><code>{}</code> (empty object)</li>
</ul>
<pre><code class="language-forge">if 0 {
    say "zero is truthy"    // this executes
}

if "" {
    say "empty string is truthy"    // this executes
}

if null {
    say "unreachable"
} otherwise {
    say "null is falsy"     // this executes
}
</code></pre>
<h2 id="operator-precedence-2"><a class="header" href="#operator-precedence-2">Operator Precedence</a></h2>
<p>From highest to lowest precedence:</p>
<ol>
<li><code>not</code> / <code>!</code> (unary)</li>
<li><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
<li><code>==</code>, <code>!=</code></li>
<li><code>and</code> / <code>&amp;&amp;</code></li>
<li><code>or</code> / <code>||</code></li>
</ol>
<pre><code class="language-forge">say true or false and false     // true (and binds tighter than or)
say not false and true          // true (not binds tightest)
</code></pre>
<p>See the <a href="#operator-precedence-3">Operator Precedence</a> appendix for the full table.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="string-interpolation-2"><a class="header" href="#string-interpolation-2">String Interpolation</a></h1>
<p>Double-quoted string literals in Forge support <strong>interpolation</strong>: embedding arbitrary expressions inside <code>{</code> and <code>}</code> delimiters. The expressions are evaluated at runtime and their results are converted to string representations and spliced into the surrounding text.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code>" ... {expression} ... "
</code></pre>
<p>Any valid Forge expression may appear between the braces.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-forge">let name = "Forge"
say "Hello, {name}!"           // "Hello, Forge!"

let x = 10
let y = 20
say "{x} + {y} = {x + y}"     // "10 + 20 = 30"
</code></pre>
<h2 id="arbitrary-expressions"><a class="header" href="#arbitrary-expressions">Arbitrary Expressions</a></h2>
<p>The interpolated expression is not limited to identifiers. Any expression that produces a value is permitted, including function calls, arithmetic, method calls, and field access.</p>
<pre><code class="language-forge">say "length: {len([1, 2, 3])}"             // "length: 3"
say "upper: {"hello".upper()}"             // "upper: HELLO"
say "sum: {1 + 2 + 3}"                     // "sum: 6"
say "type: {typeof(42)}"                    // "type: int"
</code></pre>
<h2 id="value-conversion"><a class="header" href="#value-conversion">Value Conversion</a></h2>
<p>Interpolated values are converted to their string representation using the same rules as the <code>str()</code> builtin:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value Type</th><th>String Representation</th></tr>
</thead>
<tbody>
<tr><td><code>string</code></td><td>The string itself</td></tr>
<tr><td><code>int</code></td><td>Decimal representation (e.g., <code>"42"</code>)</td></tr>
<tr><td><code>float</code></td><td>Decimal representation (e.g., <code>"3.14"</code>)</td></tr>
<tr><td><code>bool</code></td><td><code>"true"</code> or <code>"false"</code></td></tr>
<tr><td><code>null</code></td><td><code>"null"</code></td></tr>
<tr><td><code>array</code></td><td><code>"[1, 2, 3]"</code></td></tr>
<tr><td><code>object</code></td><td><code>"{key: value, ...}"</code></td></tr>
</tbody>
</table>
</div>
<h2 id="escape-sequences-1"><a class="header" href="#escape-sequences-1">Escape Sequences</a></h2>
<p>The following escape sequences are recognized inside double-quoted strings:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Escape</th><th>Character</th></tr>
</thead>
<tbody>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
<tr><td><code>\{</code></td><td>Literal <code>{</code> (suppresses interpolation)</td></tr>
<tr><td><code>\"</code></td><td>Double quote</td></tr>
</tbody>
</table>
</div>
<p>To include a literal <code>{</code> character without triggering interpolation, escape it:</p>
<pre><code class="language-forge">say "use \{braces\} for interpolation"
// Output: use {braces} for interpolation
</code></pre>
<h2 id="nesting"><a class="header" href="#nesting">Nesting</a></h2>
<p>Interpolated expressions may themselves contain string literals with interpolation, though this is discouraged for readability:</p>
<pre><code class="language-forge">let items = ["a", "b", "c"]
say "result: {join(items, ", ")}"
</code></pre>
<h2 id="non-interpolated-strings"><a class="header" href="#non-interpolated-strings">Non-Interpolated Strings</a></h2>
<p>Single-quoted strings do not support interpolation. Use single quotes when the string contains braces that should be treated literally:</p>
<pre><code class="language-forge">say 'no {interpolation} here'
// Output: no {interpolation} here
</code></pre>
<h2 id="empty-interpolation"><a class="header" href="#empty-interpolation">Empty Interpolation</a></h2>
<p>An empty interpolation <code>{}</code> is not valid and produces a parse error.</p>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<p>String interpolation is parsed into a <code>StringInterp</code> AST node containing a sequence of <code>StringPart</code> elements, each being either a <code>Literal</code> (raw text) or an <code>Expr</code> (an evaluated expression). At runtime, all parts are evaluated and concatenated to produce the final string value.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="field-access-2"><a class="header" href="#field-access-2">Field Access</a></h1>
<p>The dot operator (<code>.</code>) accesses fields on objects and struct instances. Forge resolves field access through direct lookup followed by delegation through embedded fields.</p>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<pre><code>expression.identifier
</code></pre>
<p>The left operand is evaluated to produce an object. The identifier names the field to retrieve.</p>
<h2 id="object-field-access"><a class="header" href="#object-field-access">Object Field Access</a></h2>
<p>Objects are unordered collections of key-value pairs. Dot notation retrieves a value by key.</p>
<pre><code class="language-forge">let user = { name: "Alice", age: 30 }
say user.name       // "Alice"
say user.age        // 30
</code></pre>
<p>If the field does not exist on the object, a runtime error is produced:</p>
<pre><code class="language-forge">let user = { name: "Alice" }
say user.email      // runtime error: no field 'email' on object
</code></pre>
<h2 id="struct-field-access"><a class="header" href="#struct-field-access">Struct Field Access</a></h2>
<p>Struct instances (created from <code>thing</code>/<code>struct</code> definitions) are objects with a <code>__type__</code> field. Field access works identically.</p>
<pre><code class="language-forge">thing Point { x: int, y: int }
let p = Point { x: 10, y: 20 }
say p.x     // 10
say p.y     // 20
</code></pre>
<h2 id="embedded-field-delegation"><a class="header" href="#embedded-field-delegation">Embedded Field Delegation</a></h2>
<p>When a struct uses <code>has</code> to embed another type, field access delegates to the embedded field if the field is not found directly on the outer object.</p>
<pre><code class="language-forge">thing Base { id: int }
thing Extended {
    has base: Base
    name: string
}

let e = Extended { base: Base { id: 1 }, name: "test" }
say e.name      // "test" (direct)
say e.id        // 1 (delegated to e.base.id)
</code></pre>
<h3 id="resolution-order"><a class="header" href="#resolution-order">Resolution Order</a></h3>
<p>Field access resolves in this order:</p>
<ol>
<li><strong>Direct field lookup</strong>: Check if the object has a field with the given name.</li>
<li><strong>Embedded field delegation</strong>: If the object has a <code>__type__</code>, check each embedded field’s sub-object for the field name. Embedded fields are checked in definition order.</li>
</ol>
<p>If neither step finds the field, a runtime error is produced.</p>
<h2 id="chaining"><a class="header" href="#chaining">Chaining</a></h2>
<p>Field access expressions can be chained to traverse nested structures.</p>
<pre><code class="language-forge">let config = {
    server: {
        host: "localhost",
        port: 8080
    }
}
say config.server.host      // "localhost"
say config.server.port      // 8080
</code></pre>
<h2 id="built-in-field-access-on-primitives"><a class="header" href="#built-in-field-access-on-primitives">Built-in Field Access on Primitives</a></h2>
<p>Certain built-in fields are available on primitive types:</p>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>.len</code></td><td><code>int</code></td><td>Number of bytes</td></tr>
<tr><td><code>.upper</code></td><td><code>string</code></td><td>Uppercase copy</td></tr>
<tr><td><code>.lower</code></td><td><code>string</code></td><td>Lowercase copy</td></tr>
<tr><td><code>.trim</code></td><td><code>string</code></td><td>Whitespace-trimmed copy</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let s = "  Hello  "
say s.len       // 9
say s.upper     // "  HELLO  "
say s.trim      // "Hello"
</code></pre>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>.len</code></td><td><code>int</code></td><td>Number of elements</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let items = [1, 2, 3]
say items.len   // 3
</code></pre>
<h2 id="index-based-access"><a class="header" href="#index-based-access">Index-Based Access</a></h2>
<p>For dynamic key access, use bracket notation instead of dot notation:</p>
<pre><code class="language-forge">let obj = { name: "Alice" }
let key = "name"
say obj[key]        // "Alice"
</code></pre>
<p>Bracket notation works on both objects (with string keys) and arrays (with integer indices).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="method-calls"><a class="header" href="#method-calls">Method Calls</a></h1>
<p>A method call uses dot notation to invoke a function on a receiver value. Forge resolves method calls through a multi-step dispatch process.</p>
<h2 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h2>
<pre><code>expression.method(arguments)
</code></pre>
<p>The left operand (the <strong>receiver</strong>) is evaluated first, then the method is resolved, then arguments are evaluated left to right.</p>
<h2 id="method-dispatch"><a class="header" href="#method-dispatch">Method Dispatch</a></h2>
<p>When evaluating <code>obj.method(args)</code>, the interpreter follows this resolution order:</p>
<h3 id="1-object-field-lookup"><a class="header" href="#1-object-field-lookup">1. Object Field Lookup</a></h3>
<p>If the receiver is an object and has a field named <code>method</code> whose value is callable (a function or closure), that field is invoked directly.</p>
<pre><code class="language-forge">let obj = {
    greet: fn(name) { "hello, {name}" }
}
say obj.greet("world")      // "hello, world"
</code></pre>
<h3 id="2-static-method-lookup"><a class="header" href="#2-static-method-lookup">2. Static Method Lookup</a></h3>
<p>If the receiver is a struct type reference (not an instance), static methods registered via <code>give</code>/<code>impl</code> blocks are checked.</p>
<pre><code class="language-forge">thing Counter { value: int }

give Counter {
    fn new() {
        Counter { value: 0 }
    }
}

let c = Counter.new()   // static method call
</code></pre>
<h3 id="3-instance-method-lookup-method_tables"><a class="header" href="#3-instance-method-lookup-method_tables">3. Instance Method Lookup (method_tables)</a></h3>
<p>If the receiver is a typed object (has a <code>__type__</code> field), the interpreter looks up the type name in the global method table. Methods registered via <code>give</code>/<code>impl</code> blocks are found here. The receiver is automatically passed as the first argument (<code>self</code>).</p>
<pre><code class="language-forge">thing Circle { radius: float }

give Circle {
    fn area(self) {
        3.14159 * self.radius * self.radius
    }
}

let c = Circle { radius: 5.0 }
say c.area()    // 78.53975
</code></pre>
<h3 id="4-embedded-field-delegation"><a class="header" href="#4-embedded-field-delegation">4. Embedded Field Delegation</a></h3>
<p>If the receiver is a typed object and no method is found in step 3, the interpreter checks embedded fields (declared with <code>has</code>). For each embedded field, the interpreter looks up the embedded type’s method table. If a match is found, the embedded sub-object is passed as <code>self</code> instead of the outer object.</p>
<pre><code class="language-forge">thing Animal { name: string }
give Animal {
    fn speak(self) { "{self.name} speaks" }
}

thing Pet {
    has animal: Animal
    owner: string
}

let p = Pet { animal: Animal { name: "Rex" }, owner: "Alice" }
say p.speak()   // "Rex speaks" (delegated to Animal.speak)
</code></pre>
<h3 id="5-built-in-string-methods"><a class="header" href="#5-built-in-string-methods">5. Built-in String Methods</a></h3>
<p>Strings have a small set of built-in methods that are resolved directly without going through the method table:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Return Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>.upper()</code></td><td><code>string</code></td><td>Uppercase copy</td></tr>
<tr><td><code>.lower()</code></td><td><code>string</code></td><td>Lowercase copy</td></tr>
<tr><td><code>.trim()</code></td><td><code>string</code></td><td>Trimmed copy</td></tr>
<tr><td><code>.len()</code></td><td><code>int</code></td><td>Byte length</td></tr>
<tr><td><code>.chars()</code></td><td><code>array</code></td><td>Array of single-character strings</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">say "hello".upper()     // "HELLO"
say "  hi  ".trim()     // "hi"
say "abc".chars()       // ["a", "b", "c"]
</code></pre>
<h3 id="6-known-built-in-methods"><a class="header" href="#6-known-built-in-methods">6. Known Built-in Methods</a></h3>
<p>If none of the above steps match, Forge checks a set of known built-in method names. If the method name matches, the call is rewritten as a function call with the receiver prepended to the argument list: <code>obj.method(args)</code> becomes <code>method(obj, args)</code>.</p>
<p>This allows calling built-in functions with method syntax:</p>
<pre><code class="language-forge">let nums = [3, 1, 2]
say nums.sort()             // [1, 2, 3]
say nums.map(fn(x) { x * 2 })  // [6, 2, 4]
say nums.filter(fn(x) { x &gt; 1 })   // [3, 2]

let text = "hello world"
say text.split(" ")        // ["hello", "world"]
say text.starts_with("hello")  // true
</code></pre>
<p>The full list of known built-in methods includes: <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>sort</code>, <code>reverse</code>, <code>push</code>, <code>pop</code>, <code>len</code>, <code>contains</code>, <code>keys</code>, <code>values</code>, <code>enumerate</code>, <code>split</code>, <code>join</code>, <code>replace</code>, <code>find</code>, <code>flat_map</code>, <code>has_key</code>, <code>get</code>, <code>pick</code>, <code>omit</code>, <code>merge</code>, <code>entries</code>, <code>from_entries</code>, <code>starts_with</code>, <code>ends_with</code>, <code>upper</code>, <code>lower</code>, <code>trim</code>, <code>substring</code>, <code>index_of</code>, <code>last_index_of</code>, <code>pad_start</code>, <code>pad_end</code>, <code>capitalize</code>, <code>title</code>, <code>repeat_str</code>, <code>count</code>, <code>sum</code>, <code>min_of</code>, <code>max_of</code>, <code>any</code>, <code>all</code>, <code>unique</code>, <code>zip</code>, <code>flatten</code>, <code>group_by</code>, <code>chunk</code>, <code>slice</code>, <code>slugify</code>, <code>snake_case</code>, <code>camel_case</code>, <code>sample</code>, <code>shuffle</code>, <code>partition</code>, <code>diff</code>.</p>
<h2 id="self-parameter"><a class="header" href="#self-parameter">Self Parameter</a></h2>
<p>Methods defined in <code>give</code>/<code>impl</code> blocks receive the receiver as their first argument, conventionally named <code>self</code>. This parameter must be declared explicitly.</p>
<pre><code class="language-forge">thing Rect { w: int, h: int }

give Rect {
    fn area(self) {
        self.w * self.h
    }
    fn scale(self, factor) {
        Rect { w: self.w * factor, h: self.h * factor }
    }
}
</code></pre>
<h2 id="method-chaining"><a class="header" href="#method-chaining">Method Chaining</a></h2>
<p>Method calls can be chained. Each call in the chain returns a value that becomes the receiver for the next call.</p>
<pre><code class="language-forge">let result = [5, 2, 8, 1, 9]
    .sort()
    .filter(fn(x) { x &gt; 3 })
    .map(fn(x) { x * 10 })
// result: [50, 80, 90]
</code></pre>
<h2 id="resolution-failure"><a class="header" href="#resolution-failure">Resolution Failure</a></h2>
<p>If method resolution exhausts all steps without finding a match, a runtime error is produced:</p>
<pre><code class="language-forge">let x = 42
say x.nonexistent()     // runtime error: unknown method 'nonexistent'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="closures-and-lambdas-1"><a class="header" href="#closures-and-lambdas-1">Closures and Lambdas</a></h1>
<p>A <strong>closure</strong> (also called a <strong>lambda</strong>) is an anonymous function expression that captures variables from its enclosing scope. Closures are first-class values: they can be stored in variables, passed as arguments, and returned from functions.</p>
<h2 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h2>
<pre><code>fn(parameters) { body }
</code></pre>
<p>The keyword <code>fn</code> introduces a closure. Parameters are comma-separated identifiers enclosed in parentheses. The body is a block of statements.</p>
<pre><code class="language-forge">let double = fn(x) { x * 2 }
say double(5)       // 10
</code></pre>
<h2 id="no-parameter-closures"><a class="header" href="#no-parameter-closures">No-Parameter Closures</a></h2>
<p>Closures with no parameters use empty parentheses:</p>
<pre><code class="language-forge">let greet = fn() { "hello" }
say greet()         // "hello"
</code></pre>
<h2 id="implicit-return"><a class="header" href="#implicit-return">Implicit Return</a></h2>
<p>The last expression in a closure body is its return value. An explicit <code>return</code> statement is also permitted but rarely needed.</p>
<pre><code class="language-forge">let add = fn(a, b) { a + b }       // implicit return
say add(3, 4)                       // 7

let abs = fn(x) {
    if x &lt; 0 {
        return -x                   // explicit return
    }
    x
}
</code></pre>
<h2 id="capture-semantics"><a class="header" href="#capture-semantics">Capture Semantics</a></h2>
<p>Closures capture variables from their enclosing scope <strong>by reference</strong>. Changes to captured variables are visible inside the closure, and mutations inside the closure affect the outer scope.</p>
<pre><code class="language-forge">let mut count = 0
let increment = fn() {
    count = count + 1
    count
}
say increment()     // 1
say increment()     // 2
say count           // 2
</code></pre>
<h3 id="capture-at-definition-time"><a class="header" href="#capture-at-definition-time">Capture at Definition Time</a></h3>
<p>The closure captures a reference to the variable’s binding, not its current value. The variable is resolved at the time the closure is called, not when it is defined.</p>
<pre><code class="language-forge">let mut x = 10
let get_x = fn() { x }
say get_x()         // 10

x = 20
say get_x()         // 20
</code></pre>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h2>
<p>Closures enable higher-order programming patterns. A higher-order function either takes a function as an argument or returns one.</p>
<h3 id="closures-as-arguments"><a class="header" href="#closures-as-arguments">Closures as Arguments</a></h3>
<p>Many built-in functions accept closures:</p>
<pre><code class="language-forge">let nums = [1, 2, 3, 4, 5]

let evens = filter(nums, fn(x) { x % 2 == 0 })
say evens       // [2, 4]

let doubled = map(nums, fn(x) { x * 2 })
say doubled     // [2, 4, 6, 8, 10]

let total = reduce(nums, 0, fn(acc, x) { acc + x })
say total       // 15
</code></pre>
<h3 id="returning-closures"><a class="header" href="#returning-closures">Returning Closures</a></h3>
<p>Functions can return closures, creating function factories:</p>
<pre><code class="language-forge">fn make_adder(n) {
    fn(x) { x + n }
}

let add5 = make_adder(5)
say add5(10)    // 15
say add5(20)    // 25
</code></pre>
<h2 id="closures-in-method-syntax"><a class="header" href="#closures-in-method-syntax">Closures in Method Syntax</a></h2>
<p>Closures integrate naturally with method-style calls:</p>
<pre><code class="language-forge">let names = ["Charlie", "Alice", "Bob"]
let sorted = names.sort(fn(a, b) { a &lt; b })
say sorted      // ["Alice", "Bob", "Charlie"]
</code></pre>
<h2 id="multi-statement-bodies"><a class="header" href="#multi-statement-bodies">Multi-Statement Bodies</a></h2>
<p>Closure bodies can contain multiple statements. The last expression is the return value.</p>
<pre><code class="language-forge">let process = fn(items) {
    let filtered = filter(items, fn(x) { x &gt; 0 })
    let doubled = map(filtered, fn(x) { x * 2 })
    doubled
}
say process([-1, 2, -3, 4])    // [4, 8]
</code></pre>
<h2 id="closures-vs-named-functions"><a class="header" href="#closures-vs-named-functions">Closures vs Named Functions</a></h2>
<p>Closures and named functions (<code>fn name(...) { }</code> / <code>define name(...) { }</code>) differ in two ways:</p>
<ol>
<li><strong>Naming</strong>: Named functions are bound to a name in the current scope. Closures are anonymous and must be assigned to a variable explicitly.</li>
<li><strong>Hoisting</strong>: Named functions are available throughout their defining scope. Closures are only available after the variable assignment that holds them.</li>
</ol>
<p>Both named functions and closures capture their environment identically.</p>
<h2 id="recursive-closures"><a class="header" href="#recursive-closures">Recursive Closures</a></h2>
<p>A closure can call itself recursively if it is assigned to a variable that is in scope at the time of the call:</p>
<pre><code class="language-forge">let factorial = fn(n) {
    if n &lt;= 1 { 1 }
    else { n * factorial(n - 1) }
}
say factorial(5)    // 120
</code></pre>
<h2 id="type-annotations-1"><a class="header" href="#type-annotations-1">Type Annotations</a></h2>
<p>Closures do not currently support parameter or return type annotations. The types of parameters and the return value are inferred at runtime.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="when-guards"><a class="header" href="#when-guards">When Guards</a></h1>
<p>A <strong>when expression</strong> performs multi-way branching on a scrutinee value using comparison operators. Each arm specifies a comparison operation applied to the scrutinee; the first matching arm’s result expression is returned.</p>
<h2 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h2>
<pre><code>when expression {
    op value -&gt; result,
    op value -&gt; result,
    else -&gt; result
}
</code></pre>
<p>The <strong>scrutinee</strong> is the expression after <code>when</code>. Each <strong>arm</strong> consists of a comparison operator, a value to compare against, the <code>-&gt;</code> arrow, and a result expression. The optional <code>else</code> arm matches when no other arm does.</p>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<pre><code class="language-forge">let label = when age {
    &lt; 13 -&gt; "child",
    &lt; 18 -&gt; "teen",
    &lt; 65 -&gt; "adult",
    else -&gt; "senior"
}
say label
</code></pre>
<p>The scrutinee <code>age</code> is evaluated once. Each arm’s operator and value are applied to the scrutinee in order. The first arm whose comparison returns <code>true</code> provides the result.</p>
<h2 id="comparison-operators-in-arms"><a class="header" href="#comparison-operators-in-arms">Comparison Operators in Arms</a></h2>
<p>Arms support any comparison operator:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>&lt;</code></td><td>Less than</td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equal</td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equal</td></tr>
<tr><td><code>==</code></td><td>Equal</td></tr>
<tr><td><code>!=</code></td><td>Not equal</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let status = when code {
    == 200 -&gt; "ok",
    == 404 -&gt; "not found",
    == 500 -&gt; "server error",
    &gt;= 400 -&gt; "client error",
    else -&gt; "unknown"
}
</code></pre>
<h2 id="evaluation-semantics"><a class="header" href="#evaluation-semantics">Evaluation Semantics</a></h2>
<ol>
<li>The scrutinee expression is evaluated exactly once.</li>
<li>Arms are tested top to bottom.</li>
<li>For each arm, the arm’s comparison operator is applied with the scrutinee as the left operand and the arm’s value as the right operand.</li>
<li>The first arm that produces <code>true</code> determines the result: its result expression is evaluated and returned.</li>
<li>If no arm matches and an <code>else</code> arm is present, the <code>else</code> result is returned.</li>
<li>If no arm matches and no <code>else</code> arm is present, the when expression evaluates to <code>null</code>.</li>
</ol>
<h2 id="when-as-an-expression"><a class="header" href="#when-as-an-expression">When as an Expression</a></h2>
<p><code>when</code> produces a value and can be used anywhere an expression is expected:</p>
<pre><code class="language-forge">say when score {
    &gt;= 90 -&gt; "A",
    &gt;= 80 -&gt; "B",
    &gt;= 70 -&gt; "C",
    else -&gt; "F"
}

let discount = when items {
    &gt; 100 -&gt; 0.20,
    &gt; 50 -&gt; 0.10,
    &gt; 10 -&gt; 0.05,
    else -&gt; 0.0
}
</code></pre>
<h2 id="when-as-a-statement"><a class="header" href="#when-as-a-statement">When as a Statement</a></h2>
<p><code>when</code> can also appear at the statement level:</p>
<pre><code class="language-forge">when temperature {
    &gt; 100 -&gt; say "boiling",
    &lt; 0 -&gt; say "freezing",
    else -&gt; say "normal"
}
</code></pre>
<h2 id="arm-result-expressions"><a class="header" href="#arm-result-expressions">Arm Result Expressions</a></h2>
<p>Each arm’s result is a single expression. For multi-statement logic, use a block expression or call a function:</p>
<pre><code class="language-forge">let result = when level {
    &gt; 10 -&gt; {
        let bonus = level * 2
        bonus + 100
    },
    else -&gt; 0
}
</code></pre>
<h2 id="the-else-arm"><a class="header" href="#the-else-arm">The else Arm</a></h2>
<p>The <code>else</code> arm is a catch-all that matches when no other arm does. It must be the last arm if present.</p>
<pre><code class="language-forge">let kind = when x {
    &gt; 0 -&gt; "positive",
    &lt; 0 -&gt; "negative",
    else -&gt; "zero"
}
</code></pre>
<p>If no <code>else</code> arm is provided and no arm matches, the when expression evaluates to <code>null</code>.</p>
<h2 id="differences-from-match"><a class="header" href="#differences-from-match">Differences from Match</a></h2>
<p><code>when</code> guards and <code>match</code> expressions serve different purposes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th><code>when</code></th><th><code>match</code></th></tr>
</thead>
<tbody>
<tr><td>Comparison style</td><td>Operator-based guards</td><td>Structural pattern matching</td></tr>
<tr><td>Scrutinee</td><td>Compared via operators</td><td>Destructured via patterns</td></tr>
<tr><td>Use case</td><td>Numeric/comparable ranges</td><td>ADT variant matching</td></tr>
</tbody>
</table>
</div>
<p>See <a href="#match-expressions-1">Match Expressions</a> for structural pattern matching.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="match-expressions-1"><a class="header" href="#match-expressions-1">Match Expressions</a></h1>
<p>A <strong>match expression</strong> performs structural pattern matching on a value. Each arm specifies a pattern; the first arm whose pattern matches the scrutinee has its body evaluated.</p>
<h2 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h2>
<pre><code>match expression {
    pattern =&gt; body,
    pattern =&gt; body,
    ...
}
</code></pre>
<p>The <strong>scrutinee</strong> is the expression after <code>match</code>. Each <strong>arm</strong> consists of a pattern, the <code>=&gt;</code> arrow, and a body (one or more statements). Arms are separated by commas.</p>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<p>Forge supports the following pattern forms:</p>
<h3 id="wildcard-pattern-1"><a class="header" href="#wildcard-pattern-1">Wildcard Pattern</a></h3>
<p>The underscore <code>_</code> matches any value and binds nothing.</p>
<pre><code class="language-forge">match x {
    _ =&gt; say "matched anything"
}
</code></pre>
<h3 id="literal-pattern"><a class="header" href="#literal-pattern">Literal Pattern</a></h3>
<p>A literal value matches if the scrutinee is equal to that value.</p>
<pre><code class="language-forge">match color {
    "red" =&gt; say "stop",
    "green" =&gt; say "go",
    "yellow" =&gt; say "caution",
    _ =&gt; say "unknown"
}
</code></pre>
<h3 id="binding-pattern"><a class="header" href="#binding-pattern">Binding Pattern</a></h3>
<p>A bare identifier binds the matched value to that name within the arm body.</p>
<pre><code class="language-forge">match value {
    x =&gt; say "got: {x}"
}
</code></pre>
<h3 id="constructor-pattern"><a class="header" href="#constructor-pattern">Constructor Pattern</a></h3>
<p>A constructor pattern matches an algebraic data type (ADT) variant and destructures its fields. The pattern names the variant and provides sub-patterns for each field.</p>
<pre><code class="language-forge">type Shape {
    Circle(float)
    Rect(float, float)
    Point
}

let s = Circle(5.0)

match s {
    Circle(r) =&gt; say "circle with radius {r}",
    Rect(w, h) =&gt; say "rectangle {w} x {h}",
    Point =&gt; say "a point",
    _ =&gt; say "unknown shape"
}
</code></pre>
<p>Nested constructor patterns are supported:</p>
<pre><code class="language-forge">type Expr {
    Num(int)
    Add(Expr, Expr)
}

match expr {
    Add(Num(a), Num(b)) =&gt; say "sum: {a + b}",
    Num(n) =&gt; say "number: {n}",
    _ =&gt; say "complex expression"
}
</code></pre>
<h2 id="evaluation-semantics-1"><a class="header" href="#evaluation-semantics-1">Evaluation Semantics</a></h2>
<ol>
<li>The scrutinee expression is evaluated exactly once.</li>
<li>Arms are tested top to bottom.</li>
<li>For each arm, the pattern is matched against the scrutinee:
<ul>
<li><strong>Wildcard</strong>: Always matches.</li>
<li><strong>Literal</strong>: Matches if the scrutinee equals the literal value.</li>
<li><strong>Binding</strong>: Always matches; binds the scrutinee to the identifier.</li>
<li><strong>Constructor</strong>: Matches if the scrutinee is an ADT value with the same variant name and the correct number of fields, and all sub-patterns recursively match.</li>
</ul>
</li>
<li>The first matching arm’s body is evaluated. Bindings introduced by the pattern are in scope for the body.</li>
<li>If no arm matches, the match expression evaluates to <code>null</code>.</li>
</ol>
<h2 id="match-as-an-expression"><a class="header" href="#match-as-an-expression">Match as an Expression</a></h2>
<p><code>match</code> produces a value and can be used in expression position:</p>
<pre><code class="language-forge">let area = match shape {
    Circle(r) =&gt; 3.14159 * r * r,
    Rect(w, h) =&gt; w * h,
    _ =&gt; 0.0
}
</code></pre>
<h2 id="match-as-a-statement"><a class="header" href="#match-as-a-statement">Match as a Statement</a></h2>
<p><code>match</code> can appear at the statement level:</p>
<pre><code class="language-forge">match event {
    Click(x, y) =&gt; handle_click(x, y),
    KeyPress(key) =&gt; handle_key(key),
    _ =&gt; {}
}
</code></pre>
<h2 id="multi-statement-arm-bodies"><a class="header" href="#multi-statement-arm-bodies">Multi-Statement Arm Bodies</a></h2>
<p>Arm bodies can contain multiple statements. The last expression in the block is the value of the arm.</p>
<pre><code class="language-forge">let result = match data {
    Some(value) =&gt; {
        let processed = transform(value)
        validate(processed)
        processed
    },
    None =&gt; default_value()
}
</code></pre>
<h2 id="adt-matching"><a class="header" href="#adt-matching">ADT Matching</a></h2>
<p>Match is the primary mechanism for working with algebraic data types (see <a href="#algebraic-data-types">Algebraic Data Types</a>).</p>
<pre><code class="language-forge">type Result {
    Ok(any)
    Err(string)
}

fn handle(r) {
    match r {
        Ok(value) =&gt; say "success: {value}",
        Err(msg) =&gt; say "error: {msg}"
    }
}
</code></pre>
<h2 id="exhaustiveness-1"><a class="header" href="#exhaustiveness-1">Exhaustiveness</a></h2>
<p>Forge does not currently enforce exhaustive matching. If no arm matches the scrutinee, the match expression evaluates to <code>null</code>. Use a wildcard <code>_</code> arm as the final arm to ensure all cases are handled.</p>
<h2 id="differences-from-when-guards"><a class="header" href="#differences-from-when-guards">Differences from When Guards</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th><code>match</code></th><th><code>when</code></th></tr>
</thead>
<tbody>
<tr><td>Arrow syntax</td><td><code>=&gt;</code></td><td><code>-&gt;</code></td></tr>
<tr><td>Matching style</td><td>Structural patterns</td><td>Comparison operators</td></tr>
<tr><td>Destructuring</td><td>Yes (ADT variants)</td><td>No</td></tr>
<tr><td>Use case</td><td>ADT variants, literal dispatch</td><td>Numeric ranges, comparisons</td></tr>
</tbody>
</table>
</div>
<p>See <a href="#when-guards">When Guards</a> for operator-based branching.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<p>A <strong>statement</strong> is a syntactic construct that performs an action. Unlike <a href="#expressions">expressions</a>, statements do not produce values (with the exception of expression statements, where an expression is evaluated for its side effects and the result is discarded).</p>
<p>A Forge program is a sequence of statements executed top to bottom.</p>
<h2 id="statement-categories"><a class="header" href="#statement-categories">Statement Categories</a></h2>
<h3 id="declarations"><a class="header" href="#declarations">Declarations</a></h3>
<p>Declarations introduce new names into the current scope.</p>
<ul>
<li><strong>Variable declaration</strong>: <code>let x = expr</code> / <code>set x to expr</code> – binds a value to a name. See <a href="#variable-declaration">Variable Declaration</a>.</li>
<li><strong>Function declaration</strong>: <code>fn name(params) { body }</code> / <code>define name(params) { body }</code> – binds a function to a name. See <a href="#function-declaration">Function Declaration</a>.</li>
<li><strong>Destructuring declaration</strong>: <code>let {a, b} = obj</code> / <code>unpack {a, b} from obj</code> – binds multiple names from a compound value. See <a href="#variable-declaration">Variable Declaration</a>.</li>
</ul>
<h3 id="assignments"><a class="header" href="#assignments">Assignments</a></h3>
<p>Assignments change the value of an existing binding.</p>
<ul>
<li><strong>Simple assignment</strong>: <code>x = expr</code> / <code>change x to expr</code></li>
<li><strong>Compound assignment</strong>: <code>x += expr</code>, <code>x -= expr</code>, <code>x *= expr</code>, <code>x /= expr</code></li>
<li><strong>Field assignment</strong>: <code>obj.field = expr</code></li>
<li><strong>Index assignment</strong>: <code>arr[i] = expr</code></li>
</ul>
<p>See <a href="#assignment">Assignment</a>.</p>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<p>Control flow statements direct the order of execution.</p>
<ul>
<li><strong>Conditional</strong>: <code>if condition { body }</code> with optional <code>else</code>/<code>otherwise</code>/<code>nah</code> clauses. See <a href="#control-flow-1">Control Flow</a>.</li>
<li><strong>When guards</strong>: <code>when expr { arms }</code> – multi-way branch on a value. See <a href="#when-guards">When Guards</a>.</li>
<li><strong>Match</strong>: <code>match expr { arms }</code> – structural pattern matching. See <a href="#match-expressions-1">Match Expressions</a>.</li>
</ul>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<p>Loop statements execute a body repeatedly.</p>
<ul>
<li><strong>For-in</strong>: <code>for item in collection { body }</code> / <code>for each item in collection { body }</code></li>
<li><strong>While</strong>: <code>while condition { body }</code></li>
<li><strong>Loop</strong>: <code>loop { body }</code> – infinite loop, exit with <code>break</code></li>
<li><strong>Repeat</strong>: <code>repeat N times { body }</code> – counted loop</li>
</ul>
<p>See <a href="#loops-1">Loops</a>.</p>
<h3 id="jump-statements"><a class="header" href="#jump-statements">Jump Statements</a></h3>
<p>Jump statements transfer control to a different point in the program.</p>
<ul>
<li><strong>return</strong>: Exits the current function, optionally with a value.</li>
<li><strong>break</strong>: Exits the innermost loop.</li>
<li><strong>continue</strong>: Skips to the next iteration of the innermost loop.</li>
</ul>
<p>See <a href="#return-break-continue">Return, Break, Continue</a>.</p>
<h3 id="module-statements"><a class="header" href="#module-statements">Module Statements</a></h3>
<p>Module statements manage code organization across files.</p>
<ul>
<li><strong>import</strong>: <code>import "file.fg"</code> – executes another file and imports its definitions.</li>
</ul>
<p>See <a href="#import-and-export">Import and Export</a>.</p>
<h3 id="expression-statements"><a class="header" href="#expression-statements">Expression Statements</a></h3>
<p>Any expression can appear as a statement. The expression is evaluated and its result is discarded. This is how function calls with side effects are written.</p>
<pre><code class="language-forge">say "hello"             // function call as statement
push(items, 42)         // side-effecting call
</code></pre>
<h2 id="statement-terminators"><a class="header" href="#statement-terminators">Statement Terminators</a></h2>
<p>Forge does not require semicolons or other explicit statement terminators. Statements are separated by newlines. Multiple statements may appear on a single line if they are unambiguous to the parser.</p>
<pre><code class="language-forge">let x = 10
let y = 20
say x + y
</code></pre>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>A <strong>block</strong> is a sequence of statements enclosed in <code>{</code> and <code>}</code>. Blocks appear as the body of functions, loops, conditionals, and other compound statements. Blocks create a new scope: variables declared inside a block are not visible outside it.</p>
<pre><code class="language-forge">let x = "outer"
{
    let x = "inner"
    say x           // "inner"
}
say x               // "outer"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="variable-declaration"><a class="header" href="#variable-declaration">Variable Declaration</a></h1>
<p>Variable declarations introduce new bindings in the current scope. Forge supports both classic and natural syntax forms, with optional mutability and destructuring.</p>
<h2 id="immutable-variables"><a class="header" href="#immutable-variables">Immutable Variables</a></h2>
<p>By default, variables are immutable. An immutable binding cannot be reassigned after initialization.</p>
<h3 id="classic-syntax"><a class="header" href="#classic-syntax">Classic Syntax</a></h3>
<pre><code class="language-forge">let name = "Alice"
let age = 30
let items = [1, 2, 3]
</code></pre>
<h3 id="natural-syntax"><a class="header" href="#natural-syntax">Natural Syntax</a></h3>
<pre><code class="language-forge">set name to "Alice"
set age to 30
set items to [1, 2, 3]
</code></pre>
<p>Both forms are semantically identical. The variable is bound to the result of evaluating the right-hand expression.</p>
<h2 id="mutable-variables"><a class="header" href="#mutable-variables">Mutable Variables</a></h2>
<p>To allow a variable to be reassigned after its initial declaration, use the <code>mut</code> keyword.</p>
<h3 id="classic-syntax-1"><a class="header" href="#classic-syntax-1">Classic Syntax</a></h3>
<pre><code class="language-forge">let mut count = 0
count = count + 1       // allowed
</code></pre>
<h3 id="natural-syntax-1"><a class="header" href="#natural-syntax-1">Natural Syntax</a></h3>
<pre><code class="language-forge">set mut count to 0
change count to count + 1   // allowed
</code></pre>
<p>Attempting to reassign an immutable variable produces a runtime error:</p>
<pre><code class="language-forge">let x = 10
x = 20          // runtime error: cannot reassign immutable variable 'x'
</code></pre>
<h2 id="type-annotations-2"><a class="header" href="#type-annotations-2">Type Annotations</a></h2>
<p>Variable declarations may include an optional type annotation after the variable name:</p>
<pre><code class="language-forge">let name: string = "Alice"
let age: int = 30
let ratio: float = 0.5
</code></pre>
<p>Type annotations are checked by the type checker when enabled. They do not affect runtime behavior in the interpreter.</p>
<h2 id="initializer-expressions"><a class="header" href="#initializer-expressions">Initializer Expressions</a></h2>
<p>The right-hand side of a variable declaration is any valid expression:</p>
<pre><code class="language-forge">let sum = 1 + 2 + 3
let greeting = "Hello, {name}!"
let data = fs.read("config.json")
let result = compute(x, y)
</code></pre>
<p>Every variable declaration requires an initializer. There is no uninitialized variable syntax.</p>
<h2 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h2>
<p>Forge supports destructuring assignment for objects and arrays.</p>
<h3 id="object-destructuring"><a class="header" href="#object-destructuring">Object Destructuring</a></h3>
<h4 id="classic-syntax-2"><a class="header" href="#classic-syntax-2">Classic Syntax</a></h4>
<pre><code class="language-forge">let person = { name: "Alice", age: 30, city: "NYC" }
let { name, age } = person
say name    // "Alice"
say age     // 30
</code></pre>
<h4 id="natural-syntax-2"><a class="header" href="#natural-syntax-2">Natural Syntax</a></h4>
<pre><code class="language-forge">let person = { name: "Alice", age: 30, city: "NYC" }
unpack { name, age } from person
say name    // "Alice"
say age     // 30
</code></pre>
<p>Object destructuring extracts the named fields from an object and binds them to variables with the same names.</p>
<h3 id="array-destructuring"><a class="header" href="#array-destructuring">Array Destructuring</a></h3>
<pre><code class="language-forge">let coords = [10, 20, 30]
let [x, y, z] = coords
say x   // 10
say y   // 20
say z   // 30
</code></pre>
<h4 id="rest-pattern"><a class="header" href="#rest-pattern">Rest Pattern</a></h4>
<p>Array destructuring supports a rest pattern to capture remaining elements:</p>
<pre><code class="language-forge">let items = [1, 2, 3, 4, 5]
let [first, ...rest] = items
say first   // 1
say rest    // [2, 3, 4, 5]
</code></pre>
<h2 id="scope-1"><a class="header" href="#scope-1">Scope</a></h2>
<p>Variables are scoped to the block in which they are declared. A variable declared inside an <code>if</code> body, loop body, or function body is not accessible outside that block.</p>
<pre><code class="language-forge">if true {
    let x = 42
    say x       // 42
}
// x is not accessible here
</code></pre>
<p>Inner scopes can shadow variables from outer scopes:</p>
<pre><code class="language-forge">let x = "outer"
{
    let x = "inner"
    say x           // "inner"
}
say x               // "outer"
</code></pre>
<h2 id="multiple-declarations"><a class="header" href="#multiple-declarations">Multiple Declarations</a></h2>
<p>Each <code>let</code>/<code>set</code> statement declares a single binding (or a destructuring pattern). To declare multiple variables, use separate statements:</p>
<pre><code class="language-forge">let x = 1
let y = 2
let z = 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="assignment"><a class="header" href="#assignment">Assignment</a></h1>
<p>Assignment statements change the value of an existing mutable binding. The target must have been declared with <code>mut</code> (or <code>let mut</code> / <code>set mut</code>).</p>
<h2 id="simple-assignment"><a class="header" href="#simple-assignment">Simple Assignment</a></h2>
<h3 id="classic-syntax-3"><a class="header" href="#classic-syntax-3">Classic Syntax</a></h3>
<pre><code class="language-forge">let mut x = 10
x = 20
say x       // 20
</code></pre>
<h3 id="natural-syntax-3"><a class="header" href="#natural-syntax-3">Natural Syntax</a></h3>
<pre><code class="language-forge">set mut x to 10
change x to 20
say x       // 20
</code></pre>
<p>Both forms evaluate the right-hand expression and store the result in the named variable.</p>
<h2 id="mutability-requirement"><a class="header" href="#mutability-requirement">Mutability Requirement</a></h2>
<p>Only variables declared with <code>mut</code> can be reassigned. Attempting to assign to an immutable variable produces a runtime error:</p>
<pre><code class="language-forge">let x = 10
x = 20          // runtime error: cannot reassign immutable variable 'x'
</code></pre>
<h2 id="compound-assignment"><a class="header" href="#compound-assignment">Compound Assignment</a></h2>
<p>Compound assignment operators combine an arithmetic operation with assignment. The target must be mutable.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Equivalent To</th></tr>
</thead>
<tbody>
<tr><td><code>x += y</code></td><td><code>x = x + y</code></td></tr>
<tr><td><code>x -= y</code></td><td><code>x = x - y</code></td></tr>
<tr><td><code>x *= y</code></td><td><code>x = x * y</code></td></tr>
<tr><td><code>x /= y</code></td><td><code>x = x / y</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let mut count = 0
count += 1          // count is 1
count += 5          // count is 6
count *= 2          // count is 12
count -= 3          // count is 9
count /= 3          // count is 3
</code></pre>
<p>Compound assignment with <code>+=</code> on strings performs concatenation:</p>
<pre><code class="language-forge">let mut msg = "hello"
msg += " world"
say msg     // "hello world"
</code></pre>
<h2 id="field-assignment"><a class="header" href="#field-assignment">Field Assignment</a></h2>
<p>Fields on objects and struct instances can be assigned using dot notation:</p>
<pre><code class="language-forge">let mut user = { name: "Alice", age: 30 }
user.age = 31
say user.age    // 31
</code></pre>
<p>Nested field assignment is supported:</p>
<pre><code class="language-forge">let mut config = { server: { port: 8080 } }
config.server.port = 3000
say config.server.port  // 3000
</code></pre>
<h2 id="index-assignment"><a class="header" href="#index-assignment">Index Assignment</a></h2>
<p>Array elements and object keys can be assigned using bracket notation:</p>
<pre><code class="language-forge">let mut items = [10, 20, 30]
items[1] = 99
say items       // [10, 99, 30]

let mut obj = { a: 1, b: 2 }
obj["a"] = 100
say obj.a       // 100
</code></pre>
<h2 id="assignment-is-not-an-expression"><a class="header" href="#assignment-is-not-an-expression">Assignment Is Not an Expression</a></h2>
<p>In Forge, assignment is a statement, not an expression. Assignment does not produce a value and cannot be used in expression position:</p>
<pre><code class="language-forge">// This is NOT valid:
// let y = (x = 5)

// Use separate statements:
let mut x = 0
x = 5
let y = x
</code></pre>
<h2 id="evaluation-order"><a class="header" href="#evaluation-order">Evaluation Order</a></h2>
<p>In an assignment <code>target = expression</code>, the right-hand expression is evaluated first, then the result is stored in the target location.</p>
<p>For compound assignment <code>target += expression</code>, the current value of the target is read, the operation is performed with the right-hand expression, and the result is stored back.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="control-flow-1"><a class="header" href="#control-flow-1">Control Flow</a></h1>
<p>Control flow statements direct the order of execution based on conditions.</p>
<h2 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h2>
<p>The <code>if</code> statement executes a block of code when a condition is truthy.</p>
<pre><code class="language-forge">if temperature &gt; 100 {
    say "boiling"
}
</code></pre>
<p>The condition is any expression. It is evaluated using Forge’s <a href="#truthiness-rules">truthiness rules</a>: <code>false</code> and <code>null</code> are falsy, everything else is truthy.</p>
<h2 id="if-else"><a class="header" href="#if-else">If-Else</a></h2>
<p>An <code>else</code> clause provides an alternative block when the condition is falsy. Forge supports three equivalent keywords for the else clause:</p>
<h3 id="classic-else"><a class="header" href="#classic-else">Classic: <code>else</code></a></h3>
<pre><code class="language-forge">if age &gt;= 18 {
    say "adult"
} else {
    say "minor"
}
</code></pre>
<h3 id="natural-otherwise"><a class="header" href="#natural-otherwise">Natural: <code>otherwise</code></a></h3>
<pre><code class="language-forge">if age &gt;= 18 {
    say "adult"
} otherwise {
    say "minor"
}
</code></pre>
<h3 id="casual-nah"><a class="header" href="#casual-nah">Casual: <code>nah</code></a></h3>
<pre><code class="language-forge">if age &gt;= 18 {
    say "adult"
} nah {
    say "minor"
}
</code></pre>
<p>All three forms are semantically identical. The else block executes when the condition is falsy.</p>
<h2 id="if-else-if-chains"><a class="header" href="#if-else-if-chains">If-Else If Chains</a></h2>
<p>Multiple conditions can be tested in sequence using <code>else if</code> (or <code>otherwise if</code> / <code>nah if</code>):</p>
<pre><code class="language-forge">if score &gt;= 90 {
    say "A"
} else if score &gt;= 80 {
    say "B"
} else if score &gt;= 70 {
    say "C"
} else {
    say "F"
}
</code></pre>
<p>Conditions are tested top to bottom. The first truthy condition’s block is executed. If no condition is truthy and an <code>else</code> clause is present, its block executes.</p>
<h2 id="nested-if-statements"><a class="header" href="#nested-if-statements">Nested If Statements</a></h2>
<p>If statements can be nested arbitrarily:</p>
<pre><code class="language-forge">if user != null {
    if user.role == "admin" {
        say "admin access"
    } else {
        say "regular access"
    }
} else {
    say "not logged in"
}
</code></pre>
<h2 id="block-scoping"><a class="header" href="#block-scoping">Block Scoping</a></h2>
<p>Variables declared inside an <code>if</code> or <code>else</code> block are scoped to that block:</p>
<pre><code class="language-forge">if true {
    let msg = "inside"
    say msg     // "inside"
}
// msg is not accessible here
</code></pre>
<h2 id="no-ternary-operator"><a class="header" href="#no-ternary-operator">No Ternary Operator</a></h2>
<p>Forge does not have a ternary conditional operator (<code>condition ? a : b</code>). Use an <code>if</code>-<code>else</code> statement or a <code>when</code> expression instead:</p>
<pre><code class="language-forge">// Using when as a conditional expression
let label = when age {
    &gt;= 18 -&gt; "adult",
    else -&gt; "minor"
}
</code></pre>
<h2 id="if-as-a-statement"><a class="header" href="#if-as-a-statement">If as a Statement</a></h2>
<p><code>if</code> is always a statement in Forge. It does not produce a value that can be used in expression position. To select between values conditionally, use a <a href="#when-guards"><code>when</code> expression</a>.</p>
<h2 id="truthiness-in-conditions"><a class="header" href="#truthiness-in-conditions">Truthiness in Conditions</a></h2>
<p>The condition in an <code>if</code> statement follows Forge’s truthiness rules:</p>
<pre><code class="language-forge">if 0 {
    say "zero is truthy"        // this executes
}

if "" {
    say "empty string is truthy"    // this executes
}

if null {
    say "unreachable"
} else {
    say "null is falsy"         // this executes
}

if false {
    say "unreachable"
} else {
    say "false is falsy"        // this executes
}
</code></pre>
<p>See <a href="#truthiness-rules">Truthiness Rules</a> for the complete specification.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="loops-1"><a class="header" href="#loops-1">Loops</a></h1>
<p>Loop statements execute a body repeatedly. Forge provides several loop forms for different iteration patterns.</p>
<h2 id="for-in-loops"><a class="header" href="#for-in-loops">For-In Loops</a></h2>
<p>The <code>for</code>-<code>in</code> loop iterates over elements of a collection.</p>
<pre><code class="language-forge">let names = ["Alice", "Bob", "Charlie"]
for name in names {
    say "Hello, {name}"
}
</code></pre>
<h3 id="for-each-variant"><a class="header" href="#for-each-variant">For Each Variant</a></h3>
<p>The <code>for each</code> form is equivalent to <code>for</code>-<code>in</code>:</p>
<pre><code class="language-forge">for each name in names {
    say "Hello, {name}"
}
</code></pre>
<h3 id="iterating-over-arrays"><a class="header" href="#iterating-over-arrays">Iterating Over Arrays</a></h3>
<pre><code class="language-forge">let nums = [10, 20, 30]
for n in nums {
    say n
}
// Output: 10, 20, 30
</code></pre>
<h3 id="iterating-over-objects"><a class="header" href="#iterating-over-objects">Iterating Over Objects</a></h3>
<p>When iterating over an object, the loop variable receives each key:</p>
<pre><code class="language-forge">let user = { name: "Alice", age: 30 }
for key in user {
    say "{key}: {user[key]}"
}
</code></pre>
<h3 id="iterating-with-index"><a class="header" href="#iterating-with-index">Iterating with Index</a></h3>
<p>Use <code>enumerate</code> or a two-variable for loop to access both index and value:</p>
<pre><code class="language-forge">let items = ["a", "b", "c"]
for i, item in items {
    say "{i}: {item}"
}
// Output: 0: a, 1: b, 2: c
</code></pre>
<h3 id="iterating-over-ranges"><a class="header" href="#iterating-over-ranges">Iterating Over Ranges</a></h3>
<p>The <code>range</code> function generates a sequence of integers:</p>
<pre><code class="language-forge">for i in range(0, 5) {
    say i
}
// Output: 0, 1, 2, 3, 4
</code></pre>
<p><code>range(start, end)</code> produces integers from <code>start</code> (inclusive) to <code>end</code> (exclusive).</p>
<h2 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h2>
<p>The <code>while</code> loop executes as long as its condition is truthy.</p>
<pre><code class="language-forge">let mut count = 0
while count &lt; 5 {
    say count
    count += 1
}
// Output: 0, 1, 2, 3, 4
</code></pre>
<p>The condition is evaluated before each iteration. If the condition is falsy on the first check, the body never executes.</p>
<h2 id="loop-infinite"><a class="header" href="#loop-infinite">Loop (Infinite)</a></h2>
<p>The <code>loop</code> keyword creates an infinite loop. Use <code>break</code> to exit.</p>
<pre><code class="language-forge">let mut n = 0
loop {
    if n &gt;= 3 {
        break
    }
    say n
    n += 1
}
// Output: 0, 1, 2
</code></pre>
<h2 id="repeat-n-times"><a class="header" href="#repeat-n-times">Repeat N Times</a></h2>
<p>The <code>repeat</code> loop executes a body a fixed number of times.</p>
<pre><code class="language-forge">repeat 3 times {
    say "hello"
}
// Output: hello, hello, hello
</code></pre>
<p>The count expression is evaluated once before the loop begins. The body executes exactly that many times.</p>
<h2 id="break"><a class="header" href="#break">Break</a></h2>
<p>The <code>break</code> statement exits the innermost enclosing loop immediately.</p>
<pre><code class="language-forge">for i in range(0, 100) {
    if i == 5 {
        break
    }
    say i
}
// Output: 0, 1, 2, 3, 4
</code></pre>
<p><code>break</code> can be used with <code>for</code>, <code>while</code>, <code>loop</code>, and <code>repeat</code>.</p>
<h2 id="continue"><a class="header" href="#continue">Continue</a></h2>
<p>The <code>continue</code> statement skips the rest of the current iteration and proceeds to the next one.</p>
<pre><code class="language-forge">for i in range(0, 5) {
    if i == 2 {
        continue
    }
    say i
}
// Output: 0, 1, 3, 4
</code></pre>
<h2 id="nested-loops"><a class="header" href="#nested-loops">Nested Loops</a></h2>
<p>Loops can be nested. <code>break</code> and <code>continue</code> apply to the innermost loop only.</p>
<pre><code class="language-forge">for i in range(0, 3) {
    for j in range(0, 3) {
        if j == 1 {
            break       // exits inner loop only
        }
        say "{i},{j}"
    }
}
// Output: 0,0  1,0  2,0
</code></pre>
<h2 id="loop-scope"><a class="header" href="#loop-scope">Loop Scope</a></h2>
<p>Variables declared inside a loop body are scoped to each iteration:</p>
<pre><code class="language-forge">for i in range(0, 3) {
    let msg = "iteration {i}"
    say msg
}
// msg is not accessible here
</code></pre>
<p>The loop variable itself (<code>i</code> in <code>for i in ...</code>) is scoped to the loop body.</p>
<h2 id="wait-in-loops"><a class="header" href="#wait-in-loops">Wait in Loops</a></h2>
<p>The <code>wait</code> statement can be used inside loops to introduce delays:</p>
<pre><code class="language-forge">repeat 3 times {
    say "tick"
    wait 1 second
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="function-declaration"><a class="header" href="#function-declaration">Function Declaration</a></h1>
<p>Function declarations introduce named, callable units of code. Forge supports both classic and natural syntax forms.</p>
<h2 id="basic-declaration"><a class="header" href="#basic-declaration">Basic Declaration</a></h2>
<h3 id="classic-syntax-4"><a class="header" href="#classic-syntax-4">Classic Syntax</a></h3>
<pre><code class="language-forge">fn greet(name) {
    say "Hello, {name}!"
}
</code></pre>
<h3 id="natural-syntax-4"><a class="header" href="#natural-syntax-4">Natural Syntax</a></h3>
<pre><code class="language-forge">define greet(name) {
    say "Hello, {name}!"
}
</code></pre>
<p>Both forms are semantically identical. The function is bound to the given name in the current scope.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>Parameters are comma-separated identifiers enclosed in parentheses.</p>
<pre><code class="language-forge">fn add(a, b) {
    a + b
}
say add(3, 4)   // 7
</code></pre>
<h3 id="no-parameters"><a class="header" href="#no-parameters">No Parameters</a></h3>
<p>Functions with no parameters use empty parentheses:</p>
<pre><code class="language-forge">fn hello() {
    say "hello"
}
hello()
</code></pre>
<h3 id="default-parameters"><a class="header" href="#default-parameters">Default Parameters</a></h3>
<p>Parameters can have default values. Default values are used when the caller does not provide an argument for that position.</p>
<pre><code class="language-forge">fn greet(name, greeting = "Hello") {
    say "{greeting}, {name}!"
}
greet("Alice")              // "Hello, Alice!"
greet("Bob", "Hi")          // "Hi, Bob!"
</code></pre>
<p>Default parameters must appear after all required parameters.</p>
<h3 id="variadic-parameters"><a class="header" href="#variadic-parameters">Variadic Parameters</a></h3>
<p>Forge does not support variadic parameters (rest parameters). To accept a variable number of arguments, use an array parameter:</p>
<pre><code class="language-forge">fn sum_all(numbers) {
    reduce(numbers, 0, fn(acc, n) { acc + n })
}
say sum_all([1, 2, 3, 4])  // 10
</code></pre>
<h2 id="return-type-annotation"><a class="header" href="#return-type-annotation">Return Type Annotation</a></h2>
<p>An optional return type annotation may follow the parameter list:</p>
<pre><code class="language-forge">fn square(n: int): int {
    n * n
}
</code></pre>
<p>Type annotations are checked by the type checker when enabled. They do not affect runtime behavior in the interpreter.</p>
<h2 id="return-values-1"><a class="header" href="#return-values-1">Return Values</a></h2>
<h3 id="implicit-return-1"><a class="header" href="#implicit-return-1">Implicit Return</a></h3>
<p>The last expression in a function body is its return value. This is the idiomatic way to return values in Forge.</p>
<pre><code class="language-forge">fn double(x) {
    x * 2
}
say double(5)   // 10
</code></pre>
<h3 id="explicit-return"><a class="header" href="#explicit-return">Explicit Return</a></h3>
<p>The <code>return</code> keyword exits the function immediately with a value:</p>
<pre><code class="language-forge">fn abs(x) {
    if x &lt; 0 {
        return -x
    }
    x
}
</code></pre>
<p>A bare <code>return</code> without a value returns <code>null</code>:</p>
<pre><code class="language-forge">fn log_if_positive(x) {
    if x &lt;= 0 {
        return
    }
    say "positive: {x}"
}
</code></pre>
<p>See <a href="#return-break-continue">Return, Break, Continue</a> for details.</p>
<h2 id="function-scope"><a class="header" href="#function-scope">Function Scope</a></h2>
<p>Functions create a new scope. Variables declared inside a function are not accessible outside it. Functions can access variables from their enclosing scope (closure behavior).</p>
<pre><code class="language-forge">let multiplier = 10

fn scale(x) {
    x * multiplier      // accesses 'multiplier' from outer scope
}
say scale(5)    // 50
</code></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>Functions can call themselves recursively:</p>
<pre><code class="language-forge">fn factorial(n) {
    if n &lt;= 1 { return 1 }
    n * factorial(n - 1)
}
say factorial(5)    // 120
</code></pre>
<pre><code class="language-forge">fn fib(n) {
    if n &lt;= 1 { return n }
    fib(n - 1) + fib(n - 2)
}
say fib(10)     // 55
</code></pre>
<h2 id="async-functions-1"><a class="header" href="#async-functions-1">Async Functions</a></h2>
<p>Async functions are declared with <code>async fn</code> (classic) or <code>forge</code> (natural):</p>
<pre><code class="language-forge">async fn fetch_data(url) {
    let resp = await http.get(url)
    resp.body
}

// Natural syntax
forge fetch_data(url) {
    let resp = hold http.get(url)
    resp.body
}
</code></pre>
<p>Async functions return a future that must be awaited with <code>await</code> / <code>hold</code>. See <a href="#async-functions-2">Async Functions</a>.</p>
<h2 id="nested-functions"><a class="header" href="#nested-functions">Nested Functions</a></h2>
<p>Functions can be declared inside other functions:</p>
<pre><code class="language-forge">fn outer() {
    fn inner() {
        say "inside"
    }
    inner()
}
outer()     // "inside"
</code></pre>
<p>Inner functions have access to the outer function’s scope.</p>
<h2 id="functions-are-values"><a class="header" href="#functions-are-values">Functions Are Values</a></h2>
<p>Function declarations create values that can be stored in variables, passed as arguments, and returned from other functions:</p>
<pre><code class="language-forge">fn add(a, b) { a + b }
fn sub(a, b) { a - b }

let ops = [add, sub]
say ops[0](10, 3)   // 13
say ops[1](10, 3)   // 7
</code></pre>
<h2 id="parameter-type-annotations"><a class="header" href="#parameter-type-annotations">Parameter Type Annotations</a></h2>
<p>Parameters can include optional type annotations:</p>
<pre><code class="language-forge">fn add(a: int, b: int): int {
    a + b
}
</code></pre>
<p>These annotations are informational for the type checker and do not enforce types at runtime in the interpreter.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="return-break-continue"><a class="header" href="#return-break-continue">Return, Break, Continue</a></h1>
<p>Jump statements transfer control to a different point in the program, interrupting the normal top-to-bottom execution flow.</p>
<h2 id="return"><a class="header" href="#return">Return</a></h2>
<p>The <code>return</code> statement exits the current function and optionally provides a return value.</p>
<h3 id="return-with-a-value"><a class="header" href="#return-with-a-value">Return with a Value</a></h3>
<pre><code class="language-forge">fn square(x) {
    return x * x
}
say square(5)   // 25
</code></pre>
<h3 id="return-without-a-value"><a class="header" href="#return-without-a-value">Return without a Value</a></h3>
<p>A bare <code>return</code> returns <code>null</code> from the function:</p>
<pre><code class="language-forge">fn maybe_log(x) {
    if x &lt;= 0 {
        return          // returns null
    }
    say "value: {x}"
}
</code></pre>
<h3 id="implicit-return-2"><a class="header" href="#implicit-return-2">Implicit Return</a></h3>
<p>The last expression in a function body is automatically used as the return value. Explicit <code>return</code> is only needed for early exit.</p>
<pre><code class="language-forge">fn double(x) {
    x * 2           // implicit return
}
say double(5)   // 10
</code></pre>
<p>When using <code>if</code>-<code>else</code> as the last statement, the last expression in the executed branch becomes the return value:</p>
<pre><code class="language-forge">fn abs(x) {
    if x &lt; 0 {
        -x
    } else {
        x
    }
}
say abs(-3)     // 3
</code></pre>
<h3 id="return-in-nested-blocks"><a class="header" href="#return-in-nested-blocks">Return in Nested Blocks</a></h3>
<p><code>return</code> exits the enclosing <strong>function</strong>, not just the current block:</p>
<pre><code class="language-forge">fn find_first_negative(items) {
    for item in items {
        if item &lt; 0 {
            return item     // exits the function, not just the loop
        }
    }
    null
}
say find_first_negative([1, 2, -3, 4])  // -3
</code></pre>
<h3 id="return-from-closures"><a class="header" href="#return-from-closures">Return from Closures</a></h3>
<p>A <code>return</code> inside a closure exits the <strong>closure</strong>, not the outer function:</p>
<pre><code class="language-forge">fn process(items) {
    let results = map(items, fn(x) {
        if x &lt; 0 {
            return 0        // exits the closure, not process()
        }
        x * 2
    })
    results
}
say process([1, -2, 3])    // [2, 0, 6]
</code></pre>
<h2 id="break-1"><a class="header" href="#break-1">Break</a></h2>
<p>The <code>break</code> statement exits the innermost enclosing loop immediately. Execution continues with the first statement after the loop.</p>
<h3 id="break-in-for-loops"><a class="header" href="#break-in-for-loops">Break in For Loops</a></h3>
<pre><code class="language-forge">for i in range(0, 100) {
    if i &gt;= 5 {
        break
    }
    say i
}
// Output: 0, 1, 2, 3, 4
say "done"
</code></pre>
<h3 id="break-in-while-loops"><a class="header" href="#break-in-while-loops">Break in While Loops</a></h3>
<pre><code class="language-forge">let mut n = 0
while true {
    if n &gt;= 3 {
        break
    }
    say n
    n += 1
}
// Output: 0, 1, 2
</code></pre>
<h3 id="break-in-loop"><a class="header" href="#break-in-loop">Break in Loop</a></h3>
<p>The <code>break</code> statement is the only way to exit a <code>loop</code> (infinite loop):</p>
<pre><code class="language-forge">let mut count = 0
loop {
    count += 1
    if count &gt; 5 {
        break
    }
}
say count   // 6
</code></pre>
<h3 id="break-in-nested-loops"><a class="header" href="#break-in-nested-loops">Break in Nested Loops</a></h3>
<p><code>break</code> only exits the innermost loop:</p>
<pre><code class="language-forge">for i in range(0, 3) {
    for j in range(0, 10) {
        if j &gt;= 2 {
            break       // exits inner loop only
        }
        say "{i},{j}"
    }
    // continues with next i
}
</code></pre>
<h3 id="break-outside-a-loop"><a class="header" href="#break-outside-a-loop">Break Outside a Loop</a></h3>
<p>Using <code>break</code> outside of a loop produces a runtime error.</p>
<h2 id="continue-1"><a class="header" href="#continue-1">Continue</a></h2>
<p>The <code>continue</code> statement skips the rest of the current loop iteration and proceeds to the next iteration.</p>
<h3 id="continue-in-for-loops"><a class="header" href="#continue-in-for-loops">Continue in For Loops</a></h3>
<pre><code class="language-forge">for i in range(0, 5) {
    if i == 2 {
        continue        // skip i == 2
    }
    say i
}
// Output: 0, 1, 3, 4
</code></pre>
<h3 id="continue-in-while-loops"><a class="header" href="#continue-in-while-loops">Continue in While Loops</a></h3>
<pre><code class="language-forge">let mut i = 0
while i &lt; 5 {
    i += 1
    if i % 2 == 0 {
        continue        // skip even numbers
    }
    say i
}
// Output: 1, 3, 5
</code></pre>
<h3 id="continue-in-nested-loops"><a class="header" href="#continue-in-nested-loops">Continue in Nested Loops</a></h3>
<p>Like <code>break</code>, <code>continue</code> applies to the innermost loop:</p>
<pre><code class="language-forge">for i in range(0, 3) {
    for j in range(0, 3) {
        if j == 1 {
            continue    // skips j == 1 in inner loop
        }
        say "{i},{j}"
    }
}
// Output: 0,0  0,2  1,0  1,2  2,0  2,2
</code></pre>
<h3 id="continue-outside-a-loop"><a class="header" href="#continue-outside-a-loop">Continue Outside a Loop</a></h3>
<p>Using <code>continue</code> outside of a loop produces a runtime error.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Statement</th><th>Context</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><code>return expr</code></td><td>Function</td><td>Exit function, return <code>expr</code></td></tr>
<tr><td><code>return</code></td><td>Function</td><td>Exit function, return <code>null</code></td></tr>
<tr><td><code>break</code></td><td>Loop</td><td>Exit innermost loop</td></tr>
<tr><td><code>continue</code></td><td>Loop</td><td>Skip to next iteration of innermost loop</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="import-and-export"><a class="header" href="#import-and-export">Import and Export</a></h1>
<p>The <code>import</code> statement loads definitions from external Forge source files or references built-in modules.</p>
<h2 id="importing-files"><a class="header" href="#importing-files">Importing Files</a></h2>
<p>To import all top-level definitions from another Forge source file:</p>
<pre><code class="language-forge">import "utils.fg"
</code></pre>
<p>The import path is a string literal specifying the file to load. The interpreter resolves the path relative to the current working directory and checks the following locations in order:</p>
<ol>
<li><code>{path}</code> – the exact path as given</li>
<li><code>{path}.fg</code> – with the <code>.fg</code> extension appended</li>
<li><code>forge_modules/{path}/main.fg</code> – in the <code>forge_modules</code> directory</li>
</ol>
<p>If no file is found at any of these locations, a runtime error is produced.</p>
<h2 id="import-semantics"><a class="header" href="#import-semantics">Import Semantics</a></h2>
<p>When a file is imported, the following steps occur:</p>
<ol>
<li>The source file is read and parsed.</li>
<li>A <strong>new interpreter instance</strong> is created.</li>
<li>The imported file is executed in the new interpreter.</li>
<li>Top-level definitions (<code>fn</code> and <code>let</code> bindings) are copied into the importing file’s scope.</li>
</ol>
<p>Importantly, each import creates a fresh interpreter. Side effects in the imported file (such as printing) occur during import. The imported file does not share mutable state with the importing file.</p>
<pre><code class="language-forge">// utils.fg
fn double(x) { x * 2 }
fn triple(x) { x * 3 }
let PI = 3.14159
</code></pre>
<pre><code class="language-forge">// main.fg
import "utils.fg"
say double(5)       // 10
say triple(5)       // 15
say PI              // 3.14159
</code></pre>
<h2 id="selective-imports"><a class="header" href="#selective-imports">Selective Imports</a></h2>
<p>To import specific names from a file, list them after the path:</p>
<pre><code class="language-forge">import { double, PI } from "utils.fg"
say double(5)       // 10
say PI              // 3.14159
// triple is NOT imported
</code></pre>
<p>Only the listed names are copied into the current scope.</p>
<h2 id="built-in-modules"><a class="header" href="#built-in-modules">Built-in Modules</a></h2>
<p>Forge’s standard library modules (<code>math</code>, <code>fs</code>, <code>io</code>, <code>crypto</code>, <code>db</code>, <code>pg</code>, <code>env</code>, <code>json</code>, <code>regex</code>, <code>log</code>, <code>term</code>, <code>http</code>, <code>csv</code>, <code>exec</code>, <code>time</code>) are automatically available without import. Attempting to <code>import</code> a built-in module name produces an error with guidance:</p>
<pre><code class="language-forge">import "math"
// Error: 'math' is a built-in module — it's already available. Use it directly: math.function()
</code></pre>
<p>Built-in modules are accessed via dot notation:</p>
<pre><code class="language-forge">say math.sqrt(16)       // 4.0
say math.pi             // 3.141592653589793
let data = fs.read("file.txt")
</code></pre>
<h2 id="module-level-execution"><a class="header" href="#module-level-execution">Module-Level Execution</a></h2>
<p>When a file is imported, all of its top-level statements execute. This includes not just declarations but also expression statements and side effects:</p>
<pre><code class="language-forge">// setup.fg
say "setting up..."         // prints during import
let config = { debug: true }

fn get_config() { config }
</code></pre>
<pre><code class="language-forge">// main.fg
import "setup.fg"           // prints "setting up..."
let c = get_config()
say c.debug                 // true
</code></pre>
<h2 id="circular-imports"><a class="header" href="#circular-imports">Circular Imports</a></h2>
<p>Forge does not detect or prevent circular imports. A circular import chain will cause infinite recursion and a stack overflow. It is the programmer’s responsibility to avoid circular dependencies.</p>
<h2 id="no-namespacing"><a class="header" href="#no-namespacing">No Namespacing</a></h2>
<p>Imported definitions are placed directly into the importing file’s scope. There is no namespace or module prefix for file imports. If two imported files define the same name, the later import overwrites the earlier one.</p>
<pre><code class="language-forge">import "a.fg"       // defines fn helper()
import "b.fg"       // also defines fn helper() -- overwrites a.fg's version
</code></pre>
<h2 id="no-export-keyword"><a class="header" href="#no-export-keyword">No Export Keyword</a></h2>
<p>Forge does not have an explicit <code>export</code> keyword. All top-level <code>fn</code> and <code>let</code> bindings in a file are automatically available for import by other files.</p>
<h2 id="re-imports"><a class="header" href="#re-imports">Re-Imports</a></h2>
<p>Importing the same file multiple times re-executes it each time. There is no import caching or module singleton behavior for file imports.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-system"><a class="header" href="#type-system">Type System</a></h1>
<p>This chapter defines the type system of Forge. Forge is dynamically typed at runtime but provides structural mechanisms for organizing data and behavior: struct definitions, method attachment, interface contracts, composition via embedding, and structural satisfaction checking.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Forge’s type system is built on five pillars:</p>
<ol>
<li><strong>Struct definitions</strong> (<code>thing</code>/<code>struct</code>) — Define named record types with typed fields and optional defaults.</li>
<li><strong>Method blocks</strong> (<code>give</code>/<code>impl</code>) — Attach instance and static methods to struct types after definition.</li>
<li><strong>Interface contracts</strong> (<code>power</code>/<code>interface</code>) — Declare behavioral contracts that types may fulfill.</li>
<li><strong>Composition</strong> (<code>has</code>) — Embed one struct inside another with automatic field and method delegation.</li>
<li><strong>Structural satisfaction</strong> (<code>satisfies</code>) — Test whether a value’s type fulfills an interface at runtime, regardless of explicit declaration.</li>
</ol>
<h2 id="dynamic-foundation"><a class="header" href="#dynamic-foundation">Dynamic Foundation</a></h2>
<p>All Forge values are represented at runtime by the <code>Value</code> enum. There is no compile-time type erasure or monomorphization. Type annotations on struct fields and function parameters are documentation and future-proofing; the interpreter does not enforce them at assignment time in the current version.</p>
<p>The <code>typeof</code> builtin returns a string naming the runtime type:</p>
<pre><code class="language-forge">typeof(42)        // "Int"
typeof("hello")   // "String"
typeof(true)      // "Bool"
typeof(null)      // "Null"
typeof([1, 2])    // "Array"
typeof({a: 1})    // "Object"
</code></pre>
<p>Struct instances are <code>Object</code> values with a <code>__type__</code> field that records the struct name.</p>
<h2 id="type-identity"><a class="header" href="#type-identity">Type Identity</a></h2>
<p>Every struct instance carries a <code>__type__</code> field set to the struct’s name as a string. This field is automatically inserted during construction and is used by the runtime for method dispatch, interface satisfaction checking, and embedded-field delegation.</p>
<pre><code class="language-forge">thing Point { x: Int, y: Int }
let p = Point { x: 1, y: 2 }
p.__type__    // "Point"
typeof(p)     // "Object"
</code></pre>
<p>The <code>typeof</code> builtin returns <code>"Object"</code> for all struct instances. The <code>__type__</code> field distinguishes between different struct types at a finer granularity.</p>
<h2 id="no-generics"><a class="header" href="#no-generics">No Generics</a></h2>
<p>Forge does not currently support generic types or parameterized type constructors. All collections (arrays, objects) are heterogeneous. Interface methods are checked by name and arity, not by parameter types.</p>
<h2 id="subsections-2"><a class="header" href="#subsections-2">Subsections</a></h2>
<p>The following subsections define each type system feature in detail:</p>
<ul>
<li><a href="#struct-definitions">Struct Definitions</a> — Defining named record types.</li>
<li><a href="#method-blocks">Method Blocks</a> — Attaching methods to types.</li>
<li><a href="#interface-contracts">Interface Contracts</a> — Declaring and implementing behavioral contracts.</li>
<li><a href="#composition">Composition</a> — Embedding types and delegation.</li>
<li><a href="#structural-satisfaction">Structural Satisfaction</a> — Runtime interface checking.</li>
<li><a href="#default-values-2">Default Values</a> — Default field values in struct definitions.</li>
<li><a href="#static-methods-2">Static Methods</a> — Type-level methods without a receiver.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="struct-definitions"><a class="header" href="#struct-definitions">Struct Definitions</a></h1>
<p>Structs are named record types that group related fields into a single value. Forge provides dual syntax for defining structs: <code>thing</code> (natural) and <code>struct</code> (classic).</p>
<h2 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h2>
<pre><code>StructDef       = ("thing" | "struct") Identifier "{" FieldList "}"
FieldList       = Field ("," Field)* ","?
Field           = EmbedField | PlainField
PlainField      = Identifier (":" TypeAnnotation)? ("=" Expression)?
EmbedField      = "has" Identifier ":" TypeAnnotation
TypeAnnotation  = Identifier
</code></pre>
<h2 id="defining-a-struct"><a class="header" href="#defining-a-struct">Defining a Struct</a></h2>
<p>The <code>thing</code> keyword (or its classic alias <code>struct</code>) introduces a new struct type. The struct name must be a valid identifier and by convention uses PascalCase.</p>
<pre><code class="language-forge">thing Person {
    name: String,
    age: Int
}
</code></pre>
<p>Classic syntax:</p>
<pre><code class="language-forge">struct Person {
    name: String,
    age: Int
}
</code></pre>
<p>Both forms are semantically identical. The parser produces the same <code>StructDef</code> AST node regardless of which keyword is used.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>Each field has a name and an optional type annotation. Type annotations follow the field name after a colon. In the current implementation, type annotations are parsed and stored but not enforced at runtime.</p>
<pre><code class="language-forge">thing Config {
    host: String,
    port: Int,
    debug: Bool
}
</code></pre>
<p>Fields without type annotations are permitted:</p>
<pre><code class="language-forge">thing Pair {
    first,
    second
}
</code></pre>
<h2 id="default-values-1"><a class="header" href="#default-values-1">Default Values</a></h2>
<p>Fields may specify a default value using <code>=</code> after the type annotation (or after the field name if no annotation is present). See <a href="#default-values-2">Default Values</a> for full details.</p>
<pre><code class="language-forge">thing Config {
    host: String = "localhost",
    port: Int = 8080,
    debug: Bool = false
}
</code></pre>
<h2 id="construction-3"><a class="header" href="#construction-3">Construction</a></h2>
<p>Struct instances are created using the struct name followed by a field initializer block. The result is an <code>Object</code> value with the specified fields plus an automatically inserted <code>__type__</code> field.</p>
<pre><code class="language-forge">thing Point { x: Int, y: Int }

let p = Point { x: 10, y: 20 }
// p is { __type__: "Point", x: 10, y: 20 }
</code></pre>
<p>Fields may be provided in any order. Fields with default values may be omitted; default values are applied first, then explicitly provided fields override them.</p>
<pre><code class="language-forge">thing Config {
    host: String = "localhost",
    port: Int = 8080
}

let c = Config { port: 3000 }
// c is { __type__: "Config", host: "localhost", port: 3000 }
</code></pre>
<h2 id="the-__type__-field-1"><a class="header" href="#the-__type__-field-1">The <code>__type__</code> Field</a></h2>
<p>Every struct instance automatically receives a <code>__type__</code> field set to the struct’s name as a <code>String</code> value. This field is inserted after all user-specified fields during construction. It is used by the runtime for:</p>
<ul>
<li>Method dispatch in <code>give</code>/<code>impl</code> blocks</li>
<li>Interface satisfaction checking in <code>satisfies</code></li>
<li>Embedded field delegation via <code>has</code></li>
</ul>
<p>The <code>__type__</code> field is a regular field and can be read like any other:</p>
<pre><code class="language-forge">thing Dog { name: String }
let d = Dog { name: "Rex" }
say d.__type__    // "Dog"
</code></pre>
<p>Manually setting <code>__type__</code> in the constructor is permitted but will be overwritten by the automatic insertion.</p>
<h2 id="registration"><a class="header" href="#registration">Registration</a></h2>
<p>When a <code>StructDef</code> statement is executed, the interpreter:</p>
<ol>
<li>Registers the struct name in the environment as a <code>BuiltIn("struct:Name")</code> sentinel value. This value is used to identify static method calls (<code>Name.method()</code>).</li>
<li>Records any embedded fields in the <code>embedded_fields</code> table for delegation.</li>
<li>Records any default values in the <code>struct_defaults</code> table, evaluating default expressions at definition time.</li>
</ol>
<p>The struct name can subsequently be used as a constructor in <code>StructInit</code> expressions.</p>
<h2 id="field-access-3"><a class="header" href="#field-access-3">Field Access</a></h2>
<p>Fields are accessed using dot notation:</p>
<pre><code class="language-forge">thing Person { name: String, age: Int }
let p = Person { name: "Alice", age: 30 }

say p.name    // "Alice"
say p.age     // 30
</code></pre>
<p>If the field does not exist on the object directly, the runtime checks embedded sub-objects before reporting an error. See <a href="#composition">Composition</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="method-blocks"><a class="header" href="#method-blocks">Method Blocks</a></h1>
<p>Method blocks attach functions to a struct type after its definition. Forge provides dual syntax: <code>give</code> (natural) and <code>impl</code> (classic). Methods are stored in the interpreter’s method tables and dispatched based on the instance’s <code>__type__</code> field.</p>
<h2 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h2>
<pre><code>MethodBlock      = GiveBlock | ImplBlock
GiveBlock        = "give" TypeName AbilityClause? "{" MethodDef* "}"
ImplBlock        = "impl" (TypeName | AbilityForType) "{" MethodDef* "}"
AbilityClause    = "the" "power" InterfaceName
AbilityForType   = InterfaceName "for" TypeName
MethodDef        = ("fn" | "define") Identifier "(" ParamList ")" Block
TypeName         = Identifier
InterfaceName    = Identifier
</code></pre>
<h2 id="instance-methods"><a class="header" href="#instance-methods">Instance Methods</a></h2>
<p>An instance method is a method whose first parameter is named <code>it</code>. The <code>it</code> parameter receives the struct instance on which the method is called — it is Forge’s equivalent of <code>self</code> or <code>this</code> in other languages.</p>
<pre><code class="language-forge">thing Person {
    name: String,
    age: Int
}

give Person {
    define greet(it) {
        say "Hello, I'm " + it.name
    }

    define birthday(it) {
        return it.age + 1
    }
}
</code></pre>
<p>Classic syntax:</p>
<pre><code class="language-forge">impl Person {
    fn greet(it) {
        say "Hello, I'm " + it.name
    }
}
</code></pre>
<p>Both <code>give</code> and <code>impl</code> are semantically identical. The parser produces the same <code>ImplBlock</code> AST node.</p>
<h2 id="method-invocation"><a class="header" href="#method-invocation">Method Invocation</a></h2>
<p>Instance methods are called using dot notation on a struct instance. The runtime automatically passes the instance as the <code>it</code> argument:</p>
<pre><code class="language-forge">let p = Person { name: "Alice", age: 30 }
p.greet()       // prints "Hello, I'm Alice"
p.birthday()    // returns 31
</code></pre>
<p>When the interpreter encounters <code>p.greet()</code>, it:</p>
<ol>
<li>Evaluates <code>p</code> to get the receiver object.</li>
<li>Reads <code>p.__type__</code> to get the type name (<code>"Person"</code>).</li>
<li>Looks up <code>"greet"</code> in <code>method_tables["Person"]</code>.</li>
<li>Prepends <code>p</code> to the argument list as the <code>it</code> parameter.</li>
<li>Calls the resolved function with the full argument list.</li>
</ol>
<h2 id="static-methods-1"><a class="header" href="#static-methods-1">Static Methods</a></h2>
<p>A method without <code>it</code> as its first parameter is a static method. Static methods are called on the type name itself, not on instances. See <a href="#static-methods-2">Static Methods</a> for full details.</p>
<pre><code class="language-forge">give Person {
    define species() {
        return "Homo sapiens"
    }
}

Person.species()    // "Homo sapiens"
</code></pre>
<h2 id="additive-blocks"><a class="header" href="#additive-blocks">Additive Blocks</a></h2>
<p>Multiple <code>give</code>/<code>impl</code> blocks for the same type are additive. Each block adds its methods to the existing method table without removing previously defined methods.</p>
<pre><code class="language-forge">thing Car {
    make: String
}

give Car {
    define brand(it) {
        return it.make
    }
}

give Car {
    define honk(it) {
        say "Beep!"
    }
}

let c = Car { make: "Toyota" }
c.brand()    // "Toyota"
c.honk()     // prints "Beep!"
</code></pre>
<p>If a later block defines a method with the same name as an existing method, the later definition overwrites the earlier one in the method table.</p>
<h2 id="method-table-storage"><a class="header" href="#method-table-storage">Method Table Storage</a></h2>
<p>The interpreter maintains two <code>HashMap</code> tables:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Table</th><th>Key</th><th>Value</th><th>Lookup</th></tr>
</thead>
<tbody>
<tr><td><code>method_tables</code></td><td>Type name</td><td><code>IndexMap&lt;String, Value&gt;</code></td><td>Instance method dispatch</td></tr>
<tr><td><code>static_methods</code></td><td>Type name</td><td><code>IndexMap&lt;String, Value&gt;</code></td><td>Static method dispatch</td></tr>
</tbody>
</table>
</div>
<p>When a <code>give</code>/<code>impl</code> block is executed, each method is inserted into <code>method_tables</code> under the type name. Methods without an <code>it</code> parameter are additionally inserted into <code>static_methods</code>.</p>
<h2 id="method-resolution-order"><a class="header" href="#method-resolution-order">Method Resolution Order</a></h2>
<p>When resolving <code>obj.method(args)</code> on a typed object:</p>
<ol>
<li><strong>Direct field</strong> — If the object has a field named <code>method</code> that is callable, it is invoked.</li>
<li><strong>Method table</strong> — The runtime looks up <code>method_tables[obj.__type__][method]</code>.</li>
<li><strong>Embedded delegation</strong> — If not found, the runtime checks each embedded field’s type for the method in <code>method_tables</code>. See <a href="#composition">Composition</a>.</li>
<li><strong>Known builtins</strong> — Certain method names (e.g., <code>map</code>, <code>filter</code>, <code>push</code>) are recognized as builtin functions and dispatched accordingly.</li>
<li><strong>Error</strong> — If no match is found, a runtime error is raised: <code>no method 'method' on TypeName</code>.</li>
</ol>
<h2 id="mixed-syntax"><a class="header" href="#mixed-syntax">Mixed Syntax</a></h2>
<p>Natural (<code>define</code>) and classic (<code>fn</code>) function syntax may be used interchangeably within <code>give</code> and <code>impl</code> blocks:</p>
<pre><code class="language-forge">give Greeter {
    define hello(it) {
        say "hi from " + it.name
    }

    fn goodbye(it) {
        say "bye from " + it.name
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="interface-contracts"><a class="header" href="#interface-contracts">Interface Contracts</a></h1>
<p>Interfaces define behavioral contracts — a set of method signatures that a type must implement. Forge provides dual syntax: <code>power</code> (natural) and <code>interface</code> (classic). Implementing an interface is verified at definition time when the <code>give...the power</code> or <code>impl...for</code> block is executed.</p>
<h2 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h2>
<pre><code>InterfaceDef     = ("power" | "interface") Identifier "{" MethodSig* "}"
MethodSig        = ("fn" | "define") Identifier "(" ParamList ")" ("-&gt;" TypeAnnotation)?
ImplInterface    = "give" TypeName "the" "power" InterfaceName "{" MethodDef* "}"
                 | "impl" InterfaceName "for" TypeName "{" MethodDef* "}"
</code></pre>
<h2 id="defining-an-interface"><a class="header" href="#defining-an-interface">Defining an Interface</a></h2>
<p>The <code>power</code> keyword (or its classic alias <code>interface</code>) introduces a named interface. An interface body contains method signatures — method names with parameter lists and optional return type annotations.</p>
<pre><code class="language-forge">power Greetable {
    fn greet(it) -&gt; String
}
</code></pre>
<p>Classic syntax:</p>
<pre><code class="language-forge">interface Greetable {
    fn greet(it) -&gt; String
}
</code></pre>
<p>Both forms produce the same <code>InterfaceDef</code> AST node.</p>
<h2 id="interface-registration"><a class="header" href="#interface-registration">Interface Registration</a></h2>
<p>When an <code>InterfaceDef</code> statement is executed, the interpreter:</p>
<ol>
<li>Builds an array of method specification objects. Each object contains:
<ul>
<li><code>name</code> — the method name as a <code>String</code>.</li>
<li><code>param_count</code> — the number of parameters as an <code>Int</code>.</li>
<li><code>return_type</code> — the return type annotation as a <code>String</code>, if present.</li>
</ul>
</li>
<li>Creates an interface metadata object with fields <code>__kind__: "interface"</code>, <code>name</code>, and <code>methods</code>.</li>
<li>Registers the interface in the environment under both its name and <code>__interface_Name__</code>.</li>
</ol>
<p>The interface object is a regular <code>Object</code> value and can be passed to functions like <code>satisfies</code>.</p>
<h2 id="implementing-an-interface-1"><a class="header" href="#implementing-an-interface-1">Implementing an Interface</a></h2>
<p>To declare that a type fulfills an interface, use <code>give...the power</code> (natural) or <code>impl...for</code> (classic):</p>
<pre><code class="language-forge">thing Cat {
    name: String
}

power Greetable {
    fn greet(it) -&gt; String
}

give Cat the power Greetable {
    define greet(it) {
        return "Meow, I'm " + it.name
    }
}
</code></pre>
<p>Classic syntax:</p>
<pre><code class="language-forge">interface Named {
    fn get_name(it) -&gt; String
}

impl Named for Animal {
    fn get_name(it) {
        return it.name
    }
}
</code></pre>
<h2 id="validation-at-definition-time"><a class="header" href="#validation-at-definition-time">Validation at Definition Time</a></h2>
<p>When a <code>give...the power</code> or <code>impl...for</code> block is executed, the runtime validates that every method required by the interface is present in the type’s method table (including methods added by the current block and any previous <code>give</code>/<code>impl</code> blocks).</p>
<p>The validation checks method presence by name. It does not verify parameter counts, parameter types, or return types.</p>
<p>If a required method is missing, a runtime error is raised:</p>
<pre><code>'Cat' does not implement 'greet' required by power 'Greetable'
</code></pre>
<p>This error occurs at the point where the <code>give...the power</code> block is executed, not at a later call site.</p>
<h2 id="interface-without-explicit-implementation"><a class="header" href="#interface-without-explicit-implementation">Interface Without Explicit Implementation</a></h2>
<p>A type may satisfy an interface without ever using <code>give...the power</code> or <code>impl...for</code>. Forge supports Go-style structural typing through the <code>satisfies</code> function. See <a href="#structural-satisfaction">Structural Satisfaction</a>.</p>
<p>The <code>give...the power</code> syntax provides two benefits over implicit satisfaction:</p>
<ol>
<li><strong>Early validation</strong> — Errors are reported at the implementation site rather than at a distant call site.</li>
<li><strong>Documentation</strong> — The code explicitly declares the relationship between a type and an interface.</li>
</ol>
<h2 id="multiple-interfaces-1"><a class="header" href="#multiple-interfaces-1">Multiple Interfaces</a></h2>
<p>A type may implement multiple interfaces through separate <code>give...the power</code> blocks:</p>
<pre><code class="language-forge">power Speakable {
    fn speak(it) -&gt; String
}

power Trainable {
    fn train(it, command: String)
    fn obey(it, command: String) -&gt; Bool
}

thing Dog {
    name: String
}

give Dog the power Speakable {
    define speak(it) {
        return "Woof!"
    }
}

give Dog the power Trainable {
    define train(it, command) {
        say it.name + " is learning " + command
    }

    define obey(it, command) {
        return true
    }
}
</code></pre>
<p>Each <code>give...the power</code> block independently validates that its interface’s requirements are met. Methods from earlier blocks (including plain <code>give</code> blocks without an interface) count toward satisfaction.</p>
<h2 id="return-type-annotations"><a class="header" href="#return-type-annotations">Return Type Annotations</a></h2>
<p>Return type annotations in interface method signatures are stored in the interface metadata but are not enforced at runtime. They serve as documentation:</p>
<pre><code class="language-forge">power Hashable {
    fn hash(it) -&gt; String
}
</code></pre>
<p>The <code>-&gt; String</code> annotation is recorded in the method specification but the runtime does not check that <code>hash</code> actually returns a <code>String</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="composition"><a class="header" href="#composition">Composition</a></h1>
<p>Forge supports struct composition through the <code>has</code> keyword, which embeds one struct inside another. Embedded fields enable automatic delegation of both field access and method calls to the inner struct, providing a composition-based alternative to inheritance.</p>
<h2 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h2>
<pre><code>EmbedField = "has" Identifier ":" TypeAnnotation
</code></pre>
<p>The <code>has</code> keyword appears in a struct field position and marks the field as embedded.</p>
<h2 id="defining-embedded-fields"><a class="header" href="#defining-embedded-fields">Defining Embedded Fields</a></h2>
<p>Use <code>has</code> inside a struct definition to embed another type:</p>
<pre><code class="language-forge">thing Address {
    street: String,
    city: String,
    zip: String
}

thing Employee {
    name: String,
    has addr: Address
}
</code></pre>
<p>The <code>addr</code> field is an embedded field of type <code>Address</code>. The <code>has</code> keyword tells the runtime to register this field for delegation.</p>
<h2 id="construction-4"><a class="header" href="#construction-4">Construction</a></h2>
<p>Embedded fields are initialized like regular fields during construction:</p>
<pre><code class="language-forge">let emp = Employee {
    name: "Alice",
    addr: Address {
        street: "123 Main St",
        city: "Springfield",
        zip: "62701"
    }
}
</code></pre>
<h2 id="field-delegation"><a class="header" href="#field-delegation">Field Delegation</a></h2>
<p>When a field is accessed on a struct instance and the field is not found directly on the object, the runtime checks each embedded sub-object for the field. This enables transparent access to inner fields:</p>
<pre><code class="language-forge">// Direct access (always works)
emp.addr.city      // "Springfield"

// Delegated access (through embedding)
emp.city           // "Springfield"
emp.street         // "123 Main St"
</code></pre>
<p>The delegation algorithm for <code>obj.field</code>:</p>
<ol>
<li>Check if <code>obj</code> has a direct field named <code>field</code>. If found, return it.</li>
<li>Read <code>obj.__type__</code> to get the type name.</li>
<li>Look up the type name in <code>embedded_fields</code> to get the list of <code>(field_name, type_name)</code> pairs.</li>
<li>For each embedded field, check if <code>obj[field_name]</code> is an object with the requested <code>field</code>. If found, return it.</li>
<li>If no embedded field contains the requested field, raise a runtime error.</li>
</ol>
<h2 id="method-delegation"><a class="header" href="#method-delegation">Method Delegation</a></h2>
<p>Method calls are also delegated to embedded types. If a method is not found in the outer type’s method table, the runtime searches each embedded type’s method table:</p>
<pre><code class="language-forge">give Address {
    define full(it) {
        return it.street + ", " + it.city + " " + it.zip
    }
}

// Called on the embedded Address through Employee
emp.full()         // "123 Main St, Springfield 62701"

// Explicit path also works
emp.addr.full()    // "123 Main St, Springfield 62701"
</code></pre>
<p>The method delegation algorithm for <code>obj.method(args)</code>:</p>
<ol>
<li>Look up <code>method</code> in <code>method_tables[obj.__type__]</code>. If found, call it with <code>obj</code> prepended as <code>it</code>.</li>
<li>Look up <code>embedded_fields[obj.__type__]</code> to get the list of embedded fields.</li>
<li>For each <code>(embed_field, embed_type)</code> pair, look up <code>method</code> in <code>method_tables[embed_type]</code>.</li>
<li>If found, extract <code>obj[embed_field]</code> as the receiver and call the method with the sub-object as <code>it</code>.</li>
<li>If no embedded type has the method, continue to builtin resolution or raise an error.</li>
</ol>
<h2 id="multiple-embeddings"><a class="header" href="#multiple-embeddings">Multiple Embeddings</a></h2>
<p>A struct may embed multiple fields:</p>
<pre><code class="language-forge">thing Engine {
    horsepower: Int
}

thing Chassis {
    material: String
}

thing Car {
    make: String,
    has engine: Engine,
    has chassis: Chassis
}

give Engine {
    define rev(it) {
        say "Vroom! " + str(it.horsepower) + "hp"
    }
}

give Chassis {
    define describe(it) {
        return it.material + " chassis"
    }
}

let c = Car {
    make: "Toyota",
    engine: Engine { horsepower: 200 },
    chassis: Chassis { material: "Steel" }
}

c.rev()          // prints "Vroom! 200hp"
c.describe()     // "Steel chassis"
c.horsepower     // 200
c.material       // "Steel"
</code></pre>
<p>Embedded fields are searched in declaration order. If two embedded types provide the same field name, the first match wins.</p>
<h2 id="embedding-and-interfaces"><a class="header" href="#embedding-and-interfaces">Embedding and Interfaces</a></h2>
<p>Delegated methods count toward interface satisfaction. If an embedded type’s method table contains a method required by an interface, the outer type satisfies that interface through delegation:</p>
<pre><code class="language-forge">power Describable {
    fn describe(it) -&gt; String
}

// Car satisfies Describable through its embedded Chassis
satisfies(c, Describable)    // true (via chassis.describe)
</code></pre>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>The interpreter maintains an <code>embedded_fields</code> table:</p>
<pre><code>embedded_fields: HashMap&lt;String, Vec&lt;(String, String)&gt;&gt;
</code></pre>
<p>The key is the outer struct name. The value is a vector of <code>(field_name, type_name)</code> pairs, one for each <code>has</code> field in the struct definition. This table is populated when the <code>StructDef</code> statement is executed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="structural-satisfaction"><a class="header" href="#structural-satisfaction">Structural Satisfaction</a></h1>
<p>The <code>satisfies</code> function tests whether a value’s type fulfills an interface’s requirements at runtime, without requiring an explicit <code>give...the power</code> or <code>impl...for</code> declaration. This is Forge’s implementation of Go-style structural typing: if a type has the right methods, it satisfies the interface.</p>
<h2 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h2>
<pre><code>satisfies(value, InterfaceObject) -&gt; Bool
</code></pre>
<p>The <code>satisfies</code> function is a builtin that takes two arguments:</p>
<ol>
<li><strong>value</strong> — Any value, typically a struct instance (an object with a <code>__type__</code> field).</li>
<li><strong>InterfaceObject</strong> — An interface value (an object with <code>__kind__: "interface"</code> and a <code>methods</code> array).</li>
</ol>
<p>It returns <code>true</code> if the value’s type has all methods required by the interface, <code>false</code> otherwise.</p>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<pre><code class="language-forge">thing Robot {
    name: String
}

power Speakable {
    fn speak(it) -&gt; String
}

give Robot {
    define speak(it) {
        return "Beep boop, I am " + it.name
    }
}

let r = Robot { name: "R2D2" }
satisfies(r, Speakable)    // true
</code></pre>
<p>Note that <code>Robot</code> never explicitly declared <code>give Robot the power Speakable</code>. The <code>satisfies</code> check passes because <code>Robot</code> has a <code>speak</code> method in its method table.</p>
<h2 id="resolution-algorithm"><a class="header" href="#resolution-algorithm">Resolution Algorithm</a></h2>
<p>The <code>satisfies</code> function checks interface satisfaction in two phases:</p>
<h3 id="phase-1-structural-check"><a class="header" href="#phase-1-structural-check">Phase 1: Structural Check</a></h3>
<p>First, <code>satisfies</code> performs a structural check on the value itself. It examines whether the value (or the object’s fields) contains callable values matching each required method name. This handles objects that carry their methods as fields.</p>
<h3 id="phase-2-method-table-check"><a class="header" href="#phase-2-method-table-check">Phase 2: Method Table Check</a></h3>
<p>If the structural check fails and the value is an object with a <code>__type__</code> field, <code>satisfies</code> looks up the type name in the interpreter’s <code>method_tables</code>. For each method required by the interface, it checks whether the method table contains an entry with that name.</p>
<pre><code class="language-forge">thing Printer {}

give Printer {
    define print_line(it, text) {
        say text
    }
}

power Printable {
    fn print_line(it, text: String)
}

let p = Printer {}
satisfies(p, Printable)    // true (found in method_tables)
</code></pre>
<h3 id="satisfaction-criteria"><a class="header" href="#satisfaction-criteria">Satisfaction Criteria</a></h3>
<p>The check verifies method presence by <strong>name only</strong>. It does not verify:</p>
<ul>
<li>Parameter count or parameter types</li>
<li>Return types</li>
<li>Method body or behavior</li>
</ul>
<p>A type satisfies an interface if and only if every method name listed in the interface’s <code>methods</code> array has a corresponding entry in the type’s method table.</p>
<h2 id="explicit-vs-structural"><a class="header" href="#explicit-vs-structural">Explicit vs. Structural</a></h2>
<p>Forge supports both explicit and structural interface satisfaction:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Syntax</th><th>When Checked</th></tr>
</thead>
<tbody>
<tr><td>Explicit</td><td><code>give T the power I { ... }</code></td><td>At definition time</td></tr>
<tr><td>Structural</td><td><code>satisfies(value, I)</code></td><td>At call time</td></tr>
</tbody>
</table>
</div>
<p>Explicit implementation triggers immediate validation and produces clear error messages at the definition site. Structural satisfaction is more flexible but defers errors to the point where <code>satisfies</code> is called.</p>
<p>Both approaches can coexist. A type that explicitly implements an interface will also pass <code>satisfies</code> checks.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="satisfied-without-explicit-declaration"><a class="header" href="#satisfied-without-explicit-declaration">Satisfied Without Explicit Declaration</a></h3>
<pre><code class="language-forge">thing Duck {
    name: String
}

power Quackable {
    fn quack(it) -&gt; String
}

give Duck {
    define quack(it) {
        return it.name + " says quack!"
    }
}

let d = Duck { name: "Donald" }
satisfies(d, Quackable)    // true — Duck has quack()
</code></pre>
<h3 id="not-satisfied"><a class="header" href="#not-satisfied">Not Satisfied</a></h3>
<pre><code class="language-forge">thing Rock {
    weight: Int
}

satisfies(Rock { weight: 5 }, Quackable)    // false — Rock has no quack()
</code></pre>
<h3 id="multiple-interface-methods"><a class="header" href="#multiple-interface-methods">Multiple Interface Methods</a></h3>
<pre><code class="language-forge">power Serializable {
    fn to_string(it) -&gt; String
    fn to_json(it) -&gt; String
}

thing Config {
    data: String
}

give Config {
    define to_string(it) { return it.data }
    // Missing to_json
}

let c = Config { data: "test" }
satisfies(c, Serializable)    // false — missing to_json
</code></pre>
<h2 id="return-value"><a class="header" href="#return-value">Return Value</a></h2>
<p><code>satisfies</code> always returns a <code>Bool</code> value. It never throws an error for non-matching types; it simply returns <code>false</code>. It only raises a runtime error if called with the wrong number of arguments.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="default-values-2"><a class="header" href="#default-values-2">Default Values</a></h1>
<p>Struct fields may specify default values that are applied when the field is omitted during construction. Default expressions are evaluated at definition time and stored in the interpreter’s <code>struct_defaults</code> table.</p>
<h2 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h2>
<pre><code>FieldWithDefault = Identifier (":" TypeAnnotation)? "=" Expression
</code></pre>
<p>The default value follows an <code>=</code> sign after the field name and optional type annotation.</p>
<h2 id="defining-defaults"><a class="header" href="#defining-defaults">Defining Defaults</a></h2>
<pre><code class="language-forge">thing Config {
    host: String = "localhost",
    port: Int = 8080,
    debug: Bool = false
}
</code></pre>
<p>A field may have a type annotation, a default, both, or neither:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field Form</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Name only</td><td><code>data</code></td></tr>
<tr><td>Name + type</td><td><code>data: String</code></td></tr>
<tr><td>Name + default</td><td><code>data = "hello"</code></td></tr>
<tr><td>Name + type + default</td><td><code>data: String = "hello"</code></td></tr>
</tbody>
</table>
</div>
<h2 id="evaluation-timing"><a class="header" href="#evaluation-timing">Evaluation Timing</a></h2>
<p>Default expressions are evaluated <strong>at definition time</strong> — when the <code>thing</code>/<code>struct</code> statement is executed, not when an instance is constructed. This means:</p>
<pre><code class="language-forge">let counter = 0

thing Widget {
    id: Int = counter
}

change counter to 10

let w = Widget {}
say w.id    // 0, not 10 — default was captured at definition time
</code></pre>
<p>The default value is the result of evaluating the expression at the point where the struct is defined. Subsequent changes to variables referenced in the default expression do not affect the stored default.</p>
<h2 id="application-during-construction"><a class="header" href="#application-during-construction">Application During Construction</a></h2>
<p>When a struct instance is constructed, defaults are applied first, then explicitly provided fields override them:</p>
<ol>
<li>The interpreter retrieves the defaults from <code>struct_defaults[StructName]</code>.</li>
<li>All default key-value pairs are inserted into the new object.</li>
<li>Explicitly provided fields in the constructor are evaluated and inserted, overwriting any defaults with the same key.</li>
<li>The <code>__type__</code> field is inserted last.</li>
</ol>
<pre><code class="language-forge">thing Server {
    host: String = "0.0.0.0",
    port: Int = 3000,
    workers: Int = 4
}

// All defaults
let s1 = Server {}
// s1 = { host: "0.0.0.0", port: 3000, workers: 4, __type__: "Server" }

// Partial override
let s2 = Server { port: 8080 }
// s2 = { host: "0.0.0.0", port: 8080, workers: 4, __type__: "Server" }

// Full override
let s3 = Server { host: "127.0.0.1", port: 443, workers: 16 }
// s3 = { host: "127.0.0.1", port: 443, workers: 16, __type__: "Server" }
</code></pre>
<h2 id="default-expressions"><a class="header" href="#default-expressions">Default Expressions</a></h2>
<p>Default values may be any valid expression, not just literals. They are evaluated in the current scope at definition time:</p>
<pre><code class="language-forge">let default_name = "World"

thing Greeter {
    greeting: String = "Hello, " + default_name + "!"
}

let g = Greeter {}
say g.greeting    // "Hello, World!"
</code></pre>
<p>Function calls, arithmetic, string concatenation, and other expressions are all valid defaults.</p>
<h2 id="storage-1"><a class="header" href="#storage-1">Storage</a></h2>
<p>The interpreter stores defaults in a <code>struct_defaults</code> table:</p>
<pre><code>struct_defaults: HashMap&lt;String, IndexMap&lt;String, Value&gt;&gt;
</code></pre>
<p>The outer key is the struct name. The inner <code>IndexMap</code> maps field names to their default <code>Value</code>. Only fields with defaults are stored; fields without defaults are absent from the map.</p>
<h2 id="fields-without-defaults"><a class="header" href="#fields-without-defaults">Fields Without Defaults</a></h2>
<p>Fields without defaults must be provided during construction. If a field without a default is omitted, the constructed object simply will not have that field — no error is raised at construction time, but accessing the missing field later will produce a runtime error.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="static-methods-2"><a class="header" href="#static-methods-2">Static Methods</a></h1>
<p>Static methods are methods attached to a type that do not operate on an instance. They are defined in <code>give</code>/<code>impl</code> blocks without <code>it</code> as the first parameter and are called on the type name itself.</p>
<h2 id="syntax-13"><a class="header" href="#syntax-13">Syntax</a></h2>
<p>Static methods are defined like instance methods but without <code>it</code>:</p>
<pre><code class="language-forge">give TypeName {
    define method_name(params) {
        // body — no `it` parameter
    }
}
</code></pre>
<p>They are called on the type name:</p>
<pre><code>TypeName.method_name(args)
</code></pre>
<h2 id="defining-static-methods"><a class="header" href="#defining-static-methods">Defining Static Methods</a></h2>
<p>A method is classified as static when its first parameter is <strong>not</strong> named <code>it</code>. Any other parameter name (or no parameters at all) makes it a static method.</p>
<pre><code class="language-forge">thing Person {
    name: String,
    age: Int
}

give Person {
    // Static method — no `it` parameter
    define species() {
        return "Homo sapiens"
    }

    // Static method — first param is not `it`
    define create(name, age) {
        return Person { name: name, age: age }
    }

    // Instance method — first param IS `it`
    define greet(it) {
        say "Hello, I'm " + it.name
    }
}
</code></pre>
<h2 id="invocation"><a class="header" href="#invocation">Invocation</a></h2>
<p>Static methods are called using the type name with dot notation:</p>
<pre><code class="language-forge">Person.species()               // "Homo sapiens"
let p = Person.create("Bob", 25)  // Person { name: "Bob", age: 25 }
</code></pre>
<p>The runtime resolves <code>Person.method()</code> by:</p>
<ol>
<li>Evaluating <code>Person</code> — this yields the <code>BuiltIn("struct:Person")</code> sentinel value registered during struct definition.</li>
<li>Extracting the type name <code>"Person"</code> from the sentinel tag.</li>
<li>Looking up the method name in <code>static_methods["Person"]</code>.</li>
<li>Calling the function with the provided arguments (no instance prepended).</li>
</ol>
<h2 id="storage-2"><a class="header" href="#storage-2">Storage</a></h2>
<p>Static methods are stored in the <code>static_methods</code> table:</p>
<pre><code>static_methods: HashMap&lt;String, IndexMap&lt;String, Value&gt;&gt;
</code></pre>
<p>The key is the type name. The value is an <code>IndexMap</code> mapping method names to function values.</p>
<p>When a <code>give</code>/<code>impl</code> block is executed, each method is checked for the <code>it</code> parameter:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>First Parameter</th><th>Stored In</th><th>Call Syntax</th></tr>
</thead>
<tbody>
<tr><td><code>it</code></td><td><code>method_tables</code> only</td><td><code>instance.method()</code></td></tr>
<tr><td>Anything else</td><td>Both <code>method_tables</code> and <code>static_methods</code></td><td><code>TypeName.method()</code></td></tr>
</tbody>
</table>
</div>
<p>Static methods are stored in both tables. This means they appear in <code>method_tables</code> as well, which allows them to be found during interface satisfaction checks.</p>
<h2 id="factory-pattern-1"><a class="header" href="#factory-pattern-1">Factory Pattern</a></h2>
<p>A common use of static methods is the factory pattern — creating instances with validation or transformation logic:</p>
<pre><code class="language-forge">thing Color {
    r: Int,
    g: Int,
    b: Int
}

give Color {
    define from_hex(hex) {
        // Parse hex string to RGB values
        return Color { r: 0, g: 0, b: 0 }
    }

    define red() {
        return Color { r: 255, g: 0, b: 0 }
    }

    define display(it) {
        return "rgb(" + str(it.r) + ", " + str(it.g) + ", " + str(it.b) + ")"
    }
}

let c = Color.red()
say c.display()    // "rgb(255, 0, 0)"
</code></pre>
<h2 id="additive-blocks-1"><a class="header" href="#additive-blocks-1">Additive Blocks</a></h2>
<p>Like instance methods, static methods from multiple <code>give</code>/<code>impl</code> blocks are additive:</p>
<pre><code class="language-forge">give Math {
    define add(a, b) { return a + b }
}

give Math {
    define sub(a, b) { return a - b }
}

Math.add(1, 2)    // 3
Math.sub(5, 3)    // 2
</code></pre>
<h2 id="instance-vs-static-ambiguity"><a class="header" href="#instance-vs-static-ambiguity">Instance vs. Static Ambiguity</a></h2>
<p>The classification is based solely on whether the first parameter is named <code>it</code>. A method named <code>it</code> with a different first parameter name is static:</p>
<pre><code class="language-forge">give Config {
    // Static: first param is "key", not "it"
    define from_key(key) {
        return Config { value: key }
    }

    // Instance: first param is "it"
    define to_string(it) {
        return str(it.value)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>This chapter defines Forge’s error handling mechanisms. Forge uses a multi-layered approach: Result types for explicit error values, the <code>?</code> operator for propagation, <code>safe</code> blocks for error suppression, <code>must</code> for crash-on-error semantics, and <code>check</code> for declarative validation.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Forge provides five complementary error handling mechanisms:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mechanism</th><th>Purpose</th><th>Behavior on Error</th></tr>
</thead>
<tbody>
<tr><td><code>Result</code> type</td><td>Represent success/failure as values</td><td>Carries error as data</td></tr>
<tr><td><code>?</code> operator</td><td>Propagate errors up the call stack</td><td>Returns <code>Err</code> from enclosing function</td></tr>
<tr><td><code>safe { }</code></td><td>Suppress errors silently</td><td>Returns <code>null</code></td></tr>
<tr><td><code>must expr</code></td><td>Assert success or crash</td><td>Raises a runtime error</td></tr>
<tr><td><code>check expr</code></td><td>Declarative validation</td><td>Raises a runtime error with description</td></tr>
</tbody>
</table>
</div>
<p>These mechanisms serve different use cases:</p>
<ul>
<li><strong>Result + ?</strong> — For functions that can fail and callers that want to handle failures explicitly.</li>
<li><strong>safe</strong> — For optional operations where failure is acceptable and the value can be <code>null</code>.</li>
<li><strong>must</strong> — For operations that should never fail in correct code.</li>
<li><strong>check</strong> — For input validation with readable error messages.</li>
</ul>
<h2 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h2>
<p>All Forge runtime errors are represented by <code>RuntimeError</code>, which contains a <code>message</code> string and an optional <code>propagated</code> value. When an error is not caught, it terminates the program with an error message.</p>
<p>Errors can be caught with <code>try</code>/<code>catch</code>:</p>
<pre><code class="language-forge">try {
    let x = 1 / 0
} catch e {
    say e.message    // "division by zero"
    say e.type       // "ArithmeticError"
}
</code></pre>
<p>The catch variable receives an object with <code>message</code> and <code>type</code> fields. Error types are inferred from the error message content:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error Type</th><th>Triggered By</th></tr>
</thead>
<tbody>
<tr><td><code>TypeError</code></td><td>Message contains “type” or “Type”</td></tr>
<tr><td><code>ArithmeticError</code></td><td>Message contains “division by zero”</td></tr>
<tr><td><code>AssertionError</code></td><td>Message contains “assertion”</td></tr>
<tr><td><code>IndexError</code></td><td>Message contains “index” or “out of bounds”</td></tr>
<tr><td><code>ReferenceError</code></td><td>Message contains “not found” or “undefined”</td></tr>
<tr><td><code>RuntimeError</code></td><td>All other errors</td></tr>
</tbody>
</table>
</div>
<h2 id="subsections-3"><a class="header" href="#subsections-3">Subsections</a></h2>
<p>The following subsections define each error handling mechanism in detail:</p>
<ul>
<li><a href="#result-type-1">Result Type</a> — Ok/Err values and inspection functions.</li>
<li><a href="#error-propagation">Propagation</a> — The <code>?</code> operator.</li>
<li><a href="#safe-and-must">Safe and Must</a> — Error suppression and crash-on-error.</li>
<li><a href="#check">Check</a> — Declarative validation.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="result-type-1"><a class="header" href="#result-type-1">Result Type</a></h1>
<p>The <code>Result</code> type represents the outcome of an operation that may succeed or fail. A <code>Result</code> is either <code>Ok(value)</code> for success or <code>Err(message)</code> for failure. Results are first-class values that can be stored in variables, passed to functions, and returned from functions.</p>
<h2 id="syntax-14"><a class="header" href="#syntax-14">Syntax</a></h2>
<pre><code>ResultOk    = ("Ok" | "ok") "(" Expression ")"
ResultErr   = ("Err" | "err") "(" Expression ")"
</code></pre>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>Forge provides two constructors for creating Result values. Both accept case-insensitive names:</p>
<pre><code class="language-forge">let success = Ok(42)
let failure = Err("something went wrong")

// Lowercase variants are equivalent
let success2 = ok(42)
let failure2 = err("not found")
</code></pre>
<p><code>Ok</code> wraps any value:</p>
<pre><code class="language-forge">Ok(42)            // Result containing Int
Ok("hello")       // Result containing String
Ok([1, 2, 3])     // Result containing Array
Ok(null)          // Result containing null (Ok with no meaningful value)
</code></pre>
<p><code>Err</code> wraps an error value (typically a string message):</p>
<pre><code class="language-forge">Err("file not found")
Err("invalid input: expected number")
</code></pre>
<p>If <code>Ok</code> is called with no arguments, it wraps <code>null</code>. If <code>Err</code> is called with no arguments, it wraps the string <code>"error"</code>.</p>
<h2 id="runtime-representation"><a class="header" href="#runtime-representation">Runtime Representation</a></h2>
<p>Results are distinct variants in the <code>Value</code> enum:</p>
<ul>
<li><code>Value::ResultOk(Box&lt;Value&gt;)</code> — wraps the success value.</li>
<li><code>Value::ResultErr(Box&lt;Value&gt;)</code> — wraps the error value.</li>
</ul>
<p>The <code>typeof</code> builtin returns <code>"Result"</code> for both variants:</p>
<pre><code class="language-forge">typeof(Ok(1))     // "Result"
typeof(Err("x"))  // "Result"
</code></pre>
<h2 id="display-format"><a class="header" href="#display-format">Display Format</a></h2>
<p>Results are displayed as <code>Ok(value)</code> or <code>Err(value)</code>:</p>
<pre><code class="language-forge">say Ok(42)              // Ok(42)
say Err("not found")    // Err(not found)
</code></pre>
<p>In JSON serialization, Results produce <code>{ "Ok": value }</code> or <code>{ "Err": value }</code>.</p>
<h2 id="inspection-functions"><a class="header" href="#inspection-functions">Inspection Functions</a></h2>
<p>Four builtin functions inspect and extract Result values:</p>
<h3 id="is_okresult"><a class="header" href="#is_okresult">is_ok(result)</a></h3>
<p>Returns <code>true</code> if the value is <code>Ok</code>, <code>false</code> if <code>Err</code>. Raises a runtime error if the argument is not a Result.</p>
<pre><code class="language-forge">is_ok(Ok(42))           // true
is_ok(Err("oops"))      // false
</code></pre>
<h3 id="is_errresult"><a class="header" href="#is_errresult">is_err(result)</a></h3>
<p>Returns <code>true</code> if the value is <code>Err</code>, <code>false</code> if <code>Ok</code>. Raises a runtime error if the argument is not a Result.</p>
<pre><code class="language-forge">is_err(Ok(42))          // false
is_err(Err("oops"))     // true
</code></pre>
<h3 id="unwrapresult"><a class="header" href="#unwrapresult">unwrap(result)</a></h3>
<p>Extracts the inner value from <code>Ok</code>. If the value is <code>Err</code>, raises a runtime error with the message <code>"unwrap() on Err: &lt;error_value&gt;"</code>.</p>
<pre><code class="language-forge">unwrap(Ok(42))          // 42
unwrap(Err("oops"))     // runtime error: unwrap() on Err: oops
</code></pre>
<p><code>unwrap</code> also works with Option values (<code>Some</code>/<code>None</code>):</p>
<pre><code class="language-forge">unwrap(Some(42))        // 42
unwrap(None)            // runtime error: unwrap() called on None
</code></pre>
<h3 id="unwrap_orresult-default"><a class="header" href="#unwrap_orresult-default">unwrap_or(result, default)</a></h3>
<p>Extracts the inner value from <code>Ok</code>. If the value is <code>Err</code>, returns the <code>default</code> value instead. Never raises an error for valid Result inputs.</p>
<pre><code class="language-forge">unwrap_or(Ok(42), 0)       // 42
unwrap_or(Err("oops"), 0)  // 0
</code></pre>
<p><code>unwrap_or</code> also works with Option values:</p>
<pre><code class="language-forge">unwrap_or(Some(42), 0)     // 42
unwrap_or(None, 0)         // 0
</code></pre>
<p>Raises a runtime error if called with the wrong number of arguments or if the first argument is not a Result or Option.</p>
<h2 id="pattern-matching-on-results"><a class="header" href="#pattern-matching-on-results">Pattern Matching on Results</a></h2>
<p>Results can be matched in <code>match</code> expressions using <code>Ok</code> and <code>Err</code> patterns:</p>
<pre><code class="language-forge">let result = Ok(42)

match result {
    Ok(value) -&gt; say "Got: " + str(value),
    Err(msg) -&gt; say "Error: " + msg
}
</code></pre>
<h2 id="results-in-functions"><a class="header" href="#results-in-functions">Results in Functions</a></h2>
<p>Functions commonly return Results to signal success or failure:</p>
<pre><code class="language-forge">fn divide(a, b) {
    if b == 0 {
        return Err("division by zero")
    }
    return Ok(a / b)
}

let result = divide(10, 0)
if is_err(result) {
    say "Cannot divide: " + unwrap(Err("division by zero"))
}
</code></pre>
<h2 id="equality-1"><a class="header" href="#equality-1">Equality</a></h2>
<p>Two <code>Ok</code> values are equal if their inner values are equal. Two <code>Err</code> values are equal if their inner values are equal. <code>Ok</code> and <code>Err</code> are never equal to each other:</p>
<pre><code class="language-forge">Ok(42) == Ok(42)          // true
Err("x") == Err("x")     // true
Ok(42) == Err(42)         // false
Ok(1) == Ok(2)            // false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-propagation"><a class="header" href="#error-propagation">Error Propagation</a></h1>
<p>The <code>?</code> operator provides concise syntax for propagating errors up the call stack. When applied to a <code>Result</code> value, it unwraps <code>Ok</code> values and short-circuits on <code>Err</code> values by returning the error from the enclosing function.</p>
<h2 id="syntax-15"><a class="header" href="#syntax-15">Syntax</a></h2>
<pre><code>TryExpr = Expression "?"
</code></pre>
<p>The <code>?</code> operator is a postfix unary operator applied to an expression that evaluates to a <code>Result</code>.</p>
<h2 id="semantics"><a class="header" href="#semantics">Semantics</a></h2>
<p>The <code>?</code> operator evaluates its operand and inspects the result:</p>
<ul>
<li>If the value is <code>Ok(v)</code>, the expression evaluates to <code>v</code> (the inner value is unwrapped).</li>
<li>If the value is <code>Err(e)</code>, the enclosing function immediately returns <code>Err(e)</code>.</li>
<li>If the value is neither <code>Ok</code> nor <code>Err</code>, a runtime error is raised: <code>`?` expects Result value (Ok(...) or Err(...))</code>.</li>
</ul>
<pre><code class="language-forge">fn parse_number(s) {
    if s == "" {
        return Err("empty string")
    }
    return Ok(int(s))
}

fn double_parsed(s) {
    let n = parse_number(s)?    // unwraps Ok or returns Err
    return Ok(n * 2)
}

double_parsed("5")     // Ok(10)
double_parsed("")      // Err("empty string")
</code></pre>
<h2 id="propagation-mechanism"><a class="header" href="#propagation-mechanism">Propagation Mechanism</a></h2>
<p>When <code>?</code> encounters an <code>Err</code> value, it raises a <code>RuntimeError</code> with the <code>propagated</code> field set to the <code>Err</code> value. The runtime distinguishes propagated errors from ordinary runtime errors. When a propagated error reaches a function boundary, the function returns the propagated <code>Err</code> value rather than crashing the program.</p>
<p>The implementation:</p>
<ol>
<li><code>Expr::Try(expr)</code> evaluates <code>expr</code>.</li>
<li>If the result is <code>ResultOk(value)</code>, returns <code>value</code>.</li>
<li>If the result is <code>ResultErr(err)</code>, calls <code>RuntimeError::propagate(ResultErr(err))</code>, which creates a <code>RuntimeError</code> whose <code>propagated</code> field carries the original <code>Err</code> value.</li>
<li>The calling function’s error handler detects the propagated value and converts it back into a return value.</li>
</ol>
<h2 id="chaining-1"><a class="header" href="#chaining-1">Chaining</a></h2>
<p>The <code>?</code> operator can be chained across multiple function calls:</p>
<pre><code class="language-forge">fn read_config() {
    let text = read_file("config.json")?
    let parsed = json.parse(text)?
    return Ok(parsed)
}
</code></pre>
<p>Each <code>?</code> either unwraps the <code>Ok</code> value for the next step or short-circuits the entire function with the first <code>Err</code> encountered.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>The <code>?</code> operator requires that its operand evaluates to a <code>Result</code> value. Applying <code>?</code> to a non-Result value (such as an <code>Int</code>, <code>String</code>, or <code>null</code>) raises a runtime error:</p>
<pre><code class="language-forge">let x = 42?    // runtime error: `?` expects Result value (Ok(...) or Err(...))
</code></pre>
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<h3 id="propagate-and-transform"><a class="header" href="#propagate-and-transform">Propagate and Transform</a></h3>
<pre><code class="language-forge">fn load_user(id) {
    let data = fetch_user_data(id)?
    let user = parse_user(data)?
    return Ok(user)
}
</code></pre>
<h3 id="propagate-with-fallback"><a class="header" href="#propagate-with-fallback">Propagate with Fallback</a></h3>
<p>Combine <code>?</code> with <code>unwrap_or</code> for partial error handling:</p>
<pre><code class="language-forge">fn get_config_or_default() {
    let config = read_config()?            // propagate file errors
    let timeout = unwrap_or(config.timeout, 30)  // fallback for missing field
    return Ok(timeout)
}
</code></pre>
<h3 id="top-level-handling"><a class="header" href="#top-level-handling">Top-Level Handling</a></h3>
<p>At the top level, propagated errors become runtime errors since there is no enclosing function to return from:</p>
<pre><code class="language-forge">// If read_config returns Err, this crashes the program
let config = read_config()?
</code></pre>
<p>To handle errors at the top level, use <code>is_ok</code>/<code>is_err</code> checks, <code>unwrap_or</code>, or <code>try</code>/<code>catch</code> blocks instead of <code>?</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="safe-and-must"><a class="header" href="#safe-and-must">Safe and Must</a></h1>
<p><code>safe</code> and <code>must</code> provide two ends of the error handling spectrum: <code>safe</code> suppresses errors silently, while <code>must</code> crashes on error with a clear message.</p>
<h2 id="safe-blocks"><a class="header" href="#safe-blocks">Safe Blocks</a></h2>
<h3 id="syntax-16"><a class="header" href="#syntax-16">Syntax</a></h3>
<pre><code>SafeBlock = "safe" "{" Statement* "}"
</code></pre>
<p>The <code>safe</code> keyword introduces a block whose errors are silently suppressed.</p>
<h3 id="semantics-1"><a class="header" href="#semantics-1">Semantics</a></h3>
<p>A <code>safe</code> block executes its body statements. If any statement raises a runtime error, the error is caught and the block evaluates to <code>null</code>. If the block completes successfully, its result is returned normally.</p>
<pre><code class="language-forge">safe {
    let data = json.parse("invalid json")
    say data
}
// No error — block silently returns null
</code></pre>
<h3 id="behavior"><a class="header" href="#behavior">Behavior</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Block Outcome</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>Body completes successfully</td><td>Signal passes through (value, return, etc.)</td></tr>
<tr><td>Body raises a runtime error</td><td><code>null</code> (error suppressed)</td></tr>
</tbody>
</table>
</div>
<p>The <code>safe</code> block is a <strong>statement</strong>, not an expression. It does not produce a value that can be assigned directly. When used for its side effects, it simply prevents errors from propagating:</p>
<pre><code class="language-forge">// Attempt to write a file; ignore errors
safe {
    fs.write("log.txt", "entry")
}

// Execution continues regardless
say "done"
</code></pre>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h3>
<ul>
<li>Optional side effects (logging, caching) where failure is acceptable.</li>
<li>Defensive code around external operations (file I/O, network) that may fail intermittently.</li>
<li>Quick prototyping where error handling is deferred.</li>
</ul>
<h3 id="caution"><a class="header" href="#caution">Caution</a></h3>
<p><code>safe</code> blocks suppress <strong>all</strong> errors indiscriminately, including programming bugs, type errors, and logic errors. Overuse of <code>safe</code> can hide real problems. Prefer explicit error handling with <code>Result</code>/<code>?</code> for production code.</p>
<h2 id="must-expression"><a class="header" href="#must-expression">Must Expression</a></h2>
<h3 id="syntax-1-1"><a class="header" href="#syntax-1-1">Syntax</a></h3>
<pre><code>MustExpr = "must" Expression
</code></pre>
<p>The <code>must</code> keyword is a prefix operator applied to an expression.</p>
<h3 id="semantics-1-1"><a class="header" href="#semantics-1-1">Semantics</a></h3>
<p><code>must</code> evaluates its operand and asserts that the result is a successful value:</p>
<ul>
<li>If the value is <code>Ok(v)</code>, returns <code>v</code> (unwrapped).</li>
<li>If the value is <code>Err(e)</code>, raises a runtime error: <code>"must failed: &lt;e&gt;"</code>.</li>
<li>If the value is <code>null</code>, raises a runtime error: <code>"must failed: got null"</code>.</li>
<li>For any other value, returns it unchanged.</li>
</ul>
<pre><code class="language-forge">// Succeeds — unwraps Ok
let value = must Ok(42)       // 42

// Crashes — Err inside must
let value = must Err("oops")  // runtime error: must failed: oops

// Crashes — null inside must
let value = must null          // runtime error: must failed: got null

// Passes through — non-Result, non-null
let value = must 42            // 42
</code></pre>
<h3 id="comparison-with-unwrap"><a class="header" href="#comparison-with-unwrap">Comparison with unwrap</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>On <code>Ok(v)</code></th><th>On <code>Err(e)</code></th><th>On <code>null</code></th><th>On other</th></tr>
</thead>
<tbody>
<tr><td><code>unwrap(r)</code></td><td><code>v</code></td><td>Error</td><td>Error (for None)</td><td>Error</td></tr>
<tr><td><code>must expr</code></td><td><code>v</code></td><td>Error</td><td>Error</td><td>Pass through</td></tr>
</tbody>
</table>
</div>
<p>The key difference: <code>must</code> passes through non-Result, non-null values unchanged, while <code>unwrap</code> requires a Result or Option value. <code>must</code> is designed for contexts where the expression might return a Result, a plain value, or null.</p>
<h3 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h3>
<ul>
<li>
<p>Asserting that a critical operation succeeds:</p>
<pre><code class="language-forge">let db = must db.open("app.db")
</code></pre>
</li>
<li>
<p>Unwrapping configuration that should always be present:</p>
<pre><code class="language-forge">let key = must env.get("API_KEY")
</code></pre>
</li>
<li>
<p>Failing fast on unexpected null values:</p>
<pre><code class="language-forge">let user = must find_user(id)
</code></pre>
</li>
</ul>
<h2 id="combining-safe-and-must"><a class="header" href="#combining-safe-and-must">Combining Safe and Must</a></h2>
<p><code>safe</code> and <code>must</code> can be used together for fallback patterns:</p>
<pre><code class="language-forge">// Try the primary source, fall back to default
safe {
    let config = must load_config("primary.json")
    apply_config(config)
}
// If must fails, safe catches it and continues

apply_config(default_config())
</code></pre>
<p>However, this pattern is generally better expressed with Result types:</p>
<pre><code class="language-forge">let config = unwrap_or(load_config("primary.json"), default_config())
apply_config(config)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="check"><a class="header" href="#check">Check</a></h1>
<p>The <code>check</code> statement provides declarative validation with clear error messages. It evaluates a condition and raises a runtime error if the check fails.</p>
<h2 id="syntax-17"><a class="header" href="#syntax-17">Syntax</a></h2>
<pre><code>CheckStmt     = "check" Expression CheckKind
CheckKind     = IsNotEmpty | Contains | Between | IsTrue
IsNotEmpty    = "is" "not" "empty"
Contains      = "contains" Expression
Between       = "is" "between" Expression "and" Expression
IsTrue        = (empty — implicit truth check)
</code></pre>
<h2 id="check-kinds"><a class="header" href="#check-kinds">Check Kinds</a></h2>
<p>Forge supports four validation kinds, each producing a specific boolean test:</p>
<h3 id="is-not-empty"><a class="header" href="#is-not-empty">is not empty</a></h3>
<p>Tests that a value is non-empty. The definition of “empty” depends on the type:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Empty When</th></tr>
</thead>
<tbody>
<tr><td><code>String</code></td><td>Length is 0</td></tr>
<tr><td><code>Array</code></td><td>Length is 0</td></tr>
<tr><td><code>Null</code></td><td>Always empty</td></tr>
<tr><td>Other types</td><td>Never empty</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let name = "Alice"
check name is not empty    // passes

let empty = ""
check empty is not empty   // runtime error: check failed: "" did not pass validation
</code></pre>
<h3 id="contains"><a class="header" href="#contains">contains</a></h3>
<p>Tests that a string contains a substring:</p>
<pre><code class="language-forge">let email = "user@example.com"
check email contains "@"    // passes

let bad = "not-an-email"
check bad contains "@"      // runtime error: check failed
</code></pre>
<p>The <code>contains</code> check currently operates on strings only. Both the value and the needle must be strings; other type combinations return <code>false</code>.</p>
<h3 id="is-between--and"><a class="header" href="#is-between--and">is between … and</a></h3>
<p>Tests that a numeric value falls within an inclusive range:</p>
<pre><code class="language-forge">let age = 25
check age is between 0 and 150    // passes

let temp = -10
check temp is between 0 and 100   // runtime error: check failed
</code></pre>
<p>Both <code>Int</code> and <code>Float</code> values are supported, but the value and both bounds must be the same type. Mixed-type comparisons (e.g., <code>Int</code> value with <code>Float</code> bounds) return <code>false</code>.</p>
<h3 id="implicit-truth-check"><a class="header" href="#implicit-truth-check">Implicit Truth Check</a></h3>
<p>When no check kind is specified, the value is tested for truthiness:</p>
<pre><code class="language-forge">let valid = true
check valid    // passes

let invalid = false
check invalid  // runtime error: check failed
</code></pre>
<h2 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h2>
<p>When a check fails, the runtime raises a <code>RuntimeError</code> with the message:</p>
<pre><code>check failed: &lt;value&gt; did not pass validation
</code></pre>
<p>Where <code>&lt;value&gt;</code> is the string representation of the tested value.</p>
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<pre><code class="language-forge">fn create_user(name, age, email) {
    check name is not empty
    check age is between 0 and 150
    check email contains "@"

    return { name: name, age: age, email: email }
}
</code></pre>
<h3 id="preconditions"><a class="header" href="#preconditions">Preconditions</a></h3>
<pre><code class="language-forge">fn withdraw(account, amount) {
    check amount is between 1 and 10000
    check account.balance is between amount and 999999

    account.balance = account.balance - amount
}
</code></pre>
<h3 id="configuration-validation"><a class="header" href="#configuration-validation">Configuration Validation</a></h3>
<pre><code class="language-forge">let config = load_config()
check config.host is not empty
check config.port is between 1 and 65535
</code></pre>
<h2 id="comparison-with-assert"><a class="header" href="#comparison-with-assert">Comparison with Assert</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th><code>check</code></th><th><code>assert</code></th></tr>
</thead>
<tbody>
<tr><td>Purpose</td><td>Declarative validation</td><td>General assertion</td></tr>
<tr><td>Syntax</td><td><code>check expr is not empty</code></td><td><code>assert(condition, "message")</code></td></tr>
<tr><td>Error message</td><td>Auto-generated from value</td><td>User-provided</td></tr>
<tr><td>Kinds</td><td><code>is not empty</code>, <code>contains</code>, <code>is between</code>, truth</td><td>Boolean only</td></tr>
</tbody>
</table>
</div>
<p><code>check</code> is designed for readable validation logic with automatic error descriptions. <code>assert</code> is a general-purpose assertion that requires the programmer to provide an error message.</p>
<h2 id="nesting-in-safe-blocks"><a class="header" href="#nesting-in-safe-blocks">Nesting in Safe Blocks</a></h2>
<p>Check failures are runtime errors and can be caught by <code>safe</code> blocks or <code>try</code>/<code>catch</code>:</p>
<pre><code class="language-forge">safe {
    check "" is not empty    // fails, but error is suppressed
}
say "continues"              // prints "continues"
</code></pre>
<pre><code class="language-forge">try {
    check input is not empty
} catch e {
    say "Validation error: " + e.message
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>This chapter defines Forge’s concurrency primitives. Forge provides three mechanisms for concurrent execution: channels for message passing, <code>spawn</code> for task creation, and <code>async</code>/<code>await</code> (with natural syntax aliases <code>forge</code>/<code>hold</code>) for asynchronous functions.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Forge’s concurrency model is built on OS threads (via <code>std::thread</code>) with channels for communication:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mechanism</th><th>Purpose</th><th>Syntax</th></tr>
</thead>
<tbody>
<tr><td>Channels</td><td>Message passing between tasks</td><td><code>channel()</code>, <code>send()</code>, <code>receive()</code></td></tr>
<tr><td>Spawn</td><td>Create concurrent tasks</td><td><code>spawn { body }</code></td></tr>
<tr><td>Async/Await</td><td>Asynchronous function definition and invocation</td><td><code>async fn</code> / <code>await</code>, <code>forge</code> / <code>hold</code></td></tr>
</tbody>
</table>
</div>
<h2 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h2>
<p>Forge spawns concurrent tasks as OS threads. Each spawned task receives a clone of the current environment, enabling access to variables defined before the spawn point. Tasks do not share mutable state directly; communication should use channels.</p>
<p>The runtime uses <code>std::thread::spawn</code> for task creation and <code>std::sync::mpsc::sync_channel</code> for channels. This provides:</p>
<ul>
<li>True parallelism on multi-core systems.</li>
<li>Thread-safe communication through bounded channels.</li>
<li>Task handle values with condition-variable notification for <code>await</code>.</li>
</ul>
<h2 id="task-handles"><a class="header" href="#task-handles">Task Handles</a></h2>
<p>When <code>spawn</code> is used as an expression, it returns a <code>TaskHandle</code> value. Task handles are opaque values that can be passed to <code>await</code> (or <code>hold</code>) to block until the spawned task completes and retrieve its return value.</p>
<pre><code class="language-forge">let handle = spawn { return 42 }
let result = await handle    // 42
</code></pre>
<p>Task handles use an <code>Arc&lt;(Mutex&lt;Option&lt;Value&gt;&gt;, Condvar)&gt;</code> internally:</p>
<ul>
<li>The <code>Mutex&lt;Option&lt;Value&gt;&gt;</code> holds the task’s return value (initially <code>None</code>).</li>
<li>The <code>Condvar</code> is notified when the task writes its result.</li>
<li><code>await</code> blocks on the <code>Condvar</code> until the result is available, then extracts it.</li>
</ul>
<h2 id="error-isolation"><a class="header" href="#error-isolation">Error Isolation</a></h2>
<p>Errors in spawned tasks do not crash the parent task. If a spawned task encounters a runtime error, the error is printed to stderr and the task’s result is <code>null</code>:</p>
<pre><code class="language-forge">spawn { let x = 1 / 0 }    // prints error to stderr, does not crash parent
say "still running"          // executes normally
</code></pre>
<h2 id="subsections-4"><a class="header" href="#subsections-4">Subsections</a></h2>
<p>The following subsections define each concurrency mechanism in detail:</p>
<ul>
<li><a href="#channels">Channels</a> — Message passing between tasks.</li>
<li><a href="#spawn">Spawn</a> — Creating concurrent tasks.</li>
<li><a href="#async-functions-2">Async Functions</a> — Defining asynchronous functions.</li>
<li><a href="#await">Await</a> — Waiting for async results.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p>Channels provide thread-safe message passing between concurrent tasks. A channel is a bounded, synchronous queue that allows one task to send values and another to receive them.</p>
<h2 id="creating-a-channel"><a class="header" href="#creating-a-channel">Creating a Channel</a></h2>
<h3 id="syntax-18"><a class="header" href="#syntax-18">Syntax</a></h3>
<pre><code>channel()
channel(capacity)
</code></pre>
<p>The <code>channel</code> builtin creates a new channel and returns a <code>Channel</code> value. An optional integer argument specifies the buffer capacity (default: 32).</p>
<pre><code class="language-forge">let ch = channel()        // buffered channel, capacity 32
let ch = channel(100)     // buffered channel, capacity 100
let ch = channel(1)       // minimal buffer, capacity 1
</code></pre>
<p>If a non-integer argument is provided, the default capacity of 32 is used. The minimum capacity is 1 (values less than 1 are clamped to 1).</p>
<h2 id="channel-value"><a class="header" href="#channel-value">Channel Value</a></h2>
<p>A channel is represented at runtime as <code>Value::Channel(Arc&lt;ChannelInner&gt;)</code>. The <code>ChannelInner</code> struct contains:</p>
<ul>
<li><code>tx: Mutex&lt;Option&lt;SyncSender&lt;Value&gt;&gt;&gt;</code> — the sender half.</li>
<li><code>rx: Mutex&lt;Option&lt;Receiver&lt;Value&gt;&gt;&gt;</code> — the receiver half.</li>
<li><code>capacity: usize</code> — the buffer capacity.</li>
</ul>
<p>Channels are reference-counted via <code>Arc</code>, so they can be safely shared between the parent task and spawned tasks through environment cloning.</p>
<h2 id="sending-values"><a class="header" href="#sending-values">Sending Values</a></h2>
<h3 id="sendchannel-value"><a class="header" href="#sendchannel-value">send(channel, value)</a></h3>
<p>The <code>send</code> builtin sends a value through a channel. It blocks if the channel buffer is full, waiting until a receiver consumes a value.</p>
<pre><code class="language-forge">let ch = channel()
send(ch, 42)
send(ch, "hello")
send(ch, [1, 2, 3])
</code></pre>
<p>Any Forge value can be sent through a channel: integers, strings, arrays, objects, functions, Results, and other channels.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>channel</code> — A <code>Channel</code> value (first argument).</li>
<li><code>value</code> — Any <code>Value</code> to send (second argument).</li>
</ul>
<p><strong>Returns:</strong> <code>null</code> on success.</p>
<p><strong>Errors:</strong></p>
<ul>
<li><code>"send(channel, value) requires 2 arguments"</code> — Wrong argument count.</li>
<li><code>"send() requires a channel as first argument"</code> — First argument is not a channel.</li>
<li><code>"channel closed"</code> — The receiver has been dropped.</li>
</ul>
<h3 id="try_sendchannel-value"><a class="header" href="#try_sendchannel-value">try_send(channel, value)</a></h3>
<p>The <code>try_send</code> builtin attempts to send a value without blocking. Returns <code>true</code> if the value was sent, <code>false</code> if the channel is full or closed.</p>
<pre><code class="language-forge">let ch = channel(1)
send(ch, "first")            // fills the buffer
let ok = try_send(ch, "second")  // false — buffer is full
</code></pre>
<p><strong>Arguments:</strong> Same as <code>send</code>.</p>
<p><strong>Returns:</strong> <code>Bool</code> — <code>true</code> if sent, <code>false</code> otherwise.</p>
<p><strong>Errors:</strong></p>
<ul>
<li><code>"try_send() requires (channel, value)"</code> — Wrong argument count.</li>
<li><code>"try_send() first argument must be a channel"</code> — First argument is not a channel.</li>
</ul>
<h2 id="receiving-values"><a class="header" href="#receiving-values">Receiving Values</a></h2>
<h3 id="receivechannel"><a class="header" href="#receivechannel">receive(channel)</a></h3>
<p>The <code>receive</code> builtin receives a value from a channel. It blocks until a value is available.</p>
<pre><code class="language-forge">let ch = channel()
send(ch, 42)
let val = receive(ch)    // 42
</code></pre>
<p>If the channel is closed (all senders dropped) and the buffer is empty, <code>receive</code> returns <code>null</code>.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>channel</code> — A <code>Channel</code> value.</li>
</ul>
<p><strong>Returns:</strong> The received <code>Value</code>, or <code>null</code> if the channel is closed.</p>
<p><strong>Errors:</strong></p>
<ul>
<li><code>"receive(channel) requires 1 argument"</code> — No argument provided.</li>
<li><code>"receive() requires a channel as first argument"</code> — Argument is not a channel.</li>
</ul>
<h3 id="try_receivechannel"><a class="header" href="#try_receivechannel">try_receive(channel)</a></h3>
<p>The <code>try_receive</code> builtin attempts to receive a value without blocking. Returns <code>Some(value)</code> if a value was available, <code>None</code> if the channel is empty.</p>
<pre><code class="language-forge">let ch = channel()
let result = try_receive(ch)    // None — nothing sent yet

send(ch, 42)
let result = try_receive(ch)    // Some(42)
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>channel</code> — A <code>Channel</code> value.</li>
</ul>
<p><strong>Returns:</strong> <code>Some(value)</code> if a value was received, <code>None</code> if the channel is empty or closed.</p>
<p><strong>Errors:</strong></p>
<ul>
<li><code>"try_receive() requires a channel"</code> — No argument provided.</li>
<li><code>"try_receive() argument must be a channel"</code> — Argument is not a channel.</li>
</ul>
<h2 id="producer-consumer-pattern"><a class="header" href="#producer-consumer-pattern">Producer-Consumer Pattern</a></h2>
<p>Channels enable classic producer-consumer patterns:</p>
<pre><code class="language-forge">let ch = channel()

// Producer
spawn {
    repeat 5 times {
        send(ch, it)
    }
}

// Consumer
repeat 5 times {
    let val = receive(ch)
    say "got: " + str(val)
}
</code></pre>
<h2 id="fan-out-pattern"><a class="header" href="#fan-out-pattern">Fan-Out Pattern</a></h2>
<p>Multiple consumers can share a channel, though only one will receive each message:</p>
<pre><code class="language-forge">let work = channel()
let results = channel()

// Producer
spawn {
    for item in tasks {
        send(work, item)
    }
}

// Workers
repeat 3 times {
    spawn {
        let item = receive(work)
        let result = process(item)
        send(results, result)
    }
}
</code></pre>
<h2 id="channel-lifetime"><a class="header" href="#channel-lifetime">Channel Lifetime</a></h2>
<p>Channels remain open as long as at least one reference exists. When all references to a channel are dropped (through garbage collection or scope exit), the underlying <code>SyncSender</code> and <code>Receiver</code> are dropped, which closes the channel. Subsequent <code>send</code> calls on a closed channel return an error; <code>receive</code> calls return <code>null</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="spawn"><a class="header" href="#spawn">Spawn</a></h1>
<p>The <code>spawn</code> keyword creates a concurrent task that runs in a separate OS thread. It can be used as a statement (fire-and-forget) or as an expression (returning a task handle).</p>
<h2 id="syntax-19"><a class="header" href="#syntax-19">Syntax</a></h2>
<pre><code>SpawnStmt = "spawn" Block
SpawnExpr = "spawn" Block
</code></pre>
<p>When <code>spawn</code> appears as a statement, the result is discarded. When it appears as an expression (e.g., assigned to a variable), it returns a <code>TaskHandle</code>.</p>
<h2 id="statement-form-fire-and-forget"><a class="header" href="#statement-form-fire-and-forget">Statement Form (Fire-and-Forget)</a></h2>
<p>When <code>spawn</code> is used as a statement, the block is executed concurrently and its result is discarded:</p>
<pre><code class="language-forge">spawn {
    say "running in background"
}
say "continues immediately"
</code></pre>
<p>The parent does not wait for the spawned task to complete. The spawned block runs independently.</p>
<h2 id="expression-form-task-handle"><a class="header" href="#expression-form-task-handle">Expression Form (Task Handle)</a></h2>
<p>When <code>spawn</code> is used as an expression, it returns a <code>TaskHandle</code> that can be awaited:</p>
<pre><code class="language-forge">let handle = spawn {
    return 42
}

let result = await handle    // 42
</code></pre>
<p>The task handle is an opaque value that represents the running task. Its type name is <code>"TaskHandle"</code>.</p>
<h2 id="execution-model-1"><a class="header" href="#execution-model-1">Execution Model</a></h2>
<p>When <code>spawn</code> is executed:</p>
<ol>
<li>The block’s statements are cloned.</li>
<li>A new <code>Interpreter</code> is created and its environment is cloned from the parent.</li>
<li>A shared result slot is created: <code>Arc&lt;(Mutex&lt;Option&lt;Value&gt;&gt;, Condvar)&gt;</code>.</li>
<li>A new OS thread is spawned via <code>std::thread::spawn</code>.</li>
<li>The thread executes the block. When it completes:
<ul>
<li><code>Signal::Return(v)</code> or <code>Signal::ImplicitReturn(v)</code> stores <code>v</code> in the result slot.</li>
<li><code>Signal::None</code> or other signals store <code>null</code>.</li>
<li>Errors print to stderr and store <code>null</code>.</li>
</ul>
</li>
<li>The <code>Condvar</code> is notified, unblocking any <code>await</code> on the handle.</li>
<li>The <code>TaskHandle</code> value is returned to the parent.</li>
</ol>
<h2 id="environment-cloning"><a class="header" href="#environment-cloning">Environment Cloning</a></h2>
<p>The spawned task receives a clone of the parent’s environment at the point of the <code>spawn</code> call. This means:</p>
<ul>
<li>Variables defined before <code>spawn</code> are accessible in the spawned block.</li>
<li>Modifications to the environment inside the spawned block do not affect the parent.</li>
<li>Modifications in the parent after <code>spawn</code> do not affect the spawned block.</li>
</ul>
<pre><code class="language-forge">let x = 10
spawn {
    say x        // 10 — sees parent's x
    let x = 20   // shadows, does not affect parent
}
say x            // 10 — parent's x unchanged
</code></pre>
<h2 id="return-values-2"><a class="header" href="#return-values-2">Return Values</a></h2>
<p>The spawned block may use <code>return</code> to provide a result. This value is stored in the task handle’s result slot:</p>
<pre><code class="language-forge">let h = spawn {
    return "hello from spawn"
}
let msg = await h    // "hello from spawn"
</code></pre>
<p>If no <code>return</code> is used, the result is the last expression value (implicit return) or <code>null</code>:</p>
<pre><code class="language-forge">let h = spawn {
    1 + 1
}
let result = await h    // may be 2 or null depending on block signal
</code></pre>
<h2 id="error-isolation-1"><a class="header" href="#error-isolation-1">Error Isolation</a></h2>
<p>Errors in spawned tasks are isolated from the parent. A runtime error in the spawned block:</p>
<ol>
<li>Prints the error message to stderr: <code>spawn error: &lt;message&gt;</code>.</li>
<li>Stores <code>null</code> in the result slot.</li>
<li>Does <strong>not</strong> crash or affect the parent task.</li>
</ol>
<pre><code class="language-forge">spawn {
    let x = 1 / 0    // error: division by zero
}
// Parent continues normally
say "still running"
</code></pre>
<p>When the handle is awaited, the result is <code>null</code>:</p>
<pre><code class="language-forge">let h = spawn {
    return 1 / 0
}
let result = await h    // null (error was caught internally)
</code></pre>
<h2 id="multiple-spawns"><a class="header" href="#multiple-spawns">Multiple Spawns</a></h2>
<p>Multiple tasks can be spawned and awaited:</p>
<pre><code class="language-forge">let a = spawn { return 10 }
let b = spawn { return 20 }

let va = await a    // 10
let vb = await b    // 20
say va + vb         // 30
</code></pre>
<p>Tasks run concurrently in separate threads. The order of completion is non-deterministic.</p>
<h2 id="spawn-with-channels"><a class="header" href="#spawn-with-channels">Spawn with Channels</a></h2>
<p>Spawn and channels work together for structured concurrency:</p>
<pre><code class="language-forge">let ch = channel()

spawn {
    let result = expensive_computation()
    send(ch, result)
}

// Do other work...

let result = receive(ch)    // blocks until computation completes
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="async-functions-2"><a class="header" href="#async-functions-2">Async Functions</a></h1>
<p>Async functions are functions that execute asynchronously and must be awaited to retrieve their result. Forge provides dual syntax: <code>async fn</code> (classic) and <code>forge</code> (natural).</p>
<h2 id="syntax-20"><a class="header" href="#syntax-20">Syntax</a></h2>
<pre><code>AsyncFnDef    = ("async" "fn" | "forge") Identifier "(" ParamList ")" Block
</code></pre>
<h2 id="defining-async-functions"><a class="header" href="#defining-async-functions">Defining Async Functions</a></h2>
<p>Classic syntax:</p>
<pre><code class="language-forge">async fn fetch_data() {
    let resp = http.get("https://api.example.com/data")
    return resp
}
</code></pre>
<p>Natural syntax:</p>
<pre><code class="language-forge">forge fetch_data() {
    let resp = http.get("https://api.example.com/data")
    return resp
}
</code></pre>
<p>Both forms are semantically identical. The parser produces the same <code>FnDef</code> AST node with <code>is_async: true</code>.</p>
<h2 id="semantics-2"><a class="header" href="#semantics-2">Semantics</a></h2>
<p>An async function is defined with the <code>is_async</code> flag set to <code>true</code> in the AST. In the current implementation, async functions are stored as regular function values. The <code>is_async</code> flag is recorded in the AST but the interpreter treats async functions identically to synchronous functions during definition.</p>
<p>The distinction becomes relevant at the call site: async functions are expected to be called with <code>await</code> (or <code>hold</code>) to retrieve their result. Without <code>await</code>, the function executes synchronously and its return value is available immediately.</p>
<h2 id="registration-1"><a class="header" href="#registration-1">Registration</a></h2>
<p>When an async function definition is executed, the function is registered in the environment as a <code>Value::Function</code> just like a synchronous function. The <code>is_async</code> flag from the AST does not alter the stored function value.</p>
<pre><code class="language-forge">forge get_value() {
    return 42
}

// The function is callable like any other function
let result = get_value()       // 42 (runs synchronously)
let result = await get_value() // 42 (await passes through non-handle values)
</code></pre>
<h2 id="parameters-and-return-values"><a class="header" href="#parameters-and-return-values">Parameters and Return Values</a></h2>
<p>Async functions support the same parameter syntax as regular functions, including default values and type annotations:</p>
<pre><code class="language-forge">async fn fetch_user(id: Int, timeout: Int = 30) {
    let resp = http.get("https://api.example.com/users/" + str(id))
    return json.parse(resp.body)
}
</code></pre>
<p>Return values follow the same rules as synchronous functions. The <code>return</code> statement provides an explicit return value; without it, the function returns <code>null</code> or the last expression’s value.</p>
<h2 id="combining-with-spawn"><a class="header" href="#combining-with-spawn">Combining with Spawn</a></h2>
<p>For true concurrent execution, combine async functions with <code>spawn</code>:</p>
<pre><code class="language-forge">forge compute(n) {
    // Expensive computation
    return n * n
}

let handle = spawn { return compute(42) }
let result = await handle    // 1764
</code></pre>
<p>The <code>spawn</code> keyword is what creates actual concurrency (a new OS thread). The <code>async</code>/<code>forge</code> keyword marks intent but does not itself create a new thread.</p>
<h2 id="natural-syntax-forge"><a class="header" href="#natural-syntax-forge">Natural Syntax: forge</a></h2>
<p>The <code>forge</code> keyword serves double duty as both the language name and the natural-syntax alias for <code>async fn</code>. In a function definition context, <code>forge</code> is parsed as an async function definition:</p>
<pre><code class="language-forge">forge load_config() {
    let text = fs.read("config.json")
    return json.parse(text)
}
</code></pre>
<p>This reads naturally as “forge a load_config function” while being functionally equivalent to <code>async fn load_config()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="await"><a class="header" href="#await">Await</a></h1>
<p>The <code>await</code> keyword (or its natural alias <code>hold</code>) suspends the current execution until an asynchronous operation completes, then returns the result. It is primarily used with task handles from <code>spawn</code>.</p>
<h2 id="syntax-21"><a class="header" href="#syntax-21">Syntax</a></h2>
<pre><code>AwaitExpr = ("await" | "hold") Expression
</code></pre>
<h2 id="semantics-3"><a class="header" href="#semantics-3">Semantics</a></h2>
<p>The <code>await</code> expression evaluates its operand and inspects the result:</p>
<h3 id="taskhandle"><a class="header" href="#taskhandle">TaskHandle</a></h3>
<p>If the operand is a <code>TaskHandle</code> (returned by <code>spawn</code>), <code>await</code> blocks the current thread until the spawned task completes, then returns the task’s result value.</p>
<pre><code class="language-forge">let h = spawn { return 42 }
let result = await h    // blocks until task completes, returns 42
</code></pre>
<p>The blocking mechanism uses a condition variable:</p>
<ol>
<li>Lock the <code>Mutex&lt;Option&lt;Value&gt;&gt;</code> inside the task handle.</li>
<li>While the value is <code>None</code>, wait on the <code>Condvar</code>.</li>
<li>When notified (the spawned task stored its result), extract the value.</li>
<li>Return the extracted value, or <code>null</code> if the slot was empty.</li>
</ol>
<h3 id="non-handle-values-pass-through"><a class="header" href="#non-handle-values-pass-through">Non-Handle Values (Pass-Through)</a></h3>
<p>If the operand is not a <code>TaskHandle</code>, <code>await</code> returns the value unchanged. This provides backward compatibility and allows <code>await</code> to be used uniformly:</p>
<pre><code class="language-forge">await 42         // 42
await "hello"    // "hello"
await null       // null
await Ok(10)     // Ok(10)
</code></pre>
<p>This pass-through behavior means <code>await</code> is always safe to call, even on values that are not async results.</p>
<h2 id="natural-syntax-hold"><a class="header" href="#natural-syntax-hold">Natural Syntax: hold</a></h2>
<p>The <code>hold</code> keyword is the natural-syntax alias for <code>await</code>:</p>
<pre><code class="language-forge">let h = spawn { return "data" }
let result = hold h    // "data"
</code></pre>
<p><code>hold</code> and <code>await</code> are parsed to the same <code>Expr::Await</code> AST node and behave identically.</p>
<h2 id="awaiting-multiple-tasks"><a class="header" href="#awaiting-multiple-tasks">Awaiting Multiple Tasks</a></h2>
<p>Multiple task handles can be awaited sequentially:</p>
<pre><code class="language-forge">let a = spawn { return 10 }
let b = spawn { return 20 }
let c = spawn { return 30 }

let va = await a    // 10
let vb = await b    // 20
let vc = await c    // 30

say va + vb + vc    // 60
</code></pre>
<p>Each <code>await</code> blocks until its specific task completes. Tasks run concurrently, so the total time is approximately the duration of the slowest task, not the sum.</p>
<h2 id="awaiting-errored-tasks"><a class="header" href="#awaiting-errored-tasks">Awaiting Errored Tasks</a></h2>
<p>If a spawned task encountered a runtime error, its result slot contains <code>null</code>. Awaiting such a handle returns <code>null</code>:</p>
<pre><code class="language-forge">let h = spawn {
    return 1 / 0    // runtime error
}

let result = await h    // null
</code></pre>
<p>The error is printed to stderr by the spawned task. The parent receives <code>null</code> and must check for it if error detection is needed.</p>
<h2 id="await-in-functions"><a class="header" href="#await-in-functions">Await in Functions</a></h2>
<p><code>await</code> can be used inside regular and async functions:</p>
<pre><code class="language-forge">fn parallel_sum(a, b) {
    let ha = spawn { return a * a }
    let hb = spawn { return b * b }
    return await ha + await hb
}

parallel_sum(3, 4)    // 25
</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The <code>await</code> expression can raise runtime errors in two cases:</p>
<ul>
<li><code>"await: task handle lock poisoned"</code> — The <code>Mutex</code> guarding the result slot was poisoned (the spawned thread panicked while holding the lock).</li>
<li><code>"await: condvar wait failed"</code> — The condition variable wait failed.</li>
</ul>
<p>Both are exceptional conditions that indicate a serious runtime problem.</p>
<h2 id="comparison-with-hold"><a class="header" href="#comparison-with-hold">Comparison with hold</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Syntax</th><th>Keyword</th><th>Parsing</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>Classic</td><td><code>await expr</code></td><td><code>Expr::Await(expr)</code></td><td>Block until result</td></tr>
<tr><td>Natural</td><td><code>hold expr</code></td><td><code>Expr::Await(expr)</code></td><td>Block until result</td></tr>
</tbody>
</table>
</div>
<p>There is no semantic difference. Use whichever style matches your code’s convention.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="standard-library-overview"><a class="header" href="#standard-library-overview">Standard Library Overview</a></h1>
<p>Forge ships with <strong>16 built-in modules</strong> containing over 230 functions. All modules are available without any import statement. There is no <code>import math</code> or <code>require("fs")</code> – every module is pre-loaded into the global scope.</p>
<h2 id="accessing-modules"><a class="header" href="#accessing-modules">Accessing Modules</a></h2>
<p>Modules are accessed via dot notation:</p>
<pre><code class="language-forge">let root = math.sqrt(144)       // 12.0
let data = fs.read("config.json")
let hash = crypto.sha256("hello")
</code></pre>
<p>Each module is a first-class object. You can assign it to a variable:</p>
<pre><code class="language-forge">let m = math
say m.pi    // 3.141592653589793
</code></pre>
<h2 id="module-index"><a class="header" href="#module-index">Module Index</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Module</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#math"><code>math</code></a></td><td>Mathematical operations and constants</td><td>17</td></tr>
<tr><td><a href="#fs"><code>fs</code></a></td><td>File system operations</td><td>20</td></tr>
<tr><td><a href="#io"><code>io</code></a></td><td>Input/output and command-line arguments</td><td>6</td></tr>
<tr><td><a href="#crypto"><code>crypto</code></a></td><td>Hashing, encoding, and decoding</td><td>6</td></tr>
<tr><td><a href="#db"><code>db</code></a></td><td>SQLite database operations</td><td>4</td></tr>
<tr><td><a href="#pg"><code>pg</code></a></td><td>PostgreSQL database operations</td><td>4</td></tr>
<tr><td><a href="#json"><code>json</code></a></td><td>JSON parsing and serialization</td><td>3</td></tr>
<tr><td><a href="#csv"><code>csv</code></a></td><td>CSV parsing and serialization</td><td>4</td></tr>
<tr><td><a href="#regex"><code>regex</code></a></td><td>Regular expression matching</td><td>5</td></tr>
<tr><td><a href="#env"><code>env</code></a></td><td>Environment variables</td><td>4</td></tr>
<tr><td><a href="#log"><code>log</code></a></td><td>Structured logging with timestamps</td><td>4</td></tr>
<tr><td><a href="#term"><code>term</code></a></td><td>Terminal colors, formatting, and widgets</td><td>25+</td></tr>
<tr><td><a href="#http"><code>http</code></a></td><td>HTTP client and server decorators</td><td>9</td></tr>
<tr><td><a href="#exec"><code>exec</code></a></td><td>External command execution</td><td>1</td></tr>
<tr><td><a href="#time"><code>time</code></a></td><td>Date, time, and timezone operations</td><td>25</td></tr>
<tr><td><a href="#npc"><code>npc</code></a></td><td>Fake data generation for testing</td><td>16</td></tr>
</tbody>
</table>
</div>
<h2 id="execution-tier-support"><a class="header" href="#execution-tier-support">Execution Tier Support</a></h2>
<p>All modules are fully supported in the <strong>interpreter</strong> (default execution mode). The bytecode VM (<code>--vm</code>) and JIT (<code>--jit</code>) support a subset of modules – primarily <code>math</code>, <code>fs</code>, <code>io</code>, and <code>npc</code>. For full module access, use the interpreter.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="math"><a class="header" href="#math">math</a></h1>
<p>Mathematical operations and constants. All trigonometric functions use radians.</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td><code>math.pi</code></td><td><code>float</code></td><td>3.141592653589793</td></tr>
<tr><td><code>math.e</code></td><td><code>float</code></td><td>2.718281828459045</td></tr>
<tr><td><code>math.inf</code></td><td><code>float</code></td><td>Infinity</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">say math.pi    // 3.141592653589793
say math.e     // 2.718281828459045
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="mathsqrtn---float"><a class="header" href="#mathsqrtn---float">math.sqrt(n) -&gt; float</a></h3>
<p>Returns the square root of <code>n</code>.</p>
<pre><code class="language-forge">math.sqrt(144)   // 12.0
math.sqrt(2)     // 1.4142135623730951
</code></pre>
<h3 id="mathpowbase-exp---int--float"><a class="header" href="#mathpowbase-exp---int--float">math.pow(base, exp) -&gt; int | float</a></h3>
<p>Returns <code>base</code> raised to the power of <code>exp</code>. Returns <code>int</code> when both arguments are non-negative integers; returns <code>float</code> otherwise.</p>
<pre><code class="language-forge">math.pow(2, 10)    // 1024
math.pow(2.0, 0.5) // 1.4142135623730951
math.pow(2, -1)    // 0.5
</code></pre>
<h3 id="mathabsn---int--float"><a class="header" href="#mathabsn---int--float">math.abs(n) -&gt; int | float</a></h3>
<p>Returns the absolute value of <code>n</code>. Preserves the input type.</p>
<pre><code class="language-forge">math.abs(-42)    // 42
math.abs(-3.14)  // 3.14
</code></pre>
<h3 id="mathmaxa-b---int--float"><a class="header" href="#mathmaxa-b---int--float">math.max(a, b) -&gt; int | float</a></h3>
<p>Returns the greater of <code>a</code> and <code>b</code>.</p>
<pre><code class="language-forge">math.max(10, 20)     // 20
math.max(3.14, 2.71) // 3.14
</code></pre>
<h3 id="mathmina-b---int--float"><a class="header" href="#mathmina-b---int--float">math.min(a, b) -&gt; int | float</a></h3>
<p>Returns the lesser of <code>a</code> and <code>b</code>.</p>
<pre><code class="language-forge">math.min(10, 20)     // 10
math.min(3.14, 2.71) // 2.71
</code></pre>
<h3 id="mathfloorn---int"><a class="header" href="#mathfloorn---int">math.floor(n) -&gt; int</a></h3>
<p>Returns the largest integer less than or equal to <code>n</code>.</p>
<pre><code class="language-forge">math.floor(3.7)   // 3
math.floor(-1.2)  // -2
math.floor(5)     // 5
</code></pre>
<h3 id="mathceiln---int"><a class="header" href="#mathceiln---int">math.ceil(n) -&gt; int</a></h3>
<p>Returns the smallest integer greater than or equal to <code>n</code>.</p>
<pre><code class="language-forge">math.ceil(3.2)    // 4
math.ceil(-1.8)   // -1
math.ceil(5)      // 5
</code></pre>
<h3 id="mathroundn---int"><a class="header" href="#mathroundn---int">math.round(n) -&gt; int</a></h3>
<p>Returns the nearest integer to <code>n</code>, rounding half away from zero.</p>
<pre><code class="language-forge">math.round(3.5)   // 4
math.round(3.4)   // 3
math.round(-2.5)  // -3
</code></pre>
<h3 id="mathrandom---float"><a class="header" href="#mathrandom---float">math.random() -&gt; float</a></h3>
<p>Returns a pseudo-random float between 0.0 and 1.0 (exclusive).</p>
<pre><code class="language-forge">let r = math.random()  // e.g. 0.482371...
</code></pre>
<h3 id="mathrandom_intmin-max---int"><a class="header" href="#mathrandom_intmin-max---int">math.random_int(min, max) -&gt; int</a></h3>
<p>Returns a pseudo-random integer in the inclusive range <code>[min, max]</code>. Errors if <code>min &gt; max</code>.</p>
<pre><code class="language-forge">let die = math.random_int(1, 6)   // 1-6
let coin = math.random_int(0, 1)  // 0 or 1
</code></pre>
<h3 id="mathsinn---float"><a class="header" href="#mathsinn---float">math.sin(n) -&gt; float</a></h3>
<p>Returns the sine of <code>n</code> (in radians).</p>
<pre><code class="language-forge">math.sin(0)          // 0.0
math.sin(math.pi/2)  // 1.0
</code></pre>
<h3 id="mathcosn---float"><a class="header" href="#mathcosn---float">math.cos(n) -&gt; float</a></h3>
<p>Returns the cosine of <code>n</code> (in radians).</p>
<pre><code class="language-forge">math.cos(0)       // 1.0
math.cos(math.pi) // -1.0
</code></pre>
<h3 id="mathtann---float"><a class="header" href="#mathtann---float">math.tan(n) -&gt; float</a></h3>
<p>Returns the tangent of <code>n</code> (in radians).</p>
<pre><code class="language-forge">math.tan(0)          // 0.0
math.tan(math.pi/4)  // ~1.0
</code></pre>
<h3 id="mathlogn---float"><a class="header" href="#mathlogn---float">math.log(n) -&gt; float</a></h3>
<p>Returns the natural logarithm (base <em>e</em>) of <code>n</code>.</p>
<pre><code class="language-forge">math.log(1)       // 0.0
math.log(math.e)  // 1.0
</code></pre>
<h3 id="mathclampvalue-min-max---int--float"><a class="header" href="#mathclampvalue-min-max---int--float">math.clamp(value, min, max) -&gt; int | float</a></h3>
<p>Clamps <code>value</code> to the range <code>[min, max]</code>.</p>
<pre><code class="language-forge">math.clamp(5, 1, 10)    // 5
math.clamp(-5, 0, 10)   // 0
math.clamp(15, 0, 10)   // 10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fs"><a class="header" href="#fs">fs</a></h1>
<p>File system operations. All paths are strings. Functions that write to the file system return <code>null</code> on success.</p>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h3 id="fsreadpath---string"><a class="header" href="#fsreadpath---string">fs.read(path) -&gt; string</a></h3>
<p>Reads the entire file at <code>path</code> and returns its contents as a string.</p>
<pre><code class="language-forge">let content = fs.read("config.txt")
say content
</code></pre>
<h3 id="fswritepath-content---null"><a class="header" href="#fswritepath-content---null">fs.write(path, content) -&gt; null</a></h3>
<p>Writes <code>content</code> to the file at <code>path</code>, creating or overwriting the file.</p>
<pre><code class="language-forge">fs.write("output.txt", "Hello, world!")
</code></pre>
<h3 id="fsappendpath-content---null"><a class="header" href="#fsappendpath-content---null">fs.append(path, content) -&gt; null</a></h3>
<p>Appends <code>content</code> to the file at <code>path</code>. Creates the file if it does not exist.</p>
<pre><code class="language-forge">fs.append("log.txt", "New log entry\n")
</code></pre>
<h3 id="fsexistspath---bool"><a class="header" href="#fsexistspath---bool">fs.exists(path) -&gt; bool</a></h3>
<p>Returns <code>true</code> if a file or directory exists at <code>path</code>.</p>
<pre><code class="language-forge">if fs.exists("config.json") {
    say "Config found"
}
</code></pre>
<h3 id="fslistpath---array"><a class="header" href="#fslistpath---array">fs.list(path) -&gt; array</a></h3>
<p>Returns an array of file and directory names in the directory at <code>path</code>. Names only, not full paths.</p>
<pre><code class="language-forge">let files = fs.list("./src")
// ["main.fg", "utils.fg", "lib"]
</code></pre>
<h3 id="fsremovepath---null"><a class="header" href="#fsremovepath---null">fs.remove(path) -&gt; null</a></h3>
<p>Deletes a file or directory (recursively) at <code>path</code>.</p>
<pre><code class="language-forge">fs.remove("temp.txt")
fs.remove("build/")     // removes directory and all contents
</code></pre>
<h3 id="fsmkdirpath---null"><a class="header" href="#fsmkdirpath---null">fs.mkdir(path) -&gt; null</a></h3>
<p>Creates the directory at <code>path</code>, including any necessary parent directories.</p>
<pre><code class="language-forge">fs.mkdir("build/output/logs")
</code></pre>
<h3 id="fscopysource-destination---int"><a class="header" href="#fscopysource-destination---int">fs.copy(source, destination) -&gt; int</a></h3>
<p>Copies a file from <code>source</code> to <code>destination</code>. Returns the number of bytes copied.</p>
<pre><code class="language-forge">let bytes = fs.copy("original.txt", "backup.txt")
say bytes  // e.g. 1024
</code></pre>
<h3 id="fsrenameold_path-new_path---null"><a class="header" href="#fsrenameold_path-new_path---null">fs.rename(old_path, new_path) -&gt; null</a></h3>
<p>Renames or moves a file or directory.</p>
<pre><code class="language-forge">fs.rename("draft.txt", "final.txt")
</code></pre>
<h3 id="fssizepath---int"><a class="header" href="#fssizepath---int">fs.size(path) -&gt; int</a></h3>
<p>Returns the size of the file at <code>path</code> in bytes.</p>
<pre><code class="language-forge">let s = fs.size("data.bin")
say s  // e.g. 4096
</code></pre>
<h3 id="fsextpath---string"><a class="header" href="#fsextpath---string">fs.ext(path) -&gt; string</a></h3>
<p>Returns the file extension without the leading dot. Returns an empty string if none.</p>
<pre><code class="language-forge">fs.ext("photo.png")     // "png"
fs.ext("Makefile")      // ""
</code></pre>
<h3 id="fsread_jsonpath---any"><a class="header" href="#fsread_jsonpath---any">fs.read_json(path) -&gt; any</a></h3>
<p>Reads a JSON file and returns the parsed Forge value (object, array, etc.).</p>
<pre><code class="language-forge">let config = fs.read_json("config.json")
say config.name
</code></pre>
<h3 id="fswrite_jsonpath-value---null"><a class="header" href="#fswrite_jsonpath-value---null">fs.write_json(path, value) -&gt; null</a></h3>
<p>Serializes <code>value</code> as pretty-printed JSON and writes it to <code>path</code>.</p>
<pre><code class="language-forge">let data = { name: "forge", version: "0.3.3" }
fs.write_json("package.json", data)
</code></pre>
<h3 id="fslinespath---array"><a class="header" href="#fslinespath---array">fs.lines(path) -&gt; array</a></h3>
<p>Reads a file and returns an array of strings, one per line.</p>
<pre><code class="language-forge">let lines = fs.lines("data.csv")
say len(lines)  // number of lines
</code></pre>
<h3 id="fsdirnamepath---string"><a class="header" href="#fsdirnamepath---string">fs.dirname(path) -&gt; string</a></h3>
<p>Returns the directory portion of <code>path</code>.</p>
<pre><code class="language-forge">fs.dirname("/home/user/file.txt")  // "/home/user"
</code></pre>
<h3 id="fsbasenamepath---string"><a class="header" href="#fsbasenamepath---string">fs.basename(path) -&gt; string</a></h3>
<p>Returns the file name portion of <code>path</code>.</p>
<pre><code class="language-forge">fs.basename("/home/user/file.txt")  // "file.txt"
</code></pre>
<h3 id="fsjoin_patha-b---string"><a class="header" href="#fsjoin_patha-b---string">fs.join_path(a, b) -&gt; string</a></h3>
<p>Joins two path segments with the platform path separator.</p>
<pre><code class="language-forge">fs.join_path("/home", "user")  // "/home/user"
</code></pre>
<h3 id="fsis_dirpath---bool"><a class="header" href="#fsis_dirpath---bool">fs.is_dir(path) -&gt; bool</a></h3>
<p>Returns <code>true</code> if <code>path</code> is a directory.</p>
<pre><code class="language-forge">fs.is_dir("/tmp")      // true
fs.is_dir("file.txt")  // false
</code></pre>
<h3 id="fsis_filepath---bool"><a class="header" href="#fsis_filepath---bool">fs.is_file(path) -&gt; bool</a></h3>
<p>Returns <code>true</code> if <code>path</code> is a regular file.</p>
<pre><code class="language-forge">fs.is_file("main.fg")  // true
fs.is_file("/tmp")      // false
</code></pre>
<h3 id="fstemp_dir---string"><a class="header" href="#fstemp_dir---string">fs.temp_dir() -&gt; string</a></h3>
<p>Returns the path to the system temporary directory.</p>
<pre><code class="language-forge">let tmp = fs.temp_dir()
say tmp  // e.g. "/tmp"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crypto"><a class="header" href="#crypto">crypto</a></h1>
<p>Hashing and encoding utilities. All functions accept and return strings.</p>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<h3 id="cryptosha256input---string"><a class="header" href="#cryptosha256input---string">crypto.sha256(input) -&gt; string</a></h3>
<p>Returns the SHA-256 hash of <code>input</code> as a lowercase hex string.</p>
<pre><code class="language-forge">crypto.sha256("hello")
// "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
</code></pre>
<h3 id="cryptomd5input---string"><a class="header" href="#cryptomd5input---string">crypto.md5(input) -&gt; string</a></h3>
<p>Returns the MD5 hash of <code>input</code> as a lowercase hex string.</p>
<pre><code class="language-forge">crypto.md5("hello")
// "5d41402abc4b2a76b9719d911017c592"
</code></pre>
<blockquote>
<p><strong>Note:</strong> MD5 is cryptographically broken. Use <code>crypto.sha256</code> for security-sensitive hashing. MD5 is provided for compatibility and checksums only.</p>
</blockquote>
<h3 id="cryptobase64_encodeinput---string"><a class="header" href="#cryptobase64_encodeinput---string">crypto.base64_encode(input) -&gt; string</a></h3>
<p>Encodes <code>input</code> as a Base64 string using the standard alphabet.</p>
<pre><code class="language-forge">crypto.base64_encode("hello world")
// "aGVsbG8gd29ybGQ="
</code></pre>
<h3 id="cryptobase64_decodeinput---string"><a class="header" href="#cryptobase64_decodeinput---string">crypto.base64_decode(input) -&gt; string</a></h3>
<p>Decodes a Base64 string back to its original form.</p>
<pre><code class="language-forge">crypto.base64_decode("aGVsbG8gd29ybGQ=")
// "hello world"
</code></pre>
<h3 id="cryptohex_encodeinput---string"><a class="header" href="#cryptohex_encodeinput---string">crypto.hex_encode(input) -&gt; string</a></h3>
<p>Encodes <code>input</code> as a hexadecimal string.</p>
<pre><code class="language-forge">crypto.hex_encode("AB")
// "4142"
</code></pre>
<h3 id="cryptohex_decodeinput---string"><a class="header" href="#cryptohex_decodeinput---string">crypto.hex_decode(input) -&gt; string</a></h3>
<p>Decodes a hexadecimal string back to its original form.</p>
<pre><code class="language-forge">crypto.hex_decode("4142")
// "AB"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="db"><a class="header" href="#db">db</a></h1>
<p>SQLite database operations. Forge embeds SQLite via the <code>rusqlite</code> crate. One connection is maintained per thread.</p>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<h3 id="dbopenpath---bool"><a class="header" href="#dbopenpath---bool">db.open(path) -&gt; bool</a></h3>
<p>Opens a SQLite database at <code>path</code>. Use <code>":memory:"</code> for an in-memory database. Returns <code>true</code> on success.</p>
<pre><code class="language-forge">db.open(":memory:")
db.open("app.db")
</code></pre>
<h3 id="dbexecutesql-params---null"><a class="header" href="#dbexecutesql-params---null">db.execute(sql, params?) -&gt; null</a></h3>
<p>Executes a SQL statement that does not return rows (CREATE, INSERT, UPDATE, DELETE). An optional second argument provides parameterized values as an array, using <code>?</code> placeholders.</p>
<pre><code class="language-forge">db.execute("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)")

// Parameterized insert (recommended)
db.execute("INSERT INTO users VALUES (?, ?, ?)", [1, "Alice", "alice@example.com"])

// Batch execution (no params)
db.execute("INSERT INTO users VALUES (2, 'Bob', 'bob@example.com')")
</code></pre>
<h3 id="dbquerysql-params---array"><a class="header" href="#dbquerysql-params---array">db.query(sql, params?) -&gt; array</a></h3>
<p>Executes a SQL SELECT query and returns an array of objects. Each object maps column names to values. An optional second argument provides parameterized values.</p>
<pre><code class="language-forge">let users = db.query("SELECT * FROM users")
// [{id: 1, name: "Alice", email: "alice@example.com"}, ...]

// Parameterized query
let result = db.query("SELECT * FROM users WHERE id = ?", [1])
say result[0].name  // "Alice"
</code></pre>
<h3 id="dbclose---null"><a class="header" href="#dbclose---null">db.close() -&gt; null</a></h3>
<p>Closes the current database connection.</p>
<pre><code class="language-forge">db.close()
</code></pre>
<h2 id="full-crud-example"><a class="header" href="#full-crud-example">Full CRUD Example</a></h2>
<pre><code class="language-forge">// Open database
db.open(":memory:")

// Create table
db.execute("CREATE TABLE tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    done INTEGER DEFAULT 0
)")

// Create
db.execute("INSERT INTO tasks (title) VALUES (?)", ["Buy groceries"])
db.execute("INSERT INTO tasks (title) VALUES (?)", ["Write documentation"])
db.execute("INSERT INTO tasks (title) VALUES (?)", ["Deploy v2"])

// Read
let all_tasks = db.query("SELECT * FROM tasks")
say all_tasks

let pending = db.query("SELECT * FROM tasks WHERE done = ?", [0])
say len(pending)  // 3

// Update
db.execute("UPDATE tasks SET done = ? WHERE id = ?", [1, 1])

// Delete
db.execute("DELETE FROM tasks WHERE id = ?", [3])

// Verify
let remaining = db.query("SELECT * FROM tasks")
say remaining

// Close
db.close()
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>SQLite types map to Forge types: INTEGER -&gt; <code>int</code>, REAL -&gt; <code>float</code>, TEXT -&gt; <code>string</code>, NULL -&gt; <code>null</code>, BLOB -&gt; <code>string</code> (as <code>&lt;blob N bytes&gt;</code>).</li>
<li>Parameterized queries (using <code>?</code> placeholders with an array) are the recommended approach to prevent SQL injection.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pg"><a class="header" href="#pg">pg</a></h1>
<p>PostgreSQL database operations. Requires a running PostgreSQL server. Uses <code>tokio-postgres</code> under the hood and requires the async runtime (interpreter mode).</p>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<h3 id="pgconnectconnection_string---bool"><a class="header" href="#pgconnectconnection_string---bool">pg.connect(connection_string) -&gt; bool</a></h3>
<p>Connects to a PostgreSQL database. Returns <code>true</code> on success. The connection string follows the standard PostgreSQL format.</p>
<pre><code class="language-forge">pg.connect("host=localhost user=postgres password=secret dbname=myapp")
</code></pre>
<h3 id="pgquerysql---array"><a class="header" href="#pgquerysql---array">pg.query(sql) -&gt; array</a></h3>
<p>Executes a SQL SELECT query and returns an array of objects. Each object maps column names to values.</p>
<pre><code class="language-forge">let users = pg.query("SELECT id, name, email FROM users")
for user in users {
    say user.name
}
</code></pre>
<h3 id="pgexecutesql---int"><a class="header" href="#pgexecutesql---int">pg.execute(sql) -&gt; int</a></h3>
<p>Executes a SQL statement that does not return rows. Returns the number of rows affected.</p>
<pre><code class="language-forge">let count = pg.execute("UPDATE users SET active = true WHERE last_login &gt; now() - interval '30 days'")
say count  // number of rows updated
</code></pre>
<h3 id="pgclose---null"><a class="header" href="#pgclose---null">pg.close() -&gt; null</a></h3>
<p>Closes the current PostgreSQL connection.</p>
<pre><code class="language-forge">pg.close()
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-forge">pg.connect("host=localhost dbname=shop user=postgres")

pg.execute("CREATE TABLE IF NOT EXISTS products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC(10,2)
)")

pg.execute("INSERT INTO products (name, price) VALUES ('Widget', 9.99)")
pg.execute("INSERT INTO products (name, price) VALUES ('Gadget', 24.99)")

let products = pg.query("SELECT * FROM products ORDER BY price")
for p in products {
    say p.name + " - $" + str(p.price)
}

pg.close()
</code></pre>
<h2 id="notes-1"><a class="header" href="#notes-1">Notes</a></h2>
<ul>
<li>PostgreSQL types map to Forge types: <code>integer</code>/<code>bigint</code> -&gt; <code>int</code>, <code>real</code>/<code>double precision</code>/<code>numeric</code> -&gt; <code>float</code>, <code>text</code>/<code>varchar</code> -&gt; <code>string</code>, <code>boolean</code> -&gt; <code>bool</code>, NULL -&gt; <code>null</code>.</li>
<li>The <code>pg</code> module requires the interpreter (default) execution mode. It is not available in the VM or JIT tiers.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="json"><a class="header" href="#json">json</a></h1>
<p>JSON parsing and serialization.</p>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<h3 id="jsonparsestring---any"><a class="header" href="#jsonparsestring---any">json.parse(string) -&gt; any</a></h3>
<p>Parses a JSON string and returns the corresponding Forge value. Objects become Forge objects, arrays become Forge arrays, and JSON primitives map to their Forge equivalents.</p>
<pre><code class="language-forge">let data = json.parse('{"name": "Forge", "version": 3}')
say data.name     // "Forge"
say data.version   // 3

let arr = json.parse("[1, 2, 3]")
say arr[0]  // 1
</code></pre>
<h3 id="jsonstringifyvalue---string"><a class="header" href="#jsonstringifyvalue---string">json.stringify(value) -&gt; string</a></h3>
<p>Serializes a Forge value into a compact JSON string (no extra whitespace).</p>
<pre><code class="language-forge">let obj = { name: "Forge", tags: ["fast", "fun"] }
let s = json.stringify(obj)
say s  // {"name": "Forge", "tags": ["fast", "fun"]}
</code></pre>
<h3 id="jsonprettyvalue-indent---string"><a class="header" href="#jsonprettyvalue-indent---string">json.pretty(value, indent?) -&gt; string</a></h3>
<p>Serializes a Forge value into a pretty-printed JSON string. The optional <code>indent</code> parameter specifies the number of spaces per indentation level (default: 2).</p>
<pre><code class="language-forge">let obj = { name: "Forge", version: 3 }
say json.pretty(obj)
// {
//   "name": "Forge",
//   "version": 3
// }

say json.pretty(obj, 4)
// {
//     "name": "Forge",
//     "version": 3
// }
</code></pre>
<h2 id="type-mapping"><a class="header" href="#type-mapping">Type Mapping</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>JSON</th><th>Forge</th></tr>
</thead>
<tbody>
<tr><td><code>null</code></td><td><code>null</code></td></tr>
<tr><td><code>true</code> / <code>false</code></td><td><code>bool</code></td></tr>
<tr><td>integer number</td><td><code>int</code></td></tr>
<tr><td>floating-point number</td><td><code>float</code></td></tr>
<tr><td><code>"string"</code></td><td><code>string</code></td></tr>
<tr><td><code>[...]</code></td><td><code>array</code></td></tr>
<tr><td><code>{...}</code></td><td><code>object</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="csv"><a class="header" href="#csv">csv</a></h1>
<p>CSV parsing and serialization. Uses comma-separated values with automatic type inference for fields.</p>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<h3 id="csvparsestring---array"><a class="header" href="#csvparsestring---array">csv.parse(string) -&gt; array</a></h3>
<p>Parses a CSV string into an array of objects. The first line is treated as headers. Values are automatically converted to <code>int</code>, <code>float</code>, or <code>bool</code> where possible; otherwise they remain strings.</p>
<pre><code class="language-forge">let data = csv.parse("name,age,active\nAlice,30,true\nBob,25,false")
say data[0].name    // "Alice"
say data[0].age     // 30
say data[1].active  // false
</code></pre>
<h3 id="csvstringifyrows---string"><a class="header" href="#csvstringifyrows---string">csv.stringify(rows) -&gt; string</a></h3>
<p>Converts an array of objects into a CSV string. Headers are derived from the keys of the first object.</p>
<pre><code class="language-forge">let rows = [
    { name: "Alice", age: 30 },
    { name: "Bob", age: 25 }
]
let output = csv.stringify(rows)
say output
// name,age
// Alice,30
// Bob,25
</code></pre>
<p>Values containing commas or quotes are automatically quoted.</p>
<h3 id="csvreadpath---array"><a class="header" href="#csvreadpath---array">csv.read(path) -&gt; array</a></h3>
<p>Reads a CSV file from disk and parses it into an array of objects. Equivalent to <code>csv.parse(fs.read(path))</code>.</p>
<pre><code class="language-forge">let users = csv.read("users.csv")
for user in users {
    say user.name + ": " + str(user.email)
}
</code></pre>
<h3 id="csvwritepath-rows---null"><a class="header" href="#csvwritepath-rows---null">csv.write(path, rows) -&gt; null</a></h3>
<p>Serializes an array of objects as CSV and writes it to the file at <code>path</code>.</p>
<pre><code class="language-forge">let data = [
    { product: "Widget", price: 9.99, qty: 100 },
    { product: "Gadget", price: 24.99, qty: 50 }
]
csv.write("inventory.csv", data)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="regex"><a class="header" href="#regex">regex</a></h1>
<p>Regular expression operations. Uses Rust’s <code>regex</code> crate syntax.</p>
<blockquote>
<p><strong>Important:</strong> All <code>regex</code> functions take the <strong>text first, pattern second</strong>: <code>regex.test(text, pattern)</code>. This is the opposite of many other languages.</p>
</blockquote>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<h3 id="regextesttext-pattern---bool"><a class="header" href="#regextesttext-pattern---bool">regex.test(text, pattern) -&gt; bool</a></h3>
<p>Returns <code>true</code> if <code>pattern</code> matches anywhere in <code>text</code>.</p>
<pre><code class="language-forge">regex.test("hello world", "world")     // true
regex.test("hello world", "^world")    // false
regex.test("abc123", "\\d+")           // true
</code></pre>
<h3 id="regexfindtext-pattern---string--null"><a class="header" href="#regexfindtext-pattern---string--null">regex.find(text, pattern) -&gt; string | null</a></h3>
<p>Returns the first match of <code>pattern</code> in <code>text</code>, or <code>null</code> if no match.</p>
<pre><code class="language-forge">regex.find("order-4521-confirmed", "\\d+")  // "4521"
regex.find("no numbers here", "\\d+")       // null
</code></pre>
<h3 id="regexfind_alltext-pattern---array"><a class="header" href="#regexfind_alltext-pattern---array">regex.find_all(text, pattern) -&gt; array</a></h3>
<p>Returns an array of all non-overlapping matches of <code>pattern</code> in <code>text</code>.</p>
<pre><code class="language-forge">regex.find_all("call 555-1234 or 555-5678", "\\d{3}-\\d{4}")
// ["555-1234", "555-5678"]

regex.find_all("aabbaab", "a+")
// ["aa", "aa"]
</code></pre>
<h3 id="regexreplacetext-pattern-replacement---string"><a class="header" href="#regexreplacetext-pattern-replacement---string">regex.replace(text, pattern, replacement) -&gt; string</a></h3>
<p>Replaces all occurrences of <code>pattern</code> in <code>text</code> with <code>replacement</code>.</p>
<pre><code class="language-forge">regex.replace("hello world", "world", "Forge")
// "hello Forge"

regex.replace("2024-01-15", "(\\d{4})-(\\d{2})-(\\d{2})", "$2/$3/$1")
// "01/15/2024"
</code></pre>
<p>The <code>replacement</code> string supports capture group references (<code>$1</code>, <code>$2</code>, etc.).</p>
<h3 id="regexsplittext-pattern---array"><a class="header" href="#regexsplittext-pattern---array">regex.split(text, pattern) -&gt; array</a></h3>
<p>Splits <code>text</code> by occurrences of <code>pattern</code> and returns an array of substrings.</p>
<pre><code class="language-forge">regex.split("one,,two,,,three", ",+")
// ["one", "two", "three"]

regex.split("hello   world  foo", "\\s+")
// ["hello", "world", "foo"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="env"><a class="header" href="#env">env</a></h1>
<p>Environment variable access.</p>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<h3 id="envgetkey-default---string--null"><a class="header" href="#envgetkey-default---string--null">env.get(key, default?) -&gt; string | null</a></h3>
<p>Returns the value of the environment variable <code>key</code>. Returns <code>null</code> if the variable is not set, or <code>default</code> if provided.</p>
<pre><code class="language-forge">let home = env.get("HOME")
say home  // "/Users/alice"

let port = env.get("PORT", "8080")
say port  // "8080" if PORT is not set
</code></pre>
<h3 id="envsetkey-value---null"><a class="header" href="#envsetkey-value---null">env.set(key, value) -&gt; null</a></h3>
<p>Sets the environment variable <code>key</code> to <code>value</code> for the current process.</p>
<pre><code class="language-forge">env.set("APP_MODE", "production")
</code></pre>
<h3 id="envhaskey---bool"><a class="header" href="#envhaskey---bool">env.has(key) -&gt; bool</a></h3>
<p>Returns <code>true</code> if the environment variable <code>key</code> is set.</p>
<pre><code class="language-forge">if env.has("DATABASE_URL") {
    say "Database configured"
}
</code></pre>
<h3 id="envkeys---array"><a class="header" href="#envkeys---array">env.keys() -&gt; array</a></h3>
<p>Returns an array of all environment variable names.</p>
<pre><code class="language-forge">let all_keys = env.keys()
say len(all_keys)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="log"><a class="header" href="#log">log</a></h1>
<p>Structured logging with timestamps and severity levels. All log output is written to stderr with ANSI color formatting.</p>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<h3 id="loginfoargs---null"><a class="header" href="#loginfoargs---null">log.info(…args) -&gt; null</a></h3>
<p>Logs an informational message in green.</p>
<pre><code class="language-forge">log.info("Server started on port", 8080)
// [14:30:15 INFO]  Server started on port 8080
</code></pre>
<h3 id="logwarnargs---null"><a class="header" href="#logwarnargs---null">log.warn(…args) -&gt; null</a></h3>
<p>Logs a warning message in yellow.</p>
<pre><code class="language-forge">log.warn("Disk usage above 80%")
// [14:30:15 WARN]  Disk usage above 80%
</code></pre>
<h3 id="logerrorargs---null"><a class="header" href="#logerrorargs---null">log.error(…args) -&gt; null</a></h3>
<p>Logs an error message in red.</p>
<pre><code class="language-forge">log.error("Failed to connect to database:", err)
// [14:30:15 ERROR] Failed to connect to database: connection refused
</code></pre>
<h3 id="logdebugargs---null"><a class="header" href="#logdebugargs---null">log.debug(…args) -&gt; null</a></h3>
<p>Logs a debug message in gray. Useful for development diagnostics.</p>
<pre><code class="language-forge">log.debug("Request payload:", data)
// [14:30:15 DEBUG] Request payload: {name: "Alice"}
</code></pre>
<h2 id="notes-2"><a class="header" href="#notes-2">Notes</a></h2>
<ul>
<li>All functions accept any number of arguments. Arguments are converted to strings and joined with spaces.</li>
<li>Timestamps use the local time in <code>HH:MM:SS</code> format.</li>
<li>Output goes to stderr, not stdout, so it does not interfere with piped output.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="term"><a class="header" href="#term">term</a></h1>
<p>Terminal formatting, colors, and UI widgets. Color functions return styled strings; display functions print to stderr and return <code>null</code>.</p>
<h2 id="color-functions"><a class="header" href="#color-functions">Color Functions</a></h2>
<p>Each color function wraps text in ANSI escape codes and returns the styled string.</p>
<h3 id="termredtext---string"><a class="header" href="#termredtext---string">term.red(text) -&gt; string</a></h3>
<h3 id="termgreentext---string"><a class="header" href="#termgreentext---string">term.green(text) -&gt; string</a></h3>
<h3 id="termbluetext---string"><a class="header" href="#termbluetext---string">term.blue(text) -&gt; string</a></h3>
<h3 id="termyellowtext---string"><a class="header" href="#termyellowtext---string">term.yellow(text) -&gt; string</a></h3>
<h3 id="termcyantext---string"><a class="header" href="#termcyantext---string">term.cyan(text) -&gt; string</a></h3>
<h3 id="termmagentatext---string"><a class="header" href="#termmagentatext---string">term.magenta(text) -&gt; string</a></h3>
<pre><code class="language-forge">say term.red("Error!")
say term.green("Success!")
say term.blue("Info")
</code></pre>
<h3 id="termboldtext---string"><a class="header" href="#termboldtext---string">term.bold(text) -&gt; string</a></h3>
<h3 id="termdimtext---string"><a class="header" href="#termdimtext---string">term.dim(text) -&gt; string</a></h3>
<pre><code class="language-forge">say term.bold("Important")
say term.dim("subtle note")
</code></pre>
<h2 id="display-functions"><a class="header" href="#display-functions">Display Functions</a></h2>
<h3 id="termtablerows---null"><a class="header" href="#termtablerows---null">term.table(rows) -&gt; null</a></h3>
<p>Prints a formatted table from an array of objects. Column widths are auto-calculated. Headers come from the keys of the first object.</p>
<pre><code class="language-forge">let data = [
    { name: "Alice", role: "Admin", active: true },
    { name: "Bob", role: "User", active: false }
]
term.table(data)
// name  | role  | active
// ------+-------+-------
// Alice | Admin | true
// Bob   | User  | false
</code></pre>
<h3 id="termhrwidth-char---null"><a class="header" href="#termhrwidth-char---null">term.hr(width?, char?) -&gt; null</a></h3>
<p>Prints a horizontal rule. Default width is 40, default character is <code>"─"</code>.</p>
<pre><code class="language-forge">term.hr()         // ────────────────────────────────────────
term.hr(20)       // ────────────────────
term.hr(20, "=")  // ====================
</code></pre>
<h3 id="termbannertext---null"><a class="header" href="#termbannertext---null">term.banner(text) -&gt; null</a></h3>
<p>Prints text in a double-line box.</p>
<pre><code class="language-forge">term.banner("Forge v0.3.3")
// ╔════════════════╗
// ║  Forge v0.3.3  ║
// ╚════════════════╝
</code></pre>
<h3 id="termboxtext---null"><a class="header" href="#termboxtext---null">term.box(text) -&gt; null</a></h3>
<p>Prints text in a single-line box. Supports multi-line text.</p>
<pre><code class="language-forge">term.box("Hello\nWorld")
// ┌───────┐
// │ Hello │
// │ World │
// └───────┘
</code></pre>
<h3 id="termbarlabel-value-max---null"><a class="header" href="#termbarlabel-value-max---null">term.bar(label, value, max?) -&gt; null</a></h3>
<p>Prints a progress bar. Default <code>max</code> is 100.</p>
<pre><code class="language-forge">term.bar("CPU", 73, 100)
//   CPU [██████████████████████░░░░░░░░] 73%
</code></pre>
<h3 id="termsparklinenumbers---string"><a class="header" href="#termsparklinenumbers---string">term.sparkline(numbers) -&gt; string</a></h3>
<p>Returns a sparkline string from an array of numbers using Unicode block characters.</p>
<pre><code class="language-forge">let spark = term.sparkline([1, 5, 3, 8, 2, 7, 4, 6])
say spark  // ▁▅▃█▂▇▃▆
</code></pre>
<h3 id="termgradienttext---string"><a class="header" href="#termgradienttext---string">term.gradient(text) -&gt; string</a></h3>
<p>Returns text with a rainbow gradient using 256-color ANSI codes.</p>
<pre><code class="language-forge">say term.gradient("Hello, Forge!")
</code></pre>
<h3 id="termsuccessmessage---null"><a class="header" href="#termsuccessmessage---null">term.success(message) -&gt; null</a></h3>
<p>Prints a green success message with a checkmark.</p>
<pre><code class="language-forge">term.success("Build complete")
//   ✅ Build complete
</code></pre>
<h3 id="termerrormessage---null"><a class="header" href="#termerrormessage---null">term.error(message) -&gt; null</a></h3>
<p>Prints a red error message with an X mark.</p>
<pre><code class="language-forge">term.error("Compilation failed")
//   ❌ Compilation failed
</code></pre>
<h3 id="termwarningmessage---null"><a class="header" href="#termwarningmessage---null">term.warning(message) -&gt; null</a></h3>
<p>Prints a yellow warning message.</p>
<pre><code class="language-forge">term.warning("Deprecated API usage")
</code></pre>
<h3 id="terminfomessage---null"><a class="header" href="#terminfomessage---null">term.info(message) -&gt; null</a></h3>
<p>Prints a cyan info message.</p>
<pre><code class="language-forge">term.info("3 files processed")
</code></pre>
<h3 id="termclear---null"><a class="header" href="#termclear---null">term.clear() -&gt; null</a></h3>
<p>Clears the terminal screen.</p>
<h3 id="termconfirmprompt---bool"><a class="header" href="#termconfirmprompt---bool">term.confirm(prompt?) -&gt; bool</a></h3>
<p>Prints a yes/no prompt and returns <code>true</code> if the user enters “y” or “yes”.</p>
<pre><code class="language-forge">if term.confirm("Delete all files?") {
    fs.remove("output/")
}
</code></pre>
<h3 id="termmenuoptions-prompt---any"><a class="header" href="#termmenuoptions-prompt---any">term.menu(options, prompt?) -&gt; any</a></h3>
<p>Displays a numbered menu and returns the selected item.</p>
<pre><code class="language-forge">let choice = term.menu(["New Project", "Open Project", "Quit"])
say choice
</code></pre>
<h3 id="termcountdownseconds---null"><a class="header" href="#termcountdownseconds---null">term.countdown(seconds?) -&gt; null</a></h3>
<p>Displays an animated countdown. Default is 3 seconds.</p>
<pre><code class="language-forge">term.countdown(5)
</code></pre>
<h3 id="termtypewritertext-delay---null"><a class="header" href="#termtypewritertext-delay---null">term.typewriter(text, delay?) -&gt; null</a></h3>
<p>Prints text one character at a time. Default delay is 30ms per character.</p>
<pre><code class="language-forge">term.typewriter("Loading system...", 50)
</code></pre>
<h3 id="termemojiname---string"><a class="header" href="#termemojiname---string">term.emoji(name) -&gt; string</a></h3>
<p>Returns an emoji by name. Use <code>term.emojis()</code> to list all available names.</p>
<pre><code class="language-forge">say term.emoji("rocket")  // 🚀
say term.emoji("check")   // ✅
say term.emoji("fire")    // 🔥
</code></pre>
<h3 id="termbeep---null"><a class="header" href="#termbeep---null">term.beep() -&gt; null</a></h3>
<p>Plays the terminal bell sound.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="http"><a class="header" href="#http">http</a></h1>
<p>HTTP client for making requests and a decorator-based HTTP server built on axum + tokio.</p>
<h2 id="client-functions"><a class="header" href="#client-functions">Client Functions</a></h2>
<p>All client functions return a response object with the following fields:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>status</code></td><td><code>int</code></td><td>HTTP status code</td></tr>
<tr><td><code>body</code></td><td><code>string</code></td><td>Raw response body</td></tr>
<tr><td><code>json</code></td><td><code>any</code></td><td>Parsed JSON body (if applicable)</td></tr>
<tr><td><code>headers</code></td><td><code>object</code></td><td>Response headers</td></tr>
<tr><td><code>url</code></td><td><code>string</code></td><td>Final URL (after redirects)</td></tr>
<tr><td><code>time</code></td><td><code>int</code></td><td>Response time in milliseconds</td></tr>
<tr><td><code>method</code></td><td><code>string</code></td><td>HTTP method used</td></tr>
</tbody>
</table>
</div>
<h3 id="httpgeturl-options---object"><a class="header" href="#httpgeturl-options---object">http.get(url, options?) -&gt; object</a></h3>
<p>Sends an HTTP GET request.</p>
<pre><code class="language-forge">let resp = http.get("https://api.example.com/users")
say resp.status  // 200
say resp.json    // [{id: 1, name: "Alice"}, ...]
</code></pre>
<h3 id="httpposturl-options---object"><a class="header" href="#httpposturl-options---object">http.post(url, options?) -&gt; object</a></h3>
<p>Sends an HTTP POST request.</p>
<pre><code class="language-forge">let resp = http.post("https://api.example.com/users", {
    body: { name: "Alice", email: "alice@example.com" }
})
say resp.status  // 201
</code></pre>
<h3 id="httpputurl-options---object"><a class="header" href="#httpputurl-options---object">http.put(url, options?) -&gt; object</a></h3>
<p>Sends an HTTP PUT request.</p>
<pre><code class="language-forge">let resp = http.put("https://api.example.com/users/1", {
    body: { name: "Alice Updated" }
})
</code></pre>
<h3 id="httpdeleteurl-options---object"><a class="header" href="#httpdeleteurl-options---object">http.delete(url, options?) -&gt; object</a></h3>
<p>Sends an HTTP DELETE request.</p>
<pre><code class="language-forge">let resp = http.delete("https://api.example.com/users/1")
say resp.status  // 204
</code></pre>
<h3 id="httppatchurl-options---object"><a class="header" href="#httppatchurl-options---object">http.patch(url, options?) -&gt; object</a></h3>
<p>Sends an HTTP PATCH request.</p>
<pre><code class="language-forge">let resp = http.patch("https://api.example.com/users/1", {
    body: { active: false }
})
</code></pre>
<h3 id="httpheadurl-options---object"><a class="header" href="#httpheadurl-options---object">http.head(url, options?) -&gt; object</a></h3>
<p>Sends an HTTP HEAD request (headers only, no body).</p>
<pre><code class="language-forge">let resp = http.head("https://example.com")
say resp.status
</code></pre>
<h3 id="options-object"><a class="header" href="#options-object">Options Object</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>body</code></td><td><code>any</code></td><td>Request body (auto-serialized as JSON)</td></tr>
<tr><td><code>headers</code></td><td><code>object</code></td><td>Custom request headers</td></tr>
<tr><td><code>auth</code></td><td><code>string</code></td><td>Bearer token (sets <code>Authorization: Bearer &lt;token&gt;</code>)</td></tr>
<tr><td><code>timeout</code></td><td><code>int</code></td><td>Timeout in seconds (default: 30)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let resp = http.get("https://api.example.com/me", {
    auth: "my-secret-token",
    headers: { "Accept": "application/json" },
    timeout: 10
})
</code></pre>
<h3 id="httpdownloadurl-destination---object"><a class="header" href="#httpdownloadurl-destination---object">http.download(url, destination?) -&gt; object</a></h3>
<p>Downloads a file from <code>url</code> and saves it to <code>destination</code>. If no destination is provided, the filename is derived from the URL. Returns an object with <code>path</code>, <code>size</code>, and <code>status</code>.</p>
<pre><code class="language-forge">let result = http.download("https://example.com/data.zip", "data.zip")
say result.size  // bytes downloaded
</code></pre>
<h3 id="httpcrawlurl---object"><a class="header" href="#httpcrawlurl---object">http.crawl(url) -&gt; object</a></h3>
<p>Fetches a web page and extracts structured data. Returns an object with:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>string</code></td><td>The URL crawled</td></tr>
<tr><td><code>status</code></td><td><code>int</code></td><td>HTTP status code</td></tr>
<tr><td><code>title</code></td><td><code>string</code></td><td>Page title</td></tr>
<tr><td><code>description</code></td><td><code>string</code></td><td>Meta description</td></tr>
<tr><td><code>links</code></td><td><code>array</code></td><td>Array of absolute URLs found in href attributes</td></tr>
<tr><td><code>text</code></td><td><code>string</code></td><td>Visible text content (first 500 characters)</td></tr>
<tr><td><code>html_length</code></td><td><code>int</code></td><td>Total HTML length in characters</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let page = http.crawl("https://example.com")
say page.title
say len(page.links)
</code></pre>
<h3 id="httpprettyresponse---null"><a class="header" href="#httpprettyresponse---null">http.pretty(response) -&gt; null</a></h3>
<p>Pretty-prints an HTTP response object to stderr with color formatting.</p>
<pre><code class="language-forge">let resp = http.get("https://api.example.com/status")
http.pretty(resp)
</code></pre>
<h2 id="server-decorators"><a class="header" href="#server-decorators">Server Decorators</a></h2>
<p>Forge supports declarative HTTP servers using decorators. The <code>@server</code> decorator configures the server, and <code>@get</code>, <code>@post</code>, <code>@put</code>, <code>@delete</code> decorators define route handlers.</p>
<pre><code class="language-forge">@server(port: 3000)

@get("/")
fn index() {
    return { message: "Welcome to Forge!" }
}

@get("/users/:id")
fn get_user(id) {
    return { id: id, name: "User " + id }
}

@post("/users")
fn create_user(body) {
    say "Creating user: " + body.name
    return { ok: true, name: body.name }
}

@delete("/users/:id")
fn delete_user(id) {
    return { deleted: id }
}
</code></pre>
<h3 id="handler-parameters"><a class="header" href="#handler-parameters">Handler Parameters</a></h3>
<p>Handler functions receive arguments based on parameter names:</p>
<ul>
<li><strong>Path parameters</strong> (<code>:id</code>, <code>:name</code>) are passed by matching the parameter name.</li>
<li><strong><code>body</code></strong> or <strong><code>data</code></strong> receives the parsed JSON request body.</li>
<li><strong><code>query</code></strong> or <strong><code>qs</code></strong> receives query string parameters as an object.</li>
</ul>
<h3 id="server-features"><a class="header" href="#server-features">Server Features</a></h3>
<ul>
<li>Built on <strong>axum</strong> and <strong>tokio</strong> for production-grade async performance.</li>
<li><strong>CORS</strong> is enabled by default (permissive policy).</li>
<li>Return values are automatically serialized as JSON responses.</li>
<li>WebSocket support via the <code>@ws</code> decorator.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="io"><a class="header" href="#io">io</a></h1>
<p>Input/output operations and command-line argument handling.</p>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<h3 id="ioprompttext---string"><a class="header" href="#ioprompttext---string">io.prompt(text?) -&gt; string</a></h3>
<p>Displays <code>text</code> and reads a line of input from stdin. Returns the input with trailing newline removed.</p>
<pre><code class="language-forge">let name = io.prompt("What is your name? ")
say "Hello, " + name
</code></pre>
<h3 id="ioprintargs---null"><a class="header" href="#ioprintargs---null">io.print(…args) -&gt; null</a></h3>
<p>Prints arguments to stdout without a trailing newline. Arguments are joined with spaces.</p>
<pre><code class="language-forge">io.print("Loading")
io.print(".")
io.print(".")
io.print(".\n")
// Loading...
</code></pre>
<h3 id="ioargs---array"><a class="header" href="#ioargs---array">io.args() -&gt; array</a></h3>
<p>Returns all command-line arguments as an array of strings, including the program name.</p>
<pre><code class="language-forge">let args = io.args()
say args  // ["forge", "run", "script.fg", "--verbose"]
</code></pre>
<h3 id="ioargs_parse---object"><a class="header" href="#ioargs_parse---object">io.args_parse() -&gt; object</a></h3>
<p>Parses command-line arguments into an object. Flags starting with <code>--</code> become keys. If a flag is followed by a non-flag value, that value is used; otherwise the flag is set to <code>true</code>.</p>
<pre><code class="language-forge">// forge run script.fg --port 3000 --verbose
let opts = io.args_parse()
say opts["--port"]     // "3000"
say opts["--verbose"]  // true
</code></pre>
<h3 id="ioargs_getflag---string--bool--null"><a class="header" href="#ioargs_getflag---string--bool--null">io.args_get(flag) -&gt; string | bool | null</a></h3>
<p>Returns the value of a specific command-line flag. Returns <code>true</code> if the flag exists but has no value, or <code>null</code> if the flag is not present.</p>
<pre><code class="language-forge">let port = io.args_get("--port")  // "3000" or null
let verbose = io.args_get("--verbose")  // true or null
</code></pre>
<h3 id="ioargs_hasflag---bool"><a class="header" href="#ioargs_hasflag---bool">io.args_has(flag) -&gt; bool</a></h3>
<p>Returns <code>true</code> if the flag is present in the command-line arguments.</p>
<pre><code class="language-forge">if io.args_has("--debug") {
    log.debug("Debug mode enabled")
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="exec"><a class="header" href="#exec">exec</a></h1>
<p>External command execution. The <code>exec</code> module provides a single function, <code>run_command</code>, which is also available as a top-level builtin.</p>
<h2 id="functions-11"><a class="header" href="#functions-11">Functions</a></h2>
<h3 id="run_commandcommand---object"><a class="header" href="#run_commandcommand---object">run_command(command) -&gt; object</a></h3>
<p>Executes an external command and returns a result object. The command string is split by whitespace into the program name and arguments. The command is <strong>not</strong> executed through a shell, which prevents shell injection.</p>
<p><strong>Returns:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>stdout</code></td><td><code>string</code></td><td>Standard output (trailing whitespace trimmed)</td></tr>
<tr><td><code>stderr</code></td><td><code>string</code></td><td>Standard error (trailing whitespace trimmed)</td></tr>
<tr><td><code>status</code></td><td><code>int</code></td><td>Exit code (0 = success)</td></tr>
<tr><td><code>ok</code></td><td><code>bool</code></td><td><code>true</code> if exit code is 0</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let result = run_command("ls -la")
say result.stdout
say result.ok      // true

let git = run_command("git status")
if git.ok {
    say git.stdout
} else {
    say "Git error: " + git.stderr
}
</code></pre>
<h2 id="notes-3"><a class="header" href="#notes-3">Notes</a></h2>
<ul>
<li>For shell features (pipes, redirects, globbing), use the <code>sh</code> builtin function instead, which executes through a shell.</li>
<li>The command string is split by whitespace, so arguments with spaces are not supported. Use <code>sh</code> for complex commands.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="time"><a class="header" href="#time">time</a></h1>
<p>Date, time, and timezone operations. Time objects are plain Forge objects with structured fields. Built on the <code>chrono</code> and <code>chrono-tz</code> crates.</p>
<h2 id="time-object-structure"><a class="header" href="#time-object-structure">Time Object Structure</a></h2>
<p>Most <code>time</code> functions return a time object with these fields:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>iso</code></td><td><code>string</code></td><td>ISO 8601 / RFC 3339 timestamp</td></tr>
<tr><td><code>unix</code></td><td><code>int</code></td><td>Unix timestamp in seconds</td></tr>
<tr><td><code>unix_ms</code></td><td><code>int</code></td><td>Unix timestamp in milliseconds</td></tr>
<tr><td><code>year</code></td><td><code>int</code></td><td>Year</td></tr>
<tr><td><code>month</code></td><td><code>int</code></td><td>Month (1-12)</td></tr>
<tr><td><code>day</code></td><td><code>int</code></td><td>Day of month (1-31)</td></tr>
<tr><td><code>hour</code></td><td><code>int</code></td><td>Hour (0-23)</td></tr>
<tr><td><code>minute</code></td><td><code>int</code></td><td>Minute (0-59)</td></tr>
<tr><td><code>second</code></td><td><code>int</code></td><td>Second (0-59)</td></tr>
<tr><td><code>weekday</code></td><td><code>string</code></td><td>Full weekday name (e.g., “Monday”)</td></tr>
<tr><td><code>weekday_short</code></td><td><code>string</code></td><td>Abbreviated weekday (e.g., “Mon”)</td></tr>
<tr><td><code>day_of_year</code></td><td><code>int</code></td><td>Day of the year (1-366)</td></tr>
<tr><td><code>timezone</code></td><td><code>string</code></td><td>Timezone name</td></tr>
</tbody>
</table>
</div>
<h2 id="functions-12"><a class="header" href="#functions-12">Functions</a></h2>
<h3 id="timenowtimezone---object"><a class="header" href="#timenowtimezone---object">time.now(timezone?) -&gt; object</a></h3>
<p>Returns the current time as a time object. Defaults to UTC. Pass a timezone string for a specific zone.</p>
<pre><code class="language-forge">let now = time.now()
say now.iso   // "2026-03-02T14:30:00+00:00"
say now.year  // 2026

let tokyo = time.now("Asia/Tokyo")
say tokyo.hour
</code></pre>
<h3 id="timelocal---object"><a class="header" href="#timelocal---object">time.local() -&gt; object</a></h3>
<p>Returns the current time in the system’s local timezone.</p>
<pre><code class="language-forge">let local = time.local()
say local.timezone  // "Local"
</code></pre>
<h3 id="timeunix---int"><a class="header" href="#timeunix---int">time.unix() -&gt; int</a></h3>
<p>Returns the current Unix timestamp in seconds.</p>
<pre><code class="language-forge">let ts = time.unix()
say ts  // e.g. 1772618400
</code></pre>
<h3 id="timetoday---string"><a class="header" href="#timetoday---string">time.today() -&gt; string</a></h3>
<p>Returns today’s date as a <code>"YYYY-MM-DD"</code> string.</p>
<pre><code class="language-forge">say time.today()  // "2026-03-02"
</code></pre>
<h3 id="timedateyear-month-day---object"><a class="header" href="#timedateyear-month-day---object">time.date(year, month, day) -&gt; object</a></h3>
<p>Creates a time object for a specific date at midnight UTC.</p>
<pre><code class="language-forge">let christmas = time.date(2026, 12, 25)
say christmas.weekday  // "Friday"
</code></pre>
<h3 id="timeparseinput-timezone---object"><a class="header" href="#timeparseinput-timezone---object">time.parse(input, timezone?) -&gt; object</a></h3>
<p>Parses a date/time string or Unix timestamp into a time object. Supports multiple formats:</p>
<ul>
<li><code>"2026-03-02T14:30:00Z"</code> (ISO 8601 with timezone)</li>
<li><code>"2026-03-02T14:30:00"</code> (ISO 8601 without timezone)</li>
<li><code>"2026-03-02 14:30:00"</code> (date + time)</li>
<li><code>"2026-03-02"</code> (date only)</li>
<li><code>"03/02/2026"</code> (US format MM/DD/YYYY)</li>
<li><code>"02.03.2026"</code> (European format DD.MM.YYYY)</li>
<li><code>"Mar 02, 2026"</code> (month name)</li>
<li><code>1772618400</code> (Unix timestamp as integer)</li>
</ul>
<pre><code class="language-forge">let t = time.parse("2026-03-02")
say t.weekday  // "Monday"

let t2 = time.parse(1772618400)
say t2.iso
</code></pre>
<h3 id="timeformattime_obj-format_str---string"><a class="header" href="#timeformattime_obj-format_str---string">time.format(time_obj, format_str?) -&gt; string</a></h3>
<p>Formats a time object using a strftime-style format string. Defaults to <code>"%Y-%m-%d %H:%M:%S"</code>.</p>
<pre><code class="language-forge">let now = time.now()
say time.format(now)                    // "2026-03-02 14:30:00"
say time.format(now, "%B %d, %Y")      // "March 02, 2026"
say time.format(now, "%H:%M")          // "14:30"
</code></pre>
<h3 id="timefrom_unixtimestamp---object"><a class="header" href="#timefrom_unixtimestamp---object">time.from_unix(timestamp) -&gt; object</a></h3>
<p>Converts a Unix timestamp (seconds) to a time object.</p>
<pre><code class="language-forge">let t = time.from_unix(0)
say t.iso  // "1970-01-01T00:00:00+00:00"
</code></pre>
<h3 id="timedifft1-t2---object"><a class="header" href="#timedifft1-t2---object">time.diff(t1, t2) -&gt; object</a></h3>
<p>Returns the difference between two time objects.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>seconds</code></td><td><code>int</code></td><td>Difference in seconds (negative if t1 &lt; t2)</td></tr>
<tr><td><code>minutes</code></td><td><code>float</code></td><td>Difference in minutes</td></tr>
<tr><td><code>hours</code></td><td><code>float</code></td><td>Difference in hours</td></tr>
<tr><td><code>days</code></td><td><code>float</code></td><td>Difference in days</td></tr>
<tr><td><code>weeks</code></td><td><code>float</code></td><td>Difference in weeks</td></tr>
<tr><td><code>human</code></td><td><code>string</code></td><td>Human-readable string (e.g., “2d 3h 15m 0s”)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let a = time.parse("2026-03-01")
let b = time.parse("2026-03-15")
let d = time.diff(b, a)
say d.days   // 14.0
say d.human  // "14d 0h 0m 0s"
</code></pre>
<h3 id="timeaddtime_obj-duration---object"><a class="header" href="#timeaddtime_obj-duration---object">time.add(time_obj, duration) -&gt; object</a></h3>
<p>Adds a duration to a time object. Duration can be an object with time unit fields or an integer (seconds).</p>
<pre><code class="language-forge">let now = time.now()
let later = time.add(now, { days: 7, hours: 3 })
let also_later = time.add(now, 3600)  // add 1 hour in seconds
</code></pre>
<p>Duration fields: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>millis</code>.</p>
<h3 id="timesubtime_obj-duration---object"><a class="header" href="#timesubtime_obj-duration---object">time.sub(time_obj, duration) -&gt; object</a></h3>
<p>Subtracts a duration from a time object. Same interface as <code>time.add</code>.</p>
<pre><code class="language-forge">let now = time.now()
let yesterday = time.sub(now, { days: 1 })
</code></pre>
<h3 id="timezonetime_obj-timezone---object"><a class="header" href="#timezonetime_obj-timezone---object">time.zone(time_obj, timezone) -&gt; object</a></h3>
<p>Converts a time object to a different timezone.</p>
<pre><code class="language-forge">let utc = time.now()
let eastern = time.zone(utc, "America/New_York")
say eastern.hour
</code></pre>
<h3 id="timezonesfilter---array"><a class="header" href="#timezonesfilter---array">time.zones(filter?) -&gt; array</a></h3>
<p>Returns an array of all available timezone names. Optionally filter by substring.</p>
<pre><code class="language-forge">let all = time.zones()
let us = time.zones("America")
</code></pre>
<h3 id="timeis_beforet1-t2---bool"><a class="header" href="#timeis_beforet1-t2---bool">time.is_before(t1, t2) -&gt; bool</a></h3>
<p>Returns <code>true</code> if <code>t1</code> is before <code>t2</code>.</p>
<h3 id="timeis_aftert1-t2---bool"><a class="header" href="#timeis_aftert1-t2---bool">time.is_after(t1, t2) -&gt; bool</a></h3>
<p>Returns <code>true</code> if <code>t1</code> is after <code>t2</code>.</p>
<h3 id="timestart_oftime_obj-unit---object"><a class="header" href="#timestart_oftime_obj-unit---object">time.start_of(time_obj, unit) -&gt; object</a></h3>
<p>Returns the start of the given unit: <code>"day"</code>, <code>"hour"</code>, <code>"minute"</code>, <code>"week"</code>, <code>"month"</code>, <code>"year"</code>.</p>
<pre><code class="language-forge">let now = time.now()
let start_of_day = time.start_of(now, "day")
say start_of_day.hour  // 0
</code></pre>
<h3 id="timeend_oftime_obj-unit---object"><a class="header" href="#timeend_oftime_obj-unit---object">time.end_of(time_obj, unit) -&gt; object</a></h3>
<p>Returns the end of the given unit (23:59:59 for days, etc.).</p>
<h3 id="timesleepseconds---null"><a class="header" href="#timesleepseconds---null">time.sleep(seconds) -&gt; null</a></h3>
<p>Pauses execution for the given number of seconds. Accepts integers or floats.</p>
<pre><code class="language-forge">time.sleep(2)     // sleep 2 seconds
time.sleep(0.5)   // sleep 500ms
</code></pre>
<h3 id="timeelapsed---int"><a class="header" href="#timeelapsed---int">time.elapsed() -&gt; int</a></h3>
<p>Returns the current time in milliseconds since the Unix epoch. Useful for measuring performance.</p>
<pre><code class="language-forge">let start = time.elapsed()
// ... do work ...
let duration = time.elapsed() - start
say "Took " + str(duration) + "ms"
</code></pre>
<h3 id="timeis_weekendtime_obj---bool"><a class="header" href="#timeis_weekendtime_obj---bool">time.is_weekend(time_obj?) -&gt; bool</a></h3>
<p>Returns <code>true</code> if the time falls on Saturday or Sunday. Defaults to now.</p>
<h3 id="timeis_weekdaytime_obj---bool"><a class="header" href="#timeis_weekdaytime_obj---bool">time.is_weekday(time_obj?) -&gt; bool</a></h3>
<p>Returns <code>true</code> if the time falls on Monday-Friday. Defaults to now.</p>
<h3 id="timeday_of_weektime_obj---string"><a class="header" href="#timeday_of_weektime_obj---string">time.day_of_week(time_obj?) -&gt; string</a></h3>
<p>Returns the full weekday name. Defaults to now.</p>
<h3 id="timedays_in_monthyear-month---int"><a class="header" href="#timedays_in_monthyear-month---int">time.days_in_month(year?, month?) -&gt; int</a></h3>
<p>Returns the number of days in a month. Accepts <code>(year, month)</code> integers or a time object.</p>
<pre><code class="language-forge">time.days_in_month(2024, 2)  // 29 (leap year)
time.days_in_month(2025, 2)  // 28
</code></pre>
<h3 id="timeis_leap_yearyear---bool"><a class="header" href="#timeis_leap_yearyear---bool">time.is_leap_year(year?) -&gt; bool</a></h3>
<p>Returns <code>true</code> if the given year is a leap year. Accepts an integer or time object.</p>
<pre><code class="language-forge">time.is_leap_year(2024)  // true
time.is_leap_year(2025)  // false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="npc"><a class="header" href="#npc">npc</a></h1>
<p>Fake data generation for testing, prototyping, and seeding databases. “NPC” stands for Non-Player Character – these are the background characters in your application.</p>
<h2 id="functions-13"><a class="header" href="#functions-13">Functions</a></h2>
<h3 id="npcname---string"><a class="header" href="#npcname---string">npc.name() -&gt; string</a></h3>
<p>Returns a random full name (first + last).</p>
<pre><code class="language-forge">say npc.name()  // e.g. "Luna Nakamura"
</code></pre>
<h3 id="npcfirst_name---string"><a class="header" href="#npcfirst_name---string">npc.first_name() -&gt; string</a></h3>
<p>Returns a random first name from a diverse, gender-neutral pool.</p>
<pre><code class="language-forge">say npc.first_name()  // e.g. "Phoenix"
</code></pre>
<h3 id="npclast_name---string"><a class="header" href="#npclast_name---string">npc.last_name() -&gt; string</a></h3>
<p>Returns a random last name from a globally diverse pool.</p>
<pre><code class="language-forge">say npc.last_name()  // e.g. "Patel"
</code></pre>
<h3 id="npcemail---string"><a class="header" href="#npcemail---string">npc.email() -&gt; string</a></h3>
<p>Returns a random email address.</p>
<pre><code class="language-forge">say npc.email()  // e.g. "luna.garcia42@proton.me"
</code></pre>
<h3 id="npcusername---string"><a class="header" href="#npcusername---string">npc.username() -&gt; string</a></h3>
<p>Returns a random username in the format <code>adjective_noun123</code>.</p>
<pre><code class="language-forge">say npc.username()  // e.g. "turbo_wizard847"
</code></pre>
<h3 id="npcphone---string"><a class="header" href="#npcphone---string">npc.phone() -&gt; string</a></h3>
<p>Returns a random US-format phone number.</p>
<pre><code class="language-forge">say npc.phone()  // e.g. "(555) 234-5678"
</code></pre>
<h3 id="npcnumbermin-max---int"><a class="header" href="#npcnumbermin-max---int">npc.number(min?, max?) -&gt; int</a></h3>
<p>Returns a random integer. Defaults to range 0-100.</p>
<pre><code class="language-forge">npc.number()        // 0-100
npc.number(1, 6)    // dice roll
npc.number(1000, 9999)  // 4-digit number
</code></pre>
<h3 id="npcpickarray---any"><a class="header" href="#npcpickarray---any">npc.pick(array) -&gt; any</a></h3>
<p>Returns a random element from the given array.</p>
<pre><code class="language-forge">let color = npc.pick(["red", "green", "blue"])
say color  // e.g. "green"
</code></pre>
<h3 id="npcbool---bool"><a class="header" href="#npcbool---bool">npc.bool() -&gt; bool</a></h3>
<p>Returns a random boolean.</p>
<pre><code class="language-forge">say npc.bool()  // true or false
</code></pre>
<h3 id="npcsentenceword_count---string"><a class="header" href="#npcsentenceword_count---string">npc.sentence(word_count?) -&gt; string</a></h3>
<p>Returns a random sentence. Default word count is 5-12.</p>
<pre><code class="language-forge">say npc.sentence()    // e.g. "The quick data flows through every node."
say npc.sentence(5)   // exactly 5 words
</code></pre>
<h3 id="npcword---string"><a class="header" href="#npcword---string">npc.word() -&gt; string</a></h3>
<p>Returns a single random word.</p>
<pre><code class="language-forge">say npc.word()  // e.g. "algorithms"
</code></pre>
<h3 id="npcid---string"><a class="header" href="#npcid---string">npc.id() -&gt; string</a></h3>
<p>Returns a random UUID-like identifier (format: <code>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code>).</p>
<pre><code class="language-forge">say npc.id()  // e.g. "a3b2f1c8-d4e5-f6a7-b8c9-d0e1f2a3b4c5"
</code></pre>
<h3 id="npccolor---string"><a class="header" href="#npccolor---string">npc.color() -&gt; string</a></h3>
<p>Returns a random hex color code.</p>
<pre><code class="language-forge">say npc.color()  // e.g. "#3a7fb2"
</code></pre>
<h3 id="npcip---string"><a class="header" href="#npcip---string">npc.ip() -&gt; string</a></h3>
<p>Returns a random IPv4 address.</p>
<pre><code class="language-forge">say npc.ip()  // e.g. "192.168.45.12"
</code></pre>
<h3 id="npcurl---string"><a class="header" href="#npcurl---string">npc.url() -&gt; string</a></h3>
<p>Returns a random URL.</p>
<pre><code class="language-forge">say npc.url()  // e.g. "https://techflow.io/dashboard"
</code></pre>
<h3 id="npccompany---string"><a class="header" href="#npccompany---string">npc.company() -&gt; string</a></h3>
<p>Returns a random company name.</p>
<pre><code class="language-forge">say npc.company()  // e.g. "QuantumLeap"
</code></pre>
<h2 id="example-seeding-a-database"><a class="header" href="#example-seeding-a-database">Example: Seeding a Database</a></h2>
<pre><code class="language-forge">db.open(":memory:")
db.execute("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)")

repeat 100 times {
    db.execute("INSERT INTO users (name, email) VALUES (?, ?)", [
        npc.name(),
        npc.email()
    ])
}

let users = db.query("SELECT * FROM users LIMIT 5")
term.table(users)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="output-functions"><a class="header" href="#output-functions">Output Functions</a></h1>
<p>Functions for printing to stdout. All output functions accept any number of arguments, which are converted to strings and joined with spaces.</p>
<h2 id="printargs---null"><a class="header" href="#printargs---null">print(…args) -&gt; null</a></h2>
<p>Prints arguments to stdout <strong>without</strong> a trailing newline.</p>
<pre><code class="language-forge">print("loading")
print("...")
print("\n")
// loading...
</code></pre>
<h2 id="printlnargs---null"><a class="header" href="#printlnargs---null">println(…args) -&gt; null</a></h2>
<p>Prints arguments to stdout <strong>with</strong> a trailing newline.</p>
<pre><code class="language-forge">println("Hello, world!")
println("x =", 42)
// Hello, world!
// x = 42
</code></pre>
<h2 id="sayargs---null"><a class="header" href="#sayargs---null">say(…args) -&gt; null</a></h2>
<p>Alias for <code>println</code>. Prints arguments followed by a newline. This is the idiomatic Forge output function.</p>
<pre><code class="language-forge">say "Hello!"
say "The answer is", 42
</code></pre>
<h2 id="yellargs---null"><a class="header" href="#yellargs---null">yell(…args) -&gt; null</a></h2>
<p>Prints arguments in UPPERCASE followed by a newline.</p>
<pre><code class="language-forge">yell "fire detected"
// FIRE DETECTED
</code></pre>
<h2 id="whisperargs---null"><a class="header" href="#whisperargs---null">whisper(…args) -&gt; null</a></h2>
<p>Prints arguments in lowercase followed by a newline.</p>
<pre><code class="language-forge">whisper "QUIET PLEASE"
// quiet please
</code></pre>
<h2 id="notes-4"><a class="header" href="#notes-4">Notes</a></h2>
<ul>
<li><code>print</code> and <code>println</code> are classic-style. <code>say</code>, <code>yell</code>, and <code>whisper</code> are Forge-style.</li>
<li>All five functions write to stdout (not stderr). For stderr output, use the <code>log</code> module.</li>
<li>Arguments of any type are auto-converted to their string representation.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-functions"><a class="header" href="#type-functions">Type Functions</a></h1>
<p>Functions for type conversion and inspection.</p>
<h2 id="strvalue---string"><a class="header" href="#strvalue---string">str(value) -&gt; string</a></h2>
<p>Converts any value to its string representation.</p>
<pre><code class="language-forge">str(42)        // "42"
str(3.14)      // "3.14"
str(true)      // "true"
str(null)      // "null"
str([1, 2])    // "[1, 2]"
</code></pre>
<h2 id="intvalue---int"><a class="header" href="#intvalue---int">int(value) -&gt; int</a></h2>
<p>Converts a value to an integer. Accepts integers, floats (truncated), and numeric strings.</p>
<pre><code class="language-forge">int(3.14)     // 3
int("42")     // 42
int(100)      // 100
</code></pre>
<p>Errors if the string is not a valid integer.</p>
<h2 id="floatvalue---float"><a class="header" href="#floatvalue---float">float(value) -&gt; float</a></h2>
<p>Converts a value to a float. Accepts integers, floats, and numeric strings.</p>
<pre><code class="language-forge">float(42)       // 42.0
float("3.14")   // 3.14
float(1)        // 1.0
</code></pre>
<p>Errors if the string is not a valid number.</p>
<h2 id="typevalue---string"><a class="header" href="#typevalue---string">type(value) -&gt; string</a></h2>
<p>Returns the type name of <code>value</code> as a string.</p>
<pre><code class="language-forge">type(42)          // "Int"
type(3.14)        // "Float"
type("hello")     // "String"
type(true)        // "Bool"
type(null)        // "Null"
type([1, 2])      // "Array"
type({a: 1})      // "Object"
type(fn(x) { x }) // "Function"
</code></pre>
<h2 id="typeofvalue---string"><a class="header" href="#typeofvalue---string">typeof(value) -&gt; string</a></h2>
<p>Alias for <code>type</code>. Returns the type name of <code>value</code>.</p>
<pre><code class="language-forge">typeof("hello")  // "String"
typeof(42)       // "Int"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="collection-functions"><a class="header" href="#collection-functions">Collection Functions</a></h1>
<p>Functions for working with arrays, objects, and sequences.</p>
<h2 id="lencollection---int"><a class="header" href="#lencollection---int">len(collection) -&gt; int</a></h2>
<p>Returns the length of a string, array, or object.</p>
<pre><code class="language-forge">len("hello")       // 5
len([1, 2, 3])     // 3
len({a: 1, b: 2})  // 2
</code></pre>
<h2 id="pusharray-value---array"><a class="header" href="#pusharray-value---array">push(array, value) -&gt; array</a></h2>
<p>Returns a new array with <code>value</code> appended to the end.</p>
<pre><code class="language-forge">let a = [1, 2, 3]
let b = push(a, 4)
say b  // [1, 2, 3, 4]
</code></pre>
<blockquote>
<p><strong>Note:</strong> <code>push</code> returns a new array. The original array is not modified.</p>
</blockquote>
<h2 id="poparray---array"><a class="header" href="#poparray---array">pop(array) -&gt; array</a></h2>
<p>Returns a new array with the last element removed.</p>
<pre><code class="language-forge">let a = [1, 2, 3]
let b = pop(a)
say b  // [1, 2]
</code></pre>
<h2 id="keysobject---array"><a class="header" href="#keysobject---array">keys(object) -&gt; array</a></h2>
<p>Returns an array of the object’s keys as strings.</p>
<pre><code class="language-forge">let obj = { name: "Alice", age: 30 }
say keys(obj)  // ["name", "age"]
</code></pre>
<h2 id="valuesobject---array"><a class="header" href="#valuesobject---array">values(object) -&gt; array</a></h2>
<p>Returns an array of the object’s values.</p>
<pre><code class="language-forge">let obj = { name: "Alice", age: 30 }
say values(obj)  // ["Alice", 30]
</code></pre>
<h2 id="containscollection-item---bool"><a class="header" href="#containscollection-item---bool">contains(collection, item) -&gt; bool</a></h2>
<p>Checks if a collection contains an item.</p>
<ul>
<li><strong>String, substring</strong>: checks if the substring exists in the string.</li>
<li><strong>Array, value</strong>: checks if the value exists in the array.</li>
<li><strong>Object, key</strong>: checks if the key exists in the object.</li>
</ul>
<pre><code class="language-forge">contains("hello world", "world")  // true
contains([1, 2, 3], 2)            // true
contains({a: 1}, "a")             // true
contains({a: 1}, "b")             // false
</code></pre>
<h2 id="rangestart-end-step---array"><a class="header" href="#rangestart-end-step---array">range(start, end, step?) -&gt; array</a></h2>
<p>Generates an array of integers from <code>start</code> (inclusive) to <code>end</code> (exclusive). Optional <code>step</code> defaults to 1.</p>
<pre><code class="language-forge">range(0, 5)        // [0, 1, 2, 3, 4]
range(1, 10, 2)    // [1, 3, 5, 7, 9]
range(5, 0, -1)    // [5, 4, 3, 2, 1]
</code></pre>
<h2 id="enumeratearray---array"><a class="header" href="#enumeratearray---array">enumerate(array) -&gt; array</a></h2>
<p>Returns an array of <code>[index, value]</code> pairs.</p>
<pre><code class="language-forge">let names = ["Alice", "Bob", "Charlie"]
for pair in enumerate(names) {
    say str(pair[0]) + ": " + pair[1]
}
// 0: Alice
// 1: Bob
// 2: Charlie
</code></pre>
<h2 id="sumarray---int--float"><a class="header" href="#sumarray---int--float">sum(array) -&gt; int | float</a></h2>
<p>Returns the sum of all numeric elements in an array.</p>
<pre><code class="language-forge">sum([1, 2, 3, 4])    // 10
sum([1.5, 2.5])       // 4.0
</code></pre>
<h2 id="min_ofarray---int--float"><a class="header" href="#min_ofarray---int--float">min_of(array) -&gt; int | float</a></h2>
<p>Returns the minimum value in an array.</p>
<pre><code class="language-forge">min_of([3, 1, 4, 1, 5])  // 1
</code></pre>
<h2 id="max_ofarray---int--float"><a class="header" href="#max_ofarray---int--float">max_of(array) -&gt; int | float</a></h2>
<p>Returns the maximum value in an array.</p>
<pre><code class="language-forge">max_of([3, 1, 4, 1, 5])  // 5
</code></pre>
<h2 id="uniquearray---array"><a class="header" href="#uniquearray---array">unique(array) -&gt; array</a></h2>
<p>Returns a new array with duplicate values removed, preserving order.</p>
<pre><code class="language-forge">unique([1, 2, 2, 3, 1])  // [1, 2, 3]
</code></pre>
<h2 id="ziparray_a-array_b---array"><a class="header" href="#ziparray_a-array_b---array">zip(array_a, array_b) -&gt; array</a></h2>
<p>Combines two arrays into an array of <code>[a, b]</code> pairs. Truncates to the shorter array’s length.</p>
<pre><code class="language-forge">zip([1, 2, 3], ["a", "b", "c"])
// [[1, "a"], [2, "b"], [3, "c"]]
</code></pre>
<h2 id="flattenarray---array"><a class="header" href="#flattenarray---array">flatten(array) -&gt; array</a></h2>
<p>Flattens nested arrays by one level.</p>
<pre><code class="language-forge">flatten([[1, 2], [3, 4], [5]])  // [1, 2, 3, 4, 5]
</code></pre>
<h2 id="group_byarray-fn---object"><a class="header" href="#group_byarray-fn---object">group_by(array, fn) -&gt; object</a></h2>
<p>Groups array elements by the string returned by <code>fn</code>. Returns an object where keys are group names and values are arrays.</p>
<pre><code class="language-forge">let people = [
    { name: "Alice", dept: "eng" },
    { name: "Bob", dept: "sales" },
    { name: "Charlie", dept: "eng" }
]
let groups = group_by(people, fn(p) { p.dept })
say keys(groups)  // ["eng", "sales"]
say groups.eng    // [{name: "Alice", dept: "eng"}, {name: "Charlie", dept: "eng"}]
</code></pre>
<h2 id="chunkarray-size---array"><a class="header" href="#chunkarray-size---array">chunk(array, size) -&gt; array</a></h2>
<p>Splits an array into chunks of the given size.</p>
<pre><code class="language-forge">chunk([1, 2, 3, 4, 5], 2)
// [[1, 2], [3, 4], [5]]
</code></pre>
<h2 id="slicearray-start-end---array"><a class="header" href="#slicearray-start-end---array">slice(array, start, end?) -&gt; array</a></h2>
<p>Returns a sub-array from <code>start</code> (inclusive) to <code>end</code> (exclusive). If <code>end</code> is omitted, slices to the end.</p>
<pre><code class="language-forge">slice([1, 2, 3, 4, 5], 1, 3)  // [2, 3]
slice([1, 2, 3, 4, 5], 2)     // [3, 4, 5]
</code></pre>
<h2 id="partitionarray-fn---array"><a class="header" href="#partitionarray-fn---array">partition(array, fn) -&gt; array</a></h2>
<p>Splits an array into two arrays: elements where <code>fn</code> returns truthy, and elements where it returns falsy.</p>
<pre><code class="language-forge">let nums = [1, 2, 3, 4, 5, 6]
let result = partition(nums, fn(n) { n % 2 == 0 })
say result[0]  // [2, 4, 6]  (even)
say result[1]  // [1, 3, 5]  (odd)
</code></pre>
<h2 id="functional-operations-1"><a class="header" href="#functional-operations-1">Functional Operations</a></h2>
<h3 id="maparray-fn---array"><a class="header" href="#maparray-fn---array">map(array, fn) -&gt; array</a></h3>
<p>Applies <code>fn</code> to each element and returns the results.</p>
<pre><code class="language-forge">map([1, 2, 3], fn(x) { x * 2 })  // [2, 4, 6]
</code></pre>
<h3 id="filterarray-fn---array"><a class="header" href="#filterarray-fn---array">filter(array, fn) -&gt; array</a></h3>
<p>Returns elements where <code>fn</code> returns truthy.</p>
<pre><code class="language-forge">filter([1, 2, 3, 4], fn(x) { x &gt; 2 })  // [3, 4]
</code></pre>
<h3 id="reducearray-initial-fn---any"><a class="header" href="#reducearray-initial-fn---any">reduce(array, initial, fn) -&gt; any</a></h3>
<p>Reduces an array to a single value by applying <code>fn(accumulator, element)</code> for each element.</p>
<pre><code class="language-forge">reduce([1, 2, 3, 4], 0, fn(acc, x) { acc + x })  // 10
</code></pre>
<h3 id="sortarray-comparator---array"><a class="header" href="#sortarray-comparator---array">sort(array, comparator?) -&gt; array</a></h3>
<p>Returns a sorted copy of the array. Without a comparator, sorts numbers numerically and strings alphabetically. The comparator function receives two elements and returns a negative number, zero, or positive number.</p>
<pre><code class="language-forge">sort([3, 1, 4, 1, 5])  // [1, 1, 3, 4, 5]

sort(["banana", "apple", "cherry"])  // ["apple", "banana", "cherry"]

// Custom sort: descending
sort([1, 2, 3], fn(a, b) { b - a })  // [3, 2, 1]
</code></pre>
<h3 id="reversearray---array"><a class="header" href="#reversearray---array">reverse(array) -&gt; array</a></h3>
<p>Returns a reversed copy of the array.</p>
<pre><code class="language-forge">reverse([1, 2, 3])  // [3, 2, 1]
</code></pre>
<h3 id="findarray-fn---any--null"><a class="header" href="#findarray-fn---any--null">find(array, fn) -&gt; any | null</a></h3>
<p>Returns the first element where <code>fn</code> returns truthy, or <code>null</code> if none match.</p>
<pre><code class="language-forge">find([1, 2, 3, 4], fn(x) { x &gt; 2 })  // 3
find([1, 2], fn(x) { x &gt; 5 })         // null
</code></pre>
<h3 id="flat_maparray-fn---array"><a class="header" href="#flat_maparray-fn---array">flat_map(array, fn) -&gt; array</a></h3>
<p>Maps each element with <code>fn</code> and flattens the result by one level.</p>
<pre><code class="language-forge">flat_map([1, 2, 3], fn(x) { [x, x * 10] })
// [1, 10, 2, 20, 3, 30]
</code></pre>
<h3 id="anyarray-fn---bool"><a class="header" href="#anyarray-fn---bool">any(array, fn) -&gt; bool</a></h3>
<p>Returns <code>true</code> if <code>fn</code> returns truthy for at least one element.</p>
<pre><code class="language-forge">any([1, 2, 3], fn(x) { x &gt; 2 })  // true
any([1, 2, 3], fn(x) { x &gt; 5 })  // false
</code></pre>
<h3 id="allarray-fn---bool"><a class="header" href="#allarray-fn---bool">all(array, fn) -&gt; bool</a></h3>
<p>Returns <code>true</code> if <code>fn</code> returns truthy for every element.</p>
<pre><code class="language-forge">all([2, 4, 6], fn(x) { x % 2 == 0 })  // true
all([2, 3, 6], fn(x) { x % 2 == 0 })  // false
</code></pre>
<h3 id="samplearray-n---any--array"><a class="header" href="#samplearray-n---any--array">sample(array, n?) -&gt; any | array</a></h3>
<p>Returns a random element (no arguments) or <code>n</code> random elements from the array.</p>
<pre><code class="language-forge">sample([1, 2, 3, 4, 5])     // e.g. 3
sample([1, 2, 3, 4, 5], 2)  // e.g. [4, 1]
</code></pre>
<h3 id="shufflearray---array"><a class="header" href="#shufflearray---array">shuffle(array) -&gt; array</a></h3>
<p>Returns a randomly shuffled copy of the array.</p>
<pre><code class="language-forge">shuffle([1, 2, 3, 4, 5])  // e.g. [3, 5, 1, 4, 2]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="string-functions"><a class="header" href="#string-functions">String Functions</a></h1>
<p>Functions for string manipulation. All string functions are non-mutating and return new strings.</p>
<h2 id="splitstring-delimiter---array"><a class="header" href="#splitstring-delimiter---array">split(string, delimiter) -&gt; array</a></h2>
<p>Splits a string by the given delimiter.</p>
<pre><code class="language-forge">split("a,b,c", ",")     // ["a", "b", "c"]
split("hello world", " ") // ["hello", "world"]
</code></pre>
<h2 id="joinarray-separator---string"><a class="header" href="#joinarray-separator---string">join(array, separator?) -&gt; string</a></h2>
<p>Joins array elements into a string with an optional separator. Default separator is empty string.</p>
<pre><code class="language-forge">join(["a", "b", "c"], ", ")  // "a, b, c"
join(["x", "y", "z"])        // "xyz"
</code></pre>
<h2 id="replacestring-from-to---string"><a class="header" href="#replacestring-from-to---string">replace(string, from, to) -&gt; string</a></h2>
<p>Replaces all occurrences of <code>from</code> with <code>to</code>.</p>
<pre><code class="language-forge">replace("hello world", "world", "Forge")  // "hello Forge"
replace("aabbcc", "bb", "XX")             // "aaXXcc"
</code></pre>
<h2 id="starts_withstring-prefix---bool"><a class="header" href="#starts_withstring-prefix---bool">starts_with(string, prefix) -&gt; bool</a></h2>
<p>Returns <code>true</code> if <code>string</code> begins with <code>prefix</code>.</p>
<pre><code class="language-forge">starts_with("hello", "hel")   // true
starts_with("hello", "world") // false
</code></pre>
<h2 id="ends_withstring-suffix---bool"><a class="header" href="#ends_withstring-suffix---bool">ends_with(string, suffix) -&gt; bool</a></h2>
<p>Returns <code>true</code> if <code>string</code> ends with <code>suffix</code>.</p>
<pre><code class="language-forge">ends_with("hello.fg", ".fg")  // true
ends_with("hello.fg", ".rs")  // false
</code></pre>
<h2 id="linesstring---array"><a class="header" href="#linesstring---array">lines(string) -&gt; array</a></h2>
<p>Splits a string into an array of lines.</p>
<pre><code class="language-forge">lines("first\nsecond\nthird")
// ["first", "second", "third"]
</code></pre>
<h2 id="substringstring-start-end---string"><a class="header" href="#substringstring-start-end---string">substring(string, start, end?) -&gt; string</a></h2>
<p>Extracts a substring from <code>start</code> (inclusive) to <code>end</code> (exclusive). If <code>end</code> is omitted, extracts to the end of the string.</p>
<pre><code class="language-forge">substring("hello world", 0, 5)   // "hello"
substring("hello world", 6)      // "world"
</code></pre>
<h2 id="index_ofstring-search---int"><a class="header" href="#index_ofstring-search---int">index_of(string, search) -&gt; int</a></h2>
<p>Returns the index of the first occurrence of <code>search</code> in <code>string</code>, or -1 if not found.</p>
<pre><code class="language-forge">index_of("hello world", "world")  // 6
index_of("hello world", "xyz")    // -1
</code></pre>
<h2 id="last_index_ofstring-search---int"><a class="header" href="#last_index_ofstring-search---int">last_index_of(string, search) -&gt; int</a></h2>
<p>Returns the index of the last occurrence of <code>search</code> in <code>string</code>, or -1 if not found.</p>
<pre><code class="language-forge">last_index_of("abcabc", "abc")  // 3
last_index_of("hello", "xyz")   // -1
</code></pre>
<h2 id="pad_startstring-length-char---string"><a class="header" href="#pad_startstring-length-char---string">pad_start(string, length, char?) -&gt; string</a></h2>
<p>Pads the beginning of a string to reach the target <code>length</code>. Default pad character is a space.</p>
<pre><code class="language-forge">pad_start("42", 5, "0")    // "00042"
pad_start("hi", 10)        // "        hi"
</code></pre>
<h2 id="pad_endstring-length-char---string"><a class="header" href="#pad_endstring-length-char---string">pad_end(string, length, char?) -&gt; string</a></h2>
<p>Pads the end of a string to reach the target <code>length</code>. Default pad character is a space.</p>
<pre><code class="language-forge">pad_end("hi", 10, ".")     // "hi........"
pad_end("test", 8)         // "test    "
</code></pre>
<h2 id="capitalizestring---string"><a class="header" href="#capitalizestring---string">capitalize(string) -&gt; string</a></h2>
<p>Returns the string with the first character in uppercase.</p>
<pre><code class="language-forge">capitalize("hello")  // "Hello"
capitalize("HELLO")  // "HELLO"
</code></pre>
<h2 id="titlestring---string"><a class="header" href="#titlestring---string">title(string) -&gt; string</a></h2>
<p>Returns the string with the first character of each word capitalized.</p>
<pre><code class="language-forge">title("hello world")        // "Hello World"
title("the quick brown fox") // "The Quick Brown Fox"
</code></pre>
<h2 id="repeat_strstring-count---string"><a class="header" href="#repeat_strstring-count---string">repeat_str(string, count) -&gt; string</a></h2>
<p>Returns the string repeated <code>count</code> times.</p>
<pre><code class="language-forge">repeat_str("ha", 3)    // "hahaha"
repeat_str("-", 20)    // "--------------------"
</code></pre>
<h2 id="countstring-substring---int"><a class="header" href="#countstring-substring---int">count(string, substring) -&gt; int</a></h2>
<p>Counts the number of non-overlapping occurrences of <code>substring</code> in <code>string</code>.</p>
<pre><code class="language-forge">count("banana", "an")   // 2
count("hello", "l")     // 2
</code></pre>
<h2 id="slugifystring---string"><a class="header" href="#slugifystring---string">slugify(string) -&gt; string</a></h2>
<p>Converts a string to a URL-friendly slug: lowercase, non-alphanumeric characters replaced with hyphens.</p>
<pre><code class="language-forge">slugify("Hello World!")           // "hello-world"
slugify("The Quick Brown Fox")    // "the-quick-brown-fox"
</code></pre>
<h2 id="snake_casestring---string"><a class="header" href="#snake_casestring---string">snake_case(string) -&gt; string</a></h2>
<p>Converts a string to snake_case. Handles camelCase, PascalCase, and spaces.</p>
<pre><code class="language-forge">snake_case("helloWorld")     // "hello_world"
snake_case("MyComponent")    // "my_component"
snake_case("some string")    // "some_string"
</code></pre>
<h2 id="camel_casestring---string"><a class="header" href="#camel_casestring---string">camel_case(string) -&gt; string</a></h2>
<p>Converts a string to camelCase.</p>
<pre><code class="language-forge">camel_case("hello_world")    // "helloWorld"
camel_case("some string")    // "someString"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="object-functions"><a class="header" href="#object-functions">Object Functions</a></h1>
<p>Functions for working with Forge objects (key-value maps).</p>
<h2 id="has_keyobject-key---bool"><a class="header" href="#has_keyobject-key---bool">has_key(object, key) -&gt; bool</a></h2>
<p>Returns <code>true</code> if <code>object</code> contains the specified key.</p>
<pre><code class="language-forge">let user = { name: "Alice", age: 30 }
has_key(user, "name")    // true
has_key(user, "email")   // false
</code></pre>
<h2 id="getobject-key-default---any"><a class="header" href="#getobject-key-default---any">get(object, key, default?) -&gt; any</a></h2>
<p>Retrieves a value from an object by key. Returns <code>default</code> (or <code>null</code>) if the key does not exist. Supports <strong>dot-path notation</strong> for nested access.</p>
<pre><code class="language-forge">let config = {
    db: {
        host: "localhost",
        port: 5432
    }
}

get(config, "db.host")           // "localhost"
get(config, "db.port")           // 5432
get(config, "db.name", "mydb")   // "mydb" (default)
get(config, "missing")           // null
</code></pre>
<p>Also works with arrays by index:</p>
<pre><code class="language-forge">let data = { items: [10, 20, 30] }
get(data, "items.1")  // 20
</code></pre>
<h2 id="pickobject-fields---object"><a class="header" href="#pickobject-fields---object">pick(object, fields) -&gt; object</a></h2>
<p>Returns a new object containing only the specified fields.</p>
<pre><code class="language-forge">let user = { name: "Alice", age: 30, email: "alice@example.com" }
pick(user, ["name", "email"])
// { name: "Alice", email: "alice@example.com" }
</code></pre>
<h2 id="omitobject-fields---object"><a class="header" href="#omitobject-fields---object">omit(object, fields) -&gt; object</a></h2>
<p>Returns a new object with the specified fields removed.</p>
<pre><code class="language-forge">let user = { name: "Alice", age: 30, password: "secret" }
omit(user, ["password"])
// { name: "Alice", age: 30 }
</code></pre>
<h2 id="mergeobjects---object"><a class="header" href="#mergeobjects---object">merge(…objects) -&gt; object</a></h2>
<p>Merges multiple objects into one. Later objects override earlier keys.</p>
<pre><code class="language-forge">let defaults = { color: "blue", size: "medium" }
let overrides = { size: "large", weight: 10 }
merge(defaults, overrides)
// { color: "blue", size: "large", weight: 10 }
</code></pre>
<h2 id="entriesobject---array"><a class="header" href="#entriesobject---array">entries(object) -&gt; array</a></h2>
<p>Returns an array of <code>[key, value]</code> pairs.</p>
<pre><code class="language-forge">let obj = { a: 1, b: 2 }
entries(obj)
// [["a", 1], ["b", 2]]
</code></pre>
<h2 id="from_entriesarray---object"><a class="header" href="#from_entriesarray---object">from_entries(array) -&gt; object</a></h2>
<p>Converts an array of <code>[key, value]</code> pairs into an object. The inverse of <code>entries</code>.</p>
<pre><code class="language-forge">from_entries([["name", "Alice"], ["age", 30]])
// { name: "Alice", age: 30 }
</code></pre>
<h2 id="diffobject_a-object_b---object"><a class="header" href="#diffobject_a-object_b---object">diff(object_a, object_b) -&gt; object</a></h2>
<p>Returns an object describing the differences between two objects. Each key that differs contains an object with <code>a</code> and <code>b</code> values.</p>
<pre><code class="language-forge">let old = { name: "Alice", age: 30, city: "NYC" }
let new_val = { name: "Alice", age: 31, email: "a@b.com" }
diff(old, new_val)
// {
//   age: { a: 30, b: 31 },
//   city: { a: "NYC", b: null },
//   email: { a: null, b: "a@b.com" }
// }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="shell-functions"><a class="header" href="#shell-functions">Shell Functions</a></h1>
<p>Functions for executing shell commands and interacting with the operating system. Unlike <code>run_command</code>, these functions execute through a system shell (<code>/bin/sh</code> on Unix, <code>cmd</code> on Windows), so pipes, redirects, and globbing work.</p>
<h2 id="shcommand---string"><a class="header" href="#shcommand---string">sh(command) -&gt; string</a></h2>
<p>Executes a shell command and returns stdout as a string. Errors if the command fails.</p>
<pre><code class="language-forge">let files = sh("ls -la")
say files

let count = sh("wc -l &lt; data.txt")
say count
</code></pre>
<h2 id="shellcommand---object"><a class="header" href="#shellcommand---object">shell(command) -&gt; object</a></h2>
<p>Executes a shell command and returns a detailed result object with <code>stdout</code>, <code>stderr</code>, <code>status</code>, and <code>ok</code> fields.</p>
<pre><code class="language-forge">let result = shell("git status")
if result.ok {
    say result.stdout
} else {
    say "Error: " + result.stderr
}
</code></pre>
<h2 id="sh_linescommand---array"><a class="header" href="#sh_linescommand---array">sh_lines(command) -&gt; array</a></h2>
<p>Executes a shell command and returns stdout split into an array of lines.</p>
<pre><code class="language-forge">let files = sh_lines("ls *.fg")
for file in files {
    say "Found: " + file
}
</code></pre>
<h2 id="sh_jsoncommand---any"><a class="header" href="#sh_jsoncommand---any">sh_json(command) -&gt; any</a></h2>
<p>Executes a shell command and parses stdout as JSON.</p>
<pre><code class="language-forge">let config = sh_json("cat package.json")
say config.name
say config.version
</code></pre>
<h2 id="sh_okcommand---bool"><a class="header" href="#sh_okcommand---bool">sh_ok(command) -&gt; bool</a></h2>
<p>Executes a shell command and returns <code>true</code> if the exit code is 0.</p>
<pre><code class="language-forge">if sh_ok("which python3") {
    say "Python 3 is installed"
}
</code></pre>
<h2 id="whichprogram---string--null"><a class="header" href="#whichprogram---string--null">which(program) -&gt; string | null</a></h2>
<p>Returns the full path to <code>program</code>, or <code>null</code> if not found. Equivalent to the Unix <code>which</code> command.</p>
<pre><code class="language-forge">which("node")    // "/usr/local/bin/node"
which("foobar")  // null
</code></pre>
<h2 id="cwd---string"><a class="header" href="#cwd---string">cwd() -&gt; string</a></h2>
<p>Returns the current working directory as a string.</p>
<pre><code class="language-forge">say cwd()  // "/home/alice/project"
</code></pre>
<h2 id="cdpath---null"><a class="header" href="#cdpath---null">cd(path) -&gt; null</a></h2>
<p>Changes the current working directory.</p>
<pre><code class="language-forge">cd("/tmp")
say cwd()  // "/tmp"
</code></pre>
<h2 id="pipe_tocommand-input---string"><a class="header" href="#pipe_tocommand-input---string">pipe_to(command, input) -&gt; string</a></h2>
<p>Pipes <code>input</code> as stdin to the given command and returns stdout.</p>
<pre><code class="language-forge">let sorted = pipe_to("sort", "banana\napple\ncherry")
say sorted
// apple
// banana
// cherry
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="assertion-functions"><a class="header" href="#assertion-functions">Assertion Functions</a></h1>
<p>Functions for testing and validation. Assertion failures produce runtime errors with descriptive messages.</p>
<h2 id="assertcondition-message---null"><a class="header" href="#assertcondition-message---null">assert(condition, message?) -&gt; null</a></h2>
<p>Asserts that <code>condition</code> is truthy. Throws a runtime error if false.</p>
<pre><code class="language-forge">assert(1 + 1 == 2)
assert(len("hello") &gt; 0, "string should not be empty")
</code></pre>
<h2 id="assert_eqactual-expected-message---null"><a class="header" href="#assert_eqactual-expected-message---null">assert_eq(actual, expected, message?) -&gt; null</a></h2>
<p>Asserts that <code>actual</code> equals <code>expected</code>. Shows both values on failure.</p>
<pre><code class="language-forge">assert_eq(1 + 1, 2)
assert_eq(sort([3, 1, 2]), [1, 2, 3])
assert_eq(user.name, "Alice", "user name mismatch")
</code></pre>
<h2 id="assert_neactual-expected-message---null"><a class="header" href="#assert_neactual-expected-message---null">assert_ne(actual, expected, message?) -&gt; null</a></h2>
<p>Asserts that <code>actual</code> does not equal <code>expected</code>.</p>
<pre><code class="language-forge">assert_ne(1, 2)
assert_ne(user.role, "admin", "user should not be admin")
</code></pre>
<h2 id="assert_throwsfn-message---null"><a class="header" href="#assert_throwsfn-message---null">assert_throws(fn, message?) -&gt; null</a></h2>
<p>Asserts that calling <code>fn</code> produces a runtime error. Useful for testing error handling.</p>
<pre><code class="language-forge">assert_throws(fn() { int("not a number") })
assert_throws(fn() { bruh "expected crash" })
</code></pre>
<h2 id="satisfiesvalue-interface---bool"><a class="header" href="#satisfiesvalue-interface---bool">satisfies(value, interface) -&gt; bool</a></h2>
<p>Checks whether <code>value</code> structurally satisfies an <code>interface</code> (Go-style structural typing). Returns <code>true</code> if the value has all methods specified by the interface, either through the environment or through <code>give</code>/<code>impl</code> blocks.</p>
<pre><code class="language-forge">power Printable {
    fn to_string() -&gt; string
}

thing User {
    name: string
}

give User {
    fn to_string() {
        return self.name
    }
}

let u = User { name: "Alice" }
assert(satisfies(u, Printable))
</code></pre>
<p>See the <a href="#interface-types">Type System</a> chapter for more details on interface satisfaction.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="genz-debug-kit"><a class="header" href="#genz-debug-kit">GenZ Debug Kit</a></h1>
<p>A set of debugging and assertion functions with personality. These are fully functional tools with expressive error messages – not just jokes.</p>
<h2 id="susvalue---value"><a class="header" href="#susvalue---value">sus(value) -&gt; value</a></h2>
<p>Inspects a value and prints its type and content to stderr, then returns the value unchanged. Works like Rust’s <code>dbg!</code> macro – you can wrap any expression without changing program behavior.</p>
<pre><code class="language-forge">let x = sus(42)
// stderr: 🔍 SUS CHECK: 42 (Int)
// x is still 42

let result = sus(http.get("https://api.example.com"))
// Prints the response object, then returns it
</code></pre>
<h2 id="bruhmessage---never"><a class="header" href="#bruhmessage---never">bruh(message?) -&gt; never</a></h2>
<p>Panics with a runtime error. Equivalent to <code>panic!</code> in Rust. Default message: “something ain’t right”.</p>
<pre><code class="language-forge">bruh "database connection lost"
// Error: BRUH: database connection lost

bruh
// Error: BRUH: something ain't right
</code></pre>
<h2 id="betcondition-message---bool"><a class="header" href="#betcondition-message---bool">bet(condition, message?) -&gt; bool</a></h2>
<p>Asserts that <code>condition</code> is truthy. Returns <code>true</code> on success, errors on failure. Equivalent to <code>assert</code>.</p>
<pre><code class="language-forge">bet(user.age &gt;= 18, "user must be an adult")
// On failure: Error: LOST THE BET: user must be an adult

bet(1 + 1 == 2)  // passes, returns true
</code></pre>
<h2 id="no_capa-b---bool"><a class="header" href="#no_capa-b---bool">no_cap(a, b) -&gt; bool</a></h2>
<p>Asserts that <code>a</code> equals <code>b</code>. Returns <code>true</code> on success, errors on failure. Equivalent to <code>assert_eq</code>.</p>
<pre><code class="language-forge">no_cap(1 + 1, 2)  // passes
no_cap("hello", "world")
// Error: CAP DETECTED: hello ≠ world
</code></pre>
<h2 id="ickcondition-message---bool"><a class="header" href="#ickcondition-message---bool">ick(condition, message?) -&gt; bool</a></h2>
<p>Asserts that <code>condition</code> is <strong>false</strong>. Returns <code>true</code> when the condition is false, errors when true. The inverse of <code>bet</code>.</p>
<pre><code class="language-forge">ick(user.banned, "user should not be banned")
// On failure: Error: ICK: user should not be banned

ick(false)  // passes, returns true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="execution-helpers"><a class="header" href="#execution-helpers">Execution Helpers</a></h1>
<p>Higher-order functions for profiling, error handling, and benchmarking.</p>
<h2 id="cookfn---any"><a class="header" href="#cookfn---any">cook(fn) -&gt; any</a></h2>
<p>Executes <code>fn</code>, measures its execution time, and prints a performance report to stderr. Returns the function’s return value.</p>
<pre><code class="language-forge">let result = cook(fn() {
    let total = 0
    for i in range(0, 1000000) {
        total = total + i
    }
    return total
})
// stderr: 👨‍🍳 COOKED: done in 42.15ms — it's giving adequate
// result contains the computed total
</code></pre>
<p>Performance messages vary by duration:</p>
<ul>
<li>Under 1ms: “speed demon fr”</li>
<li>1-100ms: “no cap that was fast”</li>
<li>100ms-1s: “it’s giving adequate”</li>
<li>Over 1s: “bruh that took a minute”</li>
</ul>
<h2 id="yolofn---any--none"><a class="header" href="#yolofn---any--none">yolo(fn) -&gt; any | None</a></h2>
<p>Executes <code>fn</code> and swallows all errors. Returns the function’s result on success, or <code>None</code> on failure. Useful for non-critical operations where errors can be safely ignored.</p>
<pre><code class="language-forge">let data = yolo(fn() {
    return fs.read("maybe-missing.txt")
})
// data is the file contents or None

if is_none(data) {
    say "File not found, using defaults"
}
</code></pre>
<h2 id="ghostfn---any"><a class="header" href="#ghostfn---any">ghost(fn) -&gt; any</a></h2>
<p>Executes <code>fn</code> silently. The function runs normally and its return value is passed through, but intended for cases where you want to suppress side effects.</p>
<pre><code class="language-forge">let result = ghost(fn() {
    return compute_something()
})
</code></pre>
<h2 id="slayfn-iterations---object"><a class="header" href="#slayfn-iterations---object">slay(fn, iterations?) -&gt; object</a></h2>
<p>Benchmarks <code>fn</code> by running it <code>iterations</code> times (default: 100). Prints a summary to stderr and returns a statistics object.</p>
<p><strong>Returns:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>avg_ms</code></td><td><code>float</code></td><td>Average time per iteration in milliseconds</td></tr>
<tr><td><code>min_ms</code></td><td><code>float</code></td><td>Minimum time in milliseconds</td></tr>
<tr><td><code>max_ms</code></td><td><code>float</code></td><td>Maximum time in milliseconds</td></tr>
<tr><td><code>p99_ms</code></td><td><code>float</code></td><td>99th percentile time in milliseconds</td></tr>
<tr><td><code>runs</code></td><td><code>int</code></td><td>Number of iterations</td></tr>
<tr><td><code>result</code></td><td><code>any</code></td><td>Return value of the last iteration</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">let stats = slay(fn() {
    return math.pow(2, 20)
}, 1000)

// stderr: 💅 SLAYED: 1000x runs — avg 0.003ms, min 0.001ms, max 0.012ms, p99 0.008ms

say stats.avg_ms   // 0.003
say stats.runs     // 1000
say stats.result   // 1048576
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dual-syntax-philosophy"><a class="header" href="#dual-syntax-philosophy">Dual Syntax Philosophy</a></h1>
<h2 id="principle"><a class="header" href="#principle">Principle</a></h2>
<p>Every construct in Forge has two spellings: a <strong>classic</strong> form familiar to programmers coming from C, Rust, or JavaScript, and a <strong>natural</strong> form that reads closer to English. Both forms compile to the exact same AST and execute identically. There is no performance difference, no feature difference, and no hidden cost.</p>
<h2 id="why-dual-syntax"><a class="header" href="#why-dual-syntax">Why Dual Syntax?</a></h2>
<p>Programming languages force a false choice: be accessible or be powerful. Forge rejects this tradeoff.</p>
<ul>
<li><strong>Classic syntax</strong> serves experienced developers who think in <code>fn</code>, <code>let</code>, and <code>else</code>. It is terse and precise.</li>
<li><strong>Natural syntax</strong> serves learners, scripters, and domain experts who prefer <code>define</code>, <code>set</code>, and <code>otherwise</code>. It reduces the cognitive barrier to writing code.</li>
</ul>
<p>Neither form is “training wheels.” Both are first-class citizens of the language.</p>
<h2 id="rules"><a class="header" href="#rules">Rules</a></h2>
<ol>
<li><strong>Both forms are always available.</strong> No mode switches, no compiler flags, no feature gates.</li>
<li><strong>They can be mixed freely.</strong> You can use <code>let</code> on one line and <code>set</code> on the next. A file can use <code>fn</code> for one function and <code>define</code> for another.</li>
<li><strong>The AST is identical.</strong> The parser recognizes both spellings and produces the same node. <code>let x = 5</code> and <code>set x to 5</code> produce an identical <code>LetDecl</code> AST node.</li>
<li><strong>Error messages normalize.</strong> Runtime errors use the classic form regardless of which syntax the programmer used.</li>
<li><strong>Formatting preserves choice.</strong> <code>forge fmt</code> does not convert between forms. Your stylistic choice is respected.</li>
</ol>
<h2 id="example-mixed-syntax"><a class="header" href="#example-mixed-syntax">Example: Mixed Syntax</a></h2>
<pre><code class="language-forge">// Classic variable, natural function
let name = "Alice"
define greet(person) {
    say "Hello, " + person
}

// Natural variable, classic function
set age to 30
fn is_adult(a) {
    return a &gt;= 18
}

// Both work together seamlessly
if is_adult(age) {
    greet(name)
} otherwise {
    say "Too young"
}
</code></pre>
<h2 id="design-guideline"><a class="header" href="#design-guideline">Design Guideline</a></h2>
<p>When in doubt, use whichever form your team agrees on. For library code shared publicly, classic syntax is conventional. For scripts, tutorials, and learning materials, natural syntax often reads better.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="syntax-mapping"><a class="header" href="#syntax-mapping">Syntax Mapping</a></h1>
<p>Complete mapping between classic and natural forms. Both compile to identical AST nodes.</p>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>let x = 5</code></td><td><code>set x to 5</code></td><td>Immutable binding</td></tr>
<tr><td><code>let mut x = 0</code></td><td><code>set mut x to 0</code></td><td>Mutable binding</td></tr>
<tr><td><code>x = 10</code></td><td><code>change x to 10</code></td><td>Reassignment</td></tr>
<tr><td><code>let {a, b} = obj</code></td><td><code>unpack {a, b} from obj</code></td><td>Destructuring</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">// Classic
let name = "Alice"
let mut count = 0
count = count + 1

// Natural
set name to "Alice"
set mut count to 0
change count to count + 1
</code></pre>
<h2 id="functions-14"><a class="header" href="#functions-14">Functions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fn add(a, b) { }</code></td><td><code>define add(a, b) { }</code></td><td>Function definition</td></tr>
<tr><td><code>async fn fetch() { }</code></td><td><code>forge fetch() { }</code></td><td>Async function</td></tr>
<tr><td><code>return value</code></td><td><code>return value</code></td><td>Return (same in both)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">// Classic
fn greet(name) {
    return "Hello, " + name
}

// Natural
define greet(name) {
    return "Hello, " + name
}
</code></pre>
<h2 id="control-flow-2"><a class="header" href="#control-flow-2">Control Flow</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>else { }</code></td><td><code>otherwise { }</code></td><td>Else branch</td></tr>
<tr><td><code>else { }</code></td><td><code>nah { }</code></td><td>Else branch (casual)</td></tr>
<tr><td><code>else if</code></td><td><code>otherwise if</code></td><td>Else-if branch</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">// Classic
if x &gt; 0 {
    say "positive"
} else if x == 0 {
    say "zero"
} else {
    say "negative"
}

// Natural
if x &gt; 0 {
    say "positive"
} otherwise if x == 0 {
    say "zero"
} nah {
    say "negative"
}
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>println("text")</code></td><td><code>say "text"</code></td><td>Print with newline</td></tr>
<tr><td><code>print("text")</code></td><td><code>print("text")</code></td><td>Print without newline</td></tr>
<tr><td>–</td><td><code>yell "text"</code></td><td>Print uppercased</td></tr>
<tr><td>–</td><td><code>whisper "text"</code></td><td>Print lowercased</td></tr>
</tbody>
</table>
</div>
<h2 id="types-and-structures"><a class="header" href="#types-and-structures">Types and Structures</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>struct User { }</code></td><td><code>thing User { }</code></td><td>Struct definition</td></tr>
<tr><td><code>impl User { }</code></td><td><code>give User { }</code></td><td>Method implementation</td></tr>
<tr><td><code>interface Printable { }</code></td><td><code>power Printable { }</code></td><td>Interface definition</td></tr>
<tr><td><code>enum Color { }</code></td><td><code>craft Color { }</code></td><td>Enum definition</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">// Classic
struct User {
    name: string,
    age: int
}

impl User {
    fn greet(self) {
        say "Hi, I'm " + self.name
    }
}

// Natural
thing User {
    name: string,
    age: int
}

give User {
    fn greet(self) {
        say "Hi, I'm " + self.name
    }
}
</code></pre>
<h2 id="async--concurrency"><a class="header" href="#async--concurrency">Async / Concurrency</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>async fn x() { }</code></td><td><code>forge x() { }</code></td><td>Async function</td></tr>
<tr><td><code>await expr</code></td><td><code>hold expr</code></td><td>Await an async value</td></tr>
<tr><td><code>yield value</code></td><td><code>emit value</code></td><td>Yield from a generator</td></tr>
<tr><td><code>fetch("url")</code></td><td><code>grab resp from "url"</code></td><td>HTTP fetch</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">// Classic
async fn get_data() {
    let resp = await fetch("https://api.example.com/data")
    return resp
}

// Natural
forge get_data() {
    let resp = hold grab data from "https://api.example.com/data"
    return resp
}
</code></pre>
<h2 id="pattern-matching-2"><a class="header" href="#pattern-matching-2">Pattern Matching</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th></tr>
</thead>
<tbody>
<tr><td><code>match value { }</code></td><td><code>match value { }</code></td></tr>
<tr><td><code>when value { }</code></td><td><code>when value { }</code></td></tr>
</tbody>
</table>
</div>
<p>Both <code>match</code> and <code>when</code> are available; <code>when</code> supports guard-style syntax unique to Forge (see <a href="#innovation-keywords-1">Innovation Keywords</a>).</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Classic</th><th>Natural</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>has InterfaceName</code></td><td><code>has InterfaceName</code></td><td>Interface conformance assertion</td></tr>
</tbody>
</table>
</div>
<p>The <code>has</code> keyword asserts that a type satisfies an interface at the point of declaration.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="innovation-keywords-1"><a class="header" href="#innovation-keywords-1">Innovation Keywords</a></h1>
<p>Keywords unique to Forge that have no direct equivalent in other mainstream languages. These are not aliases – they introduce genuinely new constructs.</p>
<h2 id="when-guards-1"><a class="header" href="#when-guards-1">when Guards</a></h2>
<p>Pattern matching with comparison guards. Unlike <code>match</code>, <code>when</code> tests a single value against comparison operators.</p>
<pre><code class="language-forge">let score = 85
let grade = when score {
    &gt;= 90 -&gt; "A",
    &gt;= 80 -&gt; "B",
    &gt;= 70 -&gt; "C",
    &gt;= 60 -&gt; "D",
    else -&gt; "F"
}
say grade  // "B"
</code></pre>
<p>The <code>else</code> arm is required and handles any unmatched case.</p>
<h2 id="must"><a class="header" href="#must">must</a></h2>
<p>Unwraps a Result or crashes with a clear error message. Used when failure is unrecoverable.</p>
<pre><code class="language-forge">let data = must fs.read("config.json")
// If the file doesn't exist, the program crashes with a descriptive error
</code></pre>
<h2 id="safe"><a class="header" href="#safe">safe</a></h2>
<p>Null-safe execution block. If any expression inside <code>safe</code> would error, the block evaluates to <code>null</code> instead of crashing. Statement-only (cannot be used as an expression).</p>
<pre><code class="language-forge">safe {
    let data = fs.read("maybe-missing.txt")
    say data
}
// If file is missing, execution continues silently
</code></pre>
<h2 id="check--is-not-empty"><a class="header" href="#check--is-not-empty">check … is not empty</a></h2>
<p>Declarative validation. Checks a condition and produces a validation error if it fails.</p>
<pre><code class="language-forge">check name is not empty
check age &gt;= 0
check email contains "@"
</code></pre>
<h2 id="retry-n-times"><a class="header" href="#retry-n-times">retry N times</a></h2>
<p>Automatically retries a block up to N times on failure.</p>
<pre><code class="language-forge">retry 3 times {
    let resp = http.get("https://flaky-api.example.com/data")
    say resp.json
}
</code></pre>
<p>If all retries fail, the error from the last attempt is raised.</p>
<h2 id="timeout-n-seconds"><a class="header" href="#timeout-n-seconds">timeout N seconds</a></h2>
<p>Limits execution time for a block. If the block does not complete within the time limit, it is interrupted.</p>
<pre><code class="language-forge">timeout 5 seconds {
    let result = http.get("https://slow-api.example.com")
    say result.json
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> This feature is experimental and may not interrupt all operations cleanly.</p>
</blockquote>
<h2 id="schedule-every-n-units"><a class="header" href="#schedule-every-n-units">schedule every N units</a></h2>
<p>Runs a block repeatedly on a schedule (cron-like).</p>
<pre><code class="language-forge">schedule every 5 minutes {
    let status = http.get("https://api.example.com/health")
    if status.status != 200 {
        log.error("Health check failed!")
    }
}
</code></pre>
<p>Supported units: <code>seconds</code>, <code>minutes</code>, <code>hours</code>.</p>
<h2 id="watch-path"><a class="header" href="#watch-path">watch “path”</a></h2>
<p>Monitors a file or directory for changes and executes the block when changes are detected.</p>
<pre><code class="language-forge">watch "src/" {
    say "Files changed, rebuilding..."
    sh("cargo build")
}
</code></pre>
<h2 id="ask-prompt"><a class="header" href="#ask-prompt">ask “prompt”</a></h2>
<p>Sends a prompt to an AI/LLM and returns the response. Requires AI configuration.</p>
<pre><code class="language-forge">let answer = ask "What is the capital of France?"
say answer  // "Paris"
</code></pre>
<h2 id="download-url-to-file"><a class="header" href="#download-url-to-file">download “url” to “file”</a></h2>
<p>Downloads a file from a URL and saves it to disk. Syntax sugar for <code>http.download</code>.</p>
<pre><code class="language-forge">download "https://example.com/data.csv" to "data.csv"
</code></pre>
<h2 id="crawl-url"><a class="header" href="#crawl-url">crawl “url”</a></h2>
<p>Fetches and parses a web page, returning structured data. Syntax sugar for <code>http.crawl</code>.</p>
<pre><code class="language-forge">let page = crawl "https://example.com"
say page.title
say page.links
</code></pre>
<h2 id="repeat-n-times-1"><a class="header" href="#repeat-n-times-1">repeat N times</a></h2>
<p>Executes a block exactly N times. A counted loop without a loop variable.</p>
<pre><code class="language-forge">repeat 5 times {
    say "Hello!"
}
</code></pre>
<h2 id="wait-n-units"><a class="header" href="#wait-n-units">wait N units</a></h2>
<p>Pauses execution for the specified duration.</p>
<pre><code class="language-forge">wait 2 seconds
wait 500 milliseconds
</code></pre>
<p>Supported units: <code>seconds</code>, <code>milliseconds</code>, <code>minutes</code>.</p>
<h2 id="grab--from-url"><a class="header" href="#grab--from-url">grab … from “url”</a></h2>
<p>Natural syntax for HTTP fetch. Assigns the response to a variable.</p>
<pre><code class="language-forge">grab data from "https://api.example.com/users"
say data
</code></pre>
<h2 id="emit-value"><a class="header" href="#emit-value">emit value</a></h2>
<p>Yields a value from a generator function. Natural equivalent of <code>yield</code>.</p>
<pre><code class="language-forge">fn fibonacci() {
    let a = 0
    let b = 1
    loop {
        emit a
        let temp = a + b
        a = b
        b = temp
    }
}
</code></pre>
<h2 id="hold-expr"><a class="header" href="#hold-expr">hold expr</a></h2>
<p>Awaits an async expression. Natural equivalent of <code>await</code>.</p>
<pre><code class="language-forge">forge fetch_data() {
    let resp = hold http.get("https://api.example.com")
    return resp.json
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="execution-model-2"><a class="header" href="#execution-model-2">Execution Model</a></h1>
<p>Forge provides three execution tiers, selectable at the command line. All tiers accept the same source files; they differ in feature coverage, performance, and implementation strategy.</p>
<h2 id="three-tiers"><a class="header" href="#three-tiers">Three Tiers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tier</th><th>Flag</th><th>Implementation</th><th>Performance</th><th>Feature Coverage</th></tr>
</thead>
<tbody>
<tr><td>Interpreter</td><td>(default)</td><td>Tree-walking</td><td>Baseline</td><td>Full (100%)</td></tr>
<tr><td>Bytecode VM</td><td><code>--vm</code></td><td>Register-based VM</td><td>~10x faster than interpreter</td><td>Partial (~60%)</td></tr>
<tr><td>JIT Compiler</td><td><code>--jit</code></td><td>Cranelift native code</td><td>~50-100x faster than interpreter</td><td>Minimal (~30%)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-bash">forge run program.fg          # Interpreter (default)
forge run program.fg --vm     # Bytecode VM
forge run program.fg --jit    # JIT compiler
</code></pre>
<h2 id="when-to-use-each-tier"><a class="header" href="#when-to-use-each-tier">When to Use Each Tier</a></h2>
<h3 id="interpreter-default"><a class="header" href="#interpreter-default">Interpreter (Default)</a></h3>
<p>Use the interpreter for:</p>
<ul>
<li>All general-purpose development</li>
<li>HTTP servers (<code>@server</code>, <code>@get</code>, <code>@post</code>)</li>
<li>Database access (<code>db</code>, <code>pg</code>)</li>
<li>AI integration (<code>ask</code>)</li>
<li>File system, crypto, terminal UI</li>
<li>Any code using the full standard library</li>
</ul>
<p>The interpreter supports every feature of the language. It is the reference implementation.</p>
<h3 id="bytecode-vm---vm"><a class="header" href="#bytecode-vm---vm">Bytecode VM (<code>--vm</code>)</a></h3>
<p>Use the VM for:</p>
<ul>
<li>Compute-intensive loops and numerical work</li>
<li>Programs that primarily use <code>math</code>, <code>fs</code>, <code>io</code>, and basic control flow</li>
<li>Benchmarking against the interpreter</li>
</ul>
<p>The VM compiles Forge source to a register-based bytecode and executes it in a virtual machine with mark-sweep garbage collection. It does not support HTTP servers, database connections, or several stdlib modules.</p>
<h3 id="jit-compiler---jit"><a class="header" href="#jit-compiler---jit">JIT Compiler (<code>--jit</code>)</a></h3>
<p>Use the JIT for:</p>
<ul>
<li>Maximum performance on hot numerical code</li>
<li>Benchmarking (e.g., <code>fib(30)</code> runs 11x faster than Python)</li>
<li>Functions that are purely computational</li>
</ul>
<p>The JIT compiles hot functions to native machine code via Cranelift. It supports the smallest subset of the language – primarily arithmetic, function calls, and basic control flow.</p>
<h2 id="trade-off-summary"><a class="header" href="#trade-off-summary">Trade-off Summary</a></h2>
<pre><code>Feature Coverage:  Interpreter &gt; VM &gt; JIT
Performance:       JIT &gt; VM &gt; Interpreter
Startup Time:      Interpreter &lt; VM &lt; JIT
</code></pre>
<p>The interpreter is always the safe default. Switch to <code>--vm</code> or <code>--jit</code> only when you need the performance and have verified your program works on that tier.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h1>
<p>The Forge interpreter is a <strong>tree-walking interpreter</strong> implemented in Rust. It traverses the AST directly, evaluating each node as it encounters it. This is the default and most complete execution engine.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code>Source (.fg) -&gt; Lexer -&gt; Parser -&gt; AST -&gt; Interpreter -&gt; Result
                                            |
                                     Environment (scopes)
                                            |
                                     Runtime Bridge
                                  (axum, reqwest, tokio, rusqlite)
</code></pre>
<p>The interpreter lives in <code>src/interpreter/mod.rs</code> (~8,100 lines) and is the largest single file in the codebase.</p>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<p>The interpreter maintains a stack of scopes. Each scope is an <code>IndexMap&lt;String, Value&gt;</code> that maps names to values. Variable resolution walks the scope stack from innermost to outermost.</p>
<ul>
<li><strong>Global scope</strong>: Pre-populated with all 16 stdlib modules and all built-in functions.</li>
<li><strong>Function scope</strong>: Created on each function call, closed over by lambdas.</li>
<li><strong>Block scope</strong>: Created for <code>if</code>, <code>for</code>, <code>while</code>, and other block statements.</li>
</ul>
<h3 id="value-type"><a class="header" href="#value-type">Value Type</a></h3>
<p>The <code>Value</code> enum represents all runtime values:</p>
<ul>
<li><code>Int(i64)</code> – 64-bit integer</li>
<li><code>Float(f64)</code> – 64-bit float</li>
<li><code>Bool(bool)</code> – boolean</li>
<li><code>String(String)</code> – heap-allocated string</li>
<li><code>Array(Vec&lt;Value&gt;)</code> – dynamic array</li>
<li><code>Object(IndexMap&lt;String, Value&gt;)</code> – ordered key-value map</li>
<li><code>Null</code> – null value</li>
<li><code>Function { params, body, closure }</code> – named function with captured environment</li>
<li><code>Lambda { params, body, closure }</code> – anonymous function</li>
<li><code>BuiltIn(String)</code> – reference to a built-in function by name</li>
<li><code>ResultOk(Box&lt;Value&gt;)</code> / <code>ResultErr(Box&lt;Value&gt;)</code> – Result type</li>
<li><code>Some(Box&lt;Value&gt;)</code> / <code>None</code> – Option type</li>
<li><code>Channel(Arc&lt;ChannelInner&gt;)</code> – concurrency channel</li>
<li><code>TaskHandle(Arc&lt;TaskInner&gt;)</code> – async task handle</li>
</ul>
<h3 id="dispatch"><a class="header" href="#dispatch">Dispatch</a></h3>
<p>Built-in function dispatch is a single large <code>match</code> statement in <code>call_builtin</code>. When a <code>BuiltIn("name")</code> value is called, the interpreter matches on the name string and executes the corresponding Rust code.</p>
<p>Stdlib module functions (e.g., <code>math.sqrt</code>) are dispatched through the module’s <code>call</code> function. The interpreter detects dot-access on a module object and routes the call to the appropriate module.</p>
<h2 id="features-unique-to-the-interpreter"><a class="header" href="#features-unique-to-the-interpreter">Features Unique to the Interpreter</a></h2>
<p>The following features are <strong>only</strong> available in the interpreter tier:</p>
<ul>
<li>HTTP server (<code>@server</code>, <code>@get</code>, <code>@post</code>, <code>@delete</code>, <code>@ws</code>)</li>
<li>Database access (<code>db.open</code>, <code>db.query</code>, <code>pg.connect</code>)</li>
<li>AI integration (<code>ask</code>)</li>
<li>Web scraping (<code>crawl</code>)</li>
<li>File download (<code>download ... to</code>)</li>
<li>Terminal UI widgets (<code>term.table</code>, <code>term.menu</code>, <code>term.confirm</code>)</li>
<li>GenZ debug kit (<code>sus</code>, <code>bruh</code>, <code>bet</code>, <code>no_cap</code>, <code>ick</code>)</li>
<li>Execution helpers (<code>cook</code>, <code>yolo</code>, <code>ghost</code>, <code>slay</code>)</li>
<li>Concurrency (<code>channel</code>, <code>send</code>, <code>receive</code>, <code>spawn</code>)</li>
</ul>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<p>The tree-walking approach means the interpreter re-traverses the AST on every loop iteration and function call. This makes it approximately 20x slower than Python for deep recursion benchmarks like <code>fib(35)</code>.</p>
<p>For most real-world scripts (file processing, HTTP handlers, database queries), interpreter overhead is negligible compared to I/O latency. The interpreter is the recommended tier for all general-purpose work.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bytecode-vm"><a class="header" href="#bytecode-vm">Bytecode VM</a></h1>
<p>The Forge bytecode VM is a <strong>register-based virtual machine</strong> that compiles Forge source to 32-bit instructions and executes them in a loop. It provides significantly better performance than the tree-walking interpreter at the cost of reduced feature coverage.</p>
<h2 id="invocation-1"><a class="header" href="#invocation-1">Invocation</a></h2>
<pre><code class="language-bash">forge run program.fg --vm
</code></pre>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<pre><code>Source -&gt; Lexer -&gt; Parser -&gt; AST -&gt; Compiler -&gt; Bytecode Chunks -&gt; Machine -&gt; Result
                                                                     |
                                                              Mark-Sweep GC
                                                                     |
                                                              Green Threads
</code></pre>
<p>Key source files:</p>
<ul>
<li><code>src/vm/compiler.rs</code> (~927 lines) – AST to bytecode compilation</li>
<li><code>src/vm/machine.rs</code> (~2,483 lines) – bytecode execution engine</li>
<li><code>src/vm/bytecode.rs</code> – instruction set definition</li>
<li><code>src/vm/gc.rs</code> – mark-sweep garbage collector</li>
<li><code>src/vm/frame.rs</code> – call frame management</li>
<li><code>src/vm/value.rs</code> – VM-specific value type</li>
<li><code>src/vm/green.rs</code> – green thread scheduler</li>
</ul>
<h2 id="instruction-encoding"><a class="header" href="#instruction-encoding">Instruction Encoding</a></h2>
<p>All instructions are 32 bits wide. Three encoding formats:</p>
<h3 id="abc-format-op8a8b8c8"><a class="header" href="#abc-format-op8a8b8c8">ABC Format: <code>[op:8][a:8][b:8][c:8]</code></a></h3>
<p>Used for register-to-register operations. <code>a</code> is typically the destination register; <code>b</code> and <code>c</code> are source registers.</p>
<h3 id="abx-format-op8a8bx16"><a class="header" href="#abx-format-op8a8bx16">ABx Format: <code>[op:8][a:8][bx:16]</code></a></h3>
<p>Used for instructions with a larger operand, such as constant loading. <code>bx</code> is an unsigned 16-bit index.</p>
<h3 id="asbx-format-op8a8sbx16"><a class="header" href="#asbx-format-op8a8sbx16">AsBx Format: <code>[op:8][a:8][sbx:16]</code></a></h3>
<p>Used for jump instructions. <code>sbx</code> is a signed 16-bit offset stored as unsigned (with bias).</p>
<blockquote>
<p><strong>Important:</strong> The VM pre-increments IP before applying jump offsets. The JIT target address is <code>ip + 1 + sbx</code>, not <code>ip + sbx</code>.</p>
</blockquote>
<h2 id="register-machine"><a class="header" href="#register-machine">Register Machine</a></h2>
<p>The VM uses a register-based architecture rather than a stack-based one. Each call frame has its own register window. Registers are addressed by 8-bit indices, allowing up to 256 registers per frame.</p>
<p>Benefits:</p>
<ul>
<li>Fewer instructions than a stack VM (no push/pop for every operand)</li>
<li>Better cache locality for register access</li>
<li>Natural fit for the JIT tier</li>
</ul>
<h2 id="constant-pool"><a class="header" href="#constant-pool">Constant Pool</a></h2>
<p>Each compiled function (called a “Chunk”) has a constant pool for literals, strings, and function prototypes. Constants are deduplicated via <code>identical()</code> comparison to avoid wasting pool slots.</p>
<h2 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h2>
<p>The VM uses a <strong>mark-sweep garbage collector</strong>. Heap-allocated objects (strings, arrays, objects, closures) are tracked by the GC. Collection is triggered when the allocation count exceeds a threshold.</p>
<p>The mark phase walks from GC roots (registers, global environment, call stack). The sweep phase frees unreachable objects.</p>
<h2 id="green-threads"><a class="header" href="#green-threads">Green Threads</a></h2>
<p>The VM includes a cooperative green thread scheduler (<code>src/vm/green.rs</code>). Green threads are multiplexed over a single OS thread with explicit yield points.</p>
<h2 id="supported-features"><a class="header" href="#supported-features">Supported Features</a></h2>
<p>The VM supports core language features:</p>
<ul>
<li>Variables, functions, closures</li>
<li>Control flow (if/else, for, while, match)</li>
<li>Arrays and objects</li>
<li>Arithmetic and comparison operators</li>
<li>String operations</li>
<li><code>math</code>, <code>fs</code>, <code>io</code>, <code>npc</code> modules</li>
<li>Basic built-in functions</li>
</ul>
<h2 id="unsupported-features"><a class="header" href="#unsupported-features">Unsupported Features</a></h2>
<p>The following require the interpreter:</p>
<ul>
<li>HTTP server and client</li>
<li>Database connections</li>
<li>AI integration</li>
<li>Terminal UI widgets</li>
<li>Most execution helpers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="jit-compiler"><a class="header" href="#jit-compiler">JIT Compiler</a></h1>
<p>The Forge JIT compiler translates hot bytecode functions into native machine code using the <strong>Cranelift</strong> code generator. It provides the highest performance tier, achieving approximately 11x faster execution than Python on recursive benchmarks like <code>fib(30)</code>.</p>
<h2 id="invocation-2"><a class="header" href="#invocation-2">Invocation</a></h2>
<pre><code class="language-bash">forge run program.fg --jit
</code></pre>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<pre><code>Source -&gt; Lexer -&gt; Parser -&gt; AST -&gt; Compiler -&gt; Bytecode -&gt; JIT -&gt; Native Code
                                                             |
                                                      Cranelift IR
                                                             |
                                                    Machine Code (x86_64/AArch64)
</code></pre>
<p>Key source files:</p>
<ul>
<li><code>src/vm/jit/ir_builder.rs</code> (~276 lines) – Bytecode to Cranelift IR translation</li>
<li><code>src/vm/jit/jit_module.rs</code> (~47 lines) – JIT module management</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<ol>
<li>The program is first compiled to bytecode (same as the <code>--vm</code> path).</li>
<li>Functions selected for JIT compilation are translated from bytecode into Cranelift’s intermediate representation (IR).</li>
<li>Cranelift compiles the IR to native machine code for the host architecture.</li>
<li>The native code is loaded into memory and called directly, bypassing the bytecode interpreter.</li>
</ol>
<h2 id="cranelift-ir-translation"><a class="header" href="#cranelift-ir-translation">Cranelift IR Translation</a></h2>
<p>The IR builder walks the bytecode instruction stream and emits Cranelift IR operations:</p>
<ul>
<li>Arithmetic bytecodes (<code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>DIV</code>) map to Cranelift <code>iadd</code>, <code>isub</code>, <code>imul</code>, <code>sdiv</code>.</li>
<li>Comparison bytecodes map to Cranelift <code>icmp</code> with the appropriate condition.</li>
<li>Jump bytecodes map to Cranelift branch and block terminators.</li>
<li>Function calls generate Cranelift <code>call</code> instructions.</li>
</ul>
<h3 id="jump-offset-encoding"><a class="header" href="#jump-offset-encoding">Jump Offset Encoding</a></h3>
<p>The VM pre-increments the instruction pointer (IP) before applying jump offsets. When translating jumps to Cranelift blocks, the JIT target is calculated as:</p>
<pre><code>target = ip + 1 + sbx
</code></pre>
<p>This is a critical detail. Using <code>ip + sbx</code> produces incorrect branch targets.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>On <code>fib(30)</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Engine</th><th>Time</th><th>Relative</th></tr>
</thead>
<tbody>
<tr><td>Python 3</td><td>~330ms</td><td>1x</td></tr>
<tr><td>Forge interpreter</td><td>~6,600ms</td><td>0.05x</td></tr>
<tr><td>Forge VM</td><td>~660ms</td><td>0.5x</td></tr>
<tr><td>Forge JIT</td><td>~30ms</td><td>11x</td></tr>
</tbody>
</table>
</div>
<p>The JIT excels at tight numerical loops and recursive functions where the overhead of interpretation dominates.</p>
<h2 id="supported-features-1"><a class="header" href="#supported-features-1">Supported Features</a></h2>
<p>The JIT supports the most restricted subset:</p>
<ul>
<li>Integer and float arithmetic</li>
<li>Function calls and recursion</li>
<li>Basic control flow (if/else, loops)</li>
<li>Local variables</li>
<li>Comparisons and boolean logic</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>No string operations</li>
<li>No object or array construction</li>
<li>No standard library access</li>
<li>No closures or higher-order functions</li>
<li>No error handling (try/catch, Result)</li>
<li>Compilation overhead makes it unsuitable for short-running programs</li>
<li>Only beneficial for compute-heavy inner loops</li>
</ul>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h2>
<p>Cranelift supports:</p>
<ul>
<li>x86_64 (macOS, Linux, Windows)</li>
<li>AArch64 / ARM64 (macOS Apple Silicon, Linux)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="http-server"><a class="header" href="#http-server">HTTP Server</a></h1>
<p>Forge includes a built-in HTTP server powered by <strong>axum</strong> and <strong>tokio</strong>. Servers are defined declaratively using decorators and launched automatically when the interpreter detects a <code>@server</code> directive.</p>
<h2 id="architecture-3"><a class="header" href="#architecture-3">Architecture</a></h2>
<pre><code>Forge Source
    |
    v
Parser extracts decorators (@server, @get, @post, ...)
    |
    v
runtime/server.rs builds axum Router
    |
    v
axum + tokio serve requests
    |
    v
Each request locks the Interpreter mutex,
calls the handler function, serializes the return value as JSON
</code></pre>
<p>The server implementation lives in <code>src/runtime/server.rs</code> (~354 lines).</p>
<h2 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h2>
<p>The <code>@server</code> decorator configures the server:</p>
<pre><code class="language-forge">@server(port: 3000, host: "0.0.0.0")
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>port</code></td><td><code>int</code></td><td>8080</td><td>Listen port</td></tr>
<tr><td><code>host</code></td><td><code>string</code></td><td>“127.0.0.1”</td><td>Bind address</td></tr>
</tbody>
</table>
</div>
<h2 id="route-decorators"><a class="header" href="#route-decorators">Route Decorators</a></h2>
<h3 id="getpath"><a class="header" href="#getpath">@get(path?)</a></h3>
<p>Registers a function as a GET handler.</p>
<pre><code class="language-forge">@get("/users")
fn list_users() {
    return [{ name: "Alice" }, { name: "Bob" }]
}
</code></pre>
<h3 id="postpath"><a class="header" href="#postpath">@post(path?)</a></h3>
<p>Registers a function as a POST handler.</p>
<pre><code class="language-forge">@post("/users")
fn create_user(body) {
    say "Creating: " + body.name
    return { ok: true }
}
</code></pre>
<h3 id="putpath"><a class="header" href="#putpath">@put(path?)</a></h3>
<p>Registers a function as a PUT handler.</p>
<h3 id="deletepath"><a class="header" href="#deletepath">@delete(path?)</a></h3>
<p>Registers a function as a DELETE handler.</p>
<h3 id="wspath"><a class="header" href="#wspath">@ws(path?)</a></h3>
<p>Registers a function as a WebSocket handler. The function receives each incoming message as a string and returns a response string.</p>
<pre><code class="language-forge">@ws("/chat")
fn handle_message(msg) {
    return "Echo: " + msg
}
</code></pre>
<h2 id="path-parameters"><a class="header" href="#path-parameters">Path Parameters</a></h2>
<p>Path parameters use colon syntax (<code>:param</code>). They are automatically mapped to function parameters by name.</p>
<pre><code class="language-forge">@get("/users/:id")
fn get_user(id) {
    return { id: id, name: "User " + id }
}
// GET /users/42 -&gt; { id: "42", name: "User 42" }
</code></pre>
<p>The Forge path syntax (<code>:id</code>) is internally converted to axum’s brace syntax (<code>{id}</code>).</p>
<h2 id="handler-parameters-1"><a class="header" href="#handler-parameters-1">Handler Parameters</a></h2>
<p>Handler functions receive arguments based on their parameter names:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter Name</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td>Name matching a path param</td><td>URL path parameter</td></tr>
<tr><td><code>body</code> or <code>data</code></td><td>Parsed JSON request body</td></tr>
<tr><td><code>query</code> or <code>qs</code></td><td>Query string as an object</td></tr>
<tr><td>Name matching a query param</td><td>Individual query parameter</td></tr>
<tr><td>Other</td><td><code>null</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-forge">@post("/search")
fn search(body, query) {
    say "Search body: " + str(body)
    say "Query params: " + str(query)
    return { results: [] }
}
</code></pre>
<h2 id="json-serialization"><a class="header" href="#json-serialization">JSON Serialization</a></h2>
<p>Return values from handlers are automatically serialized to JSON:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Forge Type</th><th>JSON</th></tr>
</thead>
<tbody>
<tr><td><code>int</code></td><td>number</td></tr>
<tr><td><code>float</code></td><td>number</td></tr>
<tr><td><code>bool</code></td><td>boolean</td></tr>
<tr><td><code>string</code></td><td>string</td></tr>
<tr><td><code>null</code></td><td>null</td></tr>
<tr><td><code>array</code></td><td>array</td></tr>
<tr><td><code>object</code></td><td>object</td></tr>
<tr><td><code>ResultOk(v)</code></td><td><code>{"Ok": v}</code></td></tr>
<tr><td><code>ResultErr(v)</code></td><td><code>{"Err": v}</code></td></tr>
<tr><td>Other</td><td><code>"&lt;TypeName&gt;"</code></td></tr>
</tbody>
</table>
</div>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>If a handler function throws a runtime error, the server returns HTTP 500 with:</p>
<pre><code class="language-json">{ "error": "error message here" }
</code></pre>
<h2 id="cors"><a class="header" href="#cors">CORS</a></h2>
<p>CORS is enabled by default with a permissive policy (all origins, all methods, all headers). This is suitable for development; production deployments should add appropriate restrictions at the reverse proxy level.</p>
<h2 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h2>
<p>The interpreter is wrapped in an <code>Arc&lt;Mutex&lt;Interpreter&gt;&gt;</code>. Each incoming request acquires the mutex lock, calls the handler, and releases it. This means handlers execute serially – only one request is processed at a time.</p>
<p>For high-throughput scenarios, consider running multiple Forge server instances behind a load balancer.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="memory-model"><a class="header" href="#memory-model">Memory Model</a></h1>
<p>Forge uses different memory management strategies depending on the execution tier.</p>
<h2 id="interpreter-memory"><a class="header" href="#interpreter-memory">Interpreter Memory</a></h2>
<p>The interpreter uses Rust’s standard memory management with no garbage collector.</p>
<h3 id="value-representation"><a class="header" href="#value-representation">Value Representation</a></h3>
<p>All Forge values are represented by the <code>Value</code> enum in Rust. Heap-allocated variants:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Heap Allocation</th></tr>
</thead>
<tbody>
<tr><td><code>String(String)</code></td><td>Rust <code>String</code> (heap-allocated, growable)</td></tr>
<tr><td><code>Array(Vec&lt;Value&gt;)</code></td><td><code>Vec</code> on the heap</td></tr>
<tr><td><code>Object(IndexMap&lt;String, Value&gt;)</code></td><td><code>IndexMap</code> on the heap</td></tr>
<tr><td><code>Function { closure, ... }</code></td><td>Captured environment on the heap</td></tr>
<tr><td><code>Lambda { closure, ... }</code></td><td>Captured environment on the heap</td></tr>
<tr><td><code>Channel(Arc&lt;ChannelInner&gt;)</code></td><td>Reference-counted channel</td></tr>
<tr><td><code>TaskHandle(Arc&lt;TaskInner&gt;)</code></td><td>Reference-counted task</td></tr>
</tbody>
</table>
</div>
<p>Primitive types (<code>Int</code>, <code>Float</code>, <code>Bool</code>, <code>Null</code>) are stored inline without heap allocation.</p>
<h3 id="ownership-and-cloning"><a class="header" href="#ownership-and-cloning">Ownership and Cloning</a></h3>
<p>The interpreter clones values when:</p>
<ul>
<li>Passing arguments to functions</li>
<li>Returning values from functions</li>
<li>Assigning variables</li>
<li>Indexing into arrays or objects</li>
</ul>
<p>This is a simple, correct approach that avoids shared mutable state. The trade-off is increased memory allocation for large data structures.</p>
<h3 id="reference-counting"><a class="header" href="#reference-counting">Reference Counting</a></h3>
<p>Channels and task handles use <code>Arc</code> (atomic reference counting) for shared ownership across threads. When the last reference is dropped, the resource is freed.</p>
<h3 id="no-manual-memory-management"><a class="header" href="#no-manual-memory-management">No Manual Memory Management</a></h3>
<p>Forge programs never explicitly allocate or free memory. There is no <code>malloc</code>, <code>free</code>, <code>new</code>, or <code>delete</code>. Memory is managed entirely by the Rust runtime.</p>
<h2 id="vm-memory"><a class="header" href="#vm-memory">VM Memory</a></h2>
<p>The bytecode VM uses a <strong>mark-sweep garbage collector</strong> for heap-allocated objects.</p>
<h3 id="vm-value-representation"><a class="header" href="#vm-value-representation">VM Value Representation</a></h3>
<p>The VM has its own <code>Value</code> enum (in <code>src/vm/value.rs</code>) optimized for the register-based architecture:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Representation</th></tr>
</thead>
<tbody>
<tr><td><code>Int(i64)</code></td><td>Inline 64-bit integer</td></tr>
<tr><td><code>Float(f64)</code></td><td>Inline 64-bit float</td></tr>
<tr><td><code>Bool(bool)</code></td><td>Inline boolean</td></tr>
<tr><td><code>Null</code></td><td>Inline null marker</td></tr>
<tr><td><code>Obj(usize)</code></td><td>Index into the GC heap</td></tr>
</tbody>
</table>
</div>
<p>Heap-allocated objects are stored in the GC’s object table and referenced by index.</p>
<h3 id="object-kinds"><a class="header" href="#object-kinds">Object Kinds</a></h3>
<pre><code>ObjKind::String(String)
ObjKind::Array(Vec&lt;Value&gt;)
ObjKind::Object(IndexMap&lt;String, Value&gt;)
ObjKind::Closure { ... }
</code></pre>
<h3 id="gc-algorithm"><a class="header" href="#gc-algorithm">GC Algorithm</a></h3>
<p>The mark-sweep collector works in two phases:</p>
<ol>
<li><strong>Mark</strong>: Starting from roots (registers, global environment, call stack frames), traverse all reachable objects and set their mark bit.</li>
<li><strong>Sweep</strong>: Walk the object table. Free any object without a mark bit. Clear all mark bits for the next cycle.</li>
</ol>
<p>Collection is triggered when the number of allocated objects exceeds a dynamic threshold that grows as the program allocates more objects.</p>
<h3 id="gc-roots"><a class="header" href="#gc-roots">GC Roots</a></h3>
<p>The following locations are scanned as roots:</p>
<ul>
<li>All registers in the current and parent call frames</li>
<li>The global environment</li>
<li>Constant pools of active chunks</li>
<li>Green thread stacks</li>
</ul>
<h2 id="jit-memory"><a class="header" href="#jit-memory">JIT Memory</a></h2>
<p>The JIT compiler allocates executable memory pages for generated native code via Cranelift’s <code>JITModule</code>. This memory is mapped with execute permissions and is freed when the JIT module is dropped.</p>
<p>JIT-compiled functions operate on machine registers and stack-allocated values. There is no GC interaction – the JIT tier does not support heap-allocated objects.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="grammar"><a class="header" href="#grammar">Grammar</a></h1>
<p>Simplified EBNF grammar for the Forge language. This is a reference guide, not a formal specification. Optional elements are marked with <code>?</code>, repetition with <code>*</code>, and alternation with <code>|</code>.</p>
<h2 id="program"><a class="header" href="#program">Program</a></h2>
<pre><code class="language-ebnf">program        = statement* EOF ;
</code></pre>
<h2 id="statements-1"><a class="header" href="#statements-1">Statements</a></h2>
<pre><code class="language-ebnf">statement      = let_stmt
               | assign_stmt
               | fn_def
               | struct_def
               | interface_def
               | impl_block
               | type_def
               | if_stmt
               | match_stmt
               | when_stmt
               | for_stmt
               | while_stmt
               | loop_stmt
               | return_stmt
               | break_stmt
               | continue_stmt
               | try_catch
               | import_stmt
               | spawn_stmt
               | destructure_stmt
               | check_stmt
               | safe_block
               | timeout_block
               | retry_block
               | schedule_block
               | watch_block
               | prompt_def
               | decorator_stmt
               | yield_stmt
               | expression_stmt ;
</code></pre>
<h3 id="variable-declarations"><a class="header" href="#variable-declarations">Variable Declarations</a></h3>
<pre><code class="language-ebnf">let_stmt       = ( "let" | "set" ) "mut"? IDENT ( ":" type_ann )? ( "=" | "to" ) expr NEWLINE ;
assign_stmt    = ( IDENT | field_access | index_expr ) ( "=" | "+=" | "-=" | "*=" | "/=" ) expr NEWLINE
               | "change" IDENT "to" expr NEWLINE ;
destructure_stmt = ( "let" | "unpack" ) destruct_pattern ( "=" | "from" ) expr NEWLINE ;
destruct_pattern = "{" IDENT ( "," IDENT )* "}"
                 | "[" IDENT ( "," IDENT )* ( "," "..." IDENT )? "]" ;
</code></pre>
<h3 id="function-definitions"><a class="header" href="#function-definitions">Function Definitions</a></h3>
<pre><code class="language-ebnf">fn_def         = decorator* ( "fn" | "define" | "async" "fn" | "forge" ) IDENT "(" param_list? ")" ( "-&gt;" type_ann )? block ;
param_list     = param ( "," param )* ;
param          = IDENT ( ":" type_ann )? ( "=" expr )? ;
block          = "{" statement* "}" ;
</code></pre>
<h3 id="struct--thing-definitions"><a class="header" href="#struct--thing-definitions">Struct / Thing Definitions</a></h3>
<pre><code class="language-ebnf">struct_def     = ( "struct" | "thing" ) IDENT "{" field_def* "}" ;
field_def      = IDENT ":" type_ann ( "=" expr )? NEWLINE ;
</code></pre>
<h3 id="interface--power-definitions"><a class="header" href="#interface--power-definitions">Interface / Power Definitions</a></h3>
<pre><code class="language-ebnf">interface_def  = ( "interface" | "power" ) IDENT "{" method_sig* "}" ;
method_sig     = IDENT "(" param_list? ")" ( "-&gt;" type_ann )? NEWLINE ;
</code></pre>
<h3 id="impl--give-blocks"><a class="header" href="#impl--give-blocks">Impl / Give Blocks</a></h3>
<pre><code class="language-ebnf">impl_block     = "impl" IDENT "{" fn_def* "}"
               | "give" IDENT "{" fn_def* "}"
               | "give" IDENT "the" "power" IDENT "{" fn_def* "}" ;
</code></pre>
<h3 id="type-definitions-adts"><a class="header" href="#type-definitions-adts">Type Definitions (ADTs)</a></h3>
<pre><code class="language-ebnf">type_def       = "type" IDENT "=" variant ( "|" variant )* ;
variant        = IDENT ( "(" type_ann ( "," type_ann )* ")" )? ;
</code></pre>
<h3 id="control-flow-3"><a class="header" href="#control-flow-3">Control Flow</a></h3>
<pre><code class="language-ebnf">if_stmt        = "if" expr block ( ( "else" | "otherwise" | "nah" ) ( if_stmt | block ) )? ;
match_stmt     = "match" expr "{" match_arm* "}" ;
match_arm      = pattern "-&gt;" ( expr | block ) ","? ;
pattern        = "_"
               | literal
               | IDENT
               | IDENT "(" pattern ( "," pattern )* ")" ;

when_stmt      = "when" expr "{" when_arm* "}" ;
when_arm       = ( comparison_op expr | "else" ) "-&gt;" expr ","? ;

for_stmt       = "for" IDENT ( "," IDENT )? "in" expr block
               | "for" "each" IDENT "in" expr block ;
while_stmt     = "while" expr block ;
loop_stmt      = "loop" block ;
return_stmt    = "return" expr? NEWLINE ;
break_stmt     = "break" NEWLINE ;
continue_stmt  = "continue" NEWLINE ;
yield_stmt     = ( "yield" | "emit" ) expr NEWLINE ;
</code></pre>
<h3 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h3>
<pre><code class="language-ebnf">try_catch      = "try" block "catch" IDENT block ;
</code></pre>
<h3 id="import"><a class="header" href="#import">Import</a></h3>
<pre><code class="language-ebnf">import_stmt    = "import" STRING
               | "from" STRING "import" IDENT ( "," IDENT )* ;
</code></pre>
<h3 id="spawn-1"><a class="header" href="#spawn-1">Spawn</a></h3>
<pre><code class="language-ebnf">spawn_stmt     = "spawn" block ;
</code></pre>
<h3 id="innovation-statements"><a class="header" href="#innovation-statements">Innovation Statements</a></h3>
<pre><code class="language-ebnf">check_stmt     = "check" expr ( "is" "not"? "empty" | "contains" expr | "between" expr "and" expr ) ;
safe_block     = "safe" block ;
timeout_block  = "timeout" expr "seconds" block ;
retry_block    = "retry" expr "times" block ;
schedule_block = "schedule" "every" expr ( "seconds" | "minutes" ) block ;
watch_block    = "watch" expr block ;
</code></pre>
<h3 id="decorators"><a class="header" href="#decorators">Decorators</a></h3>
<pre><code class="language-ebnf">decorator      = "@" IDENT ( "(" decorator_args? ")" )? ;
decorator_args = decorator_arg ( "," decorator_arg )* ;
decorator_arg  = IDENT ":" expr
               | expr ;
</code></pre>
<h3 id="prompt-definitions"><a class="header" href="#prompt-definitions">Prompt Definitions</a></h3>
<pre><code class="language-ebnf">prompt_def     = "prompt" IDENT "(" param_list? ")" "{" prompt_body "}" ;
prompt_body    = ( "system" ":" STRING )? "user" ":" STRING ( "returns" ":" STRING )? ;
</code></pre>
<h2 id="expressions-1"><a class="header" href="#expressions-1">Expressions</a></h2>
<pre><code class="language-ebnf">expr           = or_expr ;
or_expr        = and_expr ( "||" and_expr )* ;
and_expr       = equality ( "&amp;&amp;" equality )* ;
equality       = comparison ( ( "==" | "!=" ) comparison )* ;
comparison     = addition ( ( "&lt;" | "&gt;" | "&lt;=" | "&gt;=" ) addition )* ;
addition       = multiplication ( ( "+" | "-" ) multiplication )* ;
multiplication = unary ( ( "*" | "/" | "%" ) unary )* ;
unary          = ( "!" | "-" ) unary | postfix ;
postfix        = primary ( call | index | field_access | "?" )* ;

call           = "(" arg_list? ")" ;
arg_list       = expr ( "," expr )* ;
index          = "[" expr "]" ;
field_access   = "." IDENT ;

primary        = INT | FLOAT | STRING | "true" | "false" | "null"
               | IDENT
               | "(" expr ")"
               | array_lit
               | object_lit
               | lambda
               | pipeline
               | must_expr
               | ask_expr
               | freeze_expr
               | spread_expr
               | await_expr
               | struct_init
               | where_filter
               | pipe_chain
               | block_expr ;

array_lit      = "[" ( expr ( "," expr )* ","? )? "]" ;
object_lit     = "{" ( field_init ( "," field_init )* ","? )? "}" ;
field_init     = ( IDENT | STRING ) ":" expr | IDENT ;
lambda         = "|" param_list? "|" ( expr | block ) ;
pipeline       = expr "|&gt;" expr ;
must_expr      = "must" expr ;
ask_expr       = "ask" expr ;
freeze_expr    = "freeze" expr ;
spread_expr    = "..." expr ;
await_expr     = ( "await" | "hold" ) expr ;
struct_init    = IDENT "{" ( IDENT ":" expr ( "," IDENT ":" expr )* ","? )? "}" ;
where_filter   = expr "where" IDENT comparison_op expr ;
pipe_chain     = "from" expr ( "keep" expr | "sort" "by" IDENT | "take" expr )+ ;
block_expr     = "{" statement* expr "}" ;
</code></pre>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<pre><code class="language-ebnf">type_ann       = simple_type
               | array_type
               | generic_type
               | function_type
               | optional_type ;

simple_type    = "Int" | "Float" | "String" | "Bool" | "Json" | IDENT ;
array_type     = "[" type_ann "]" ;
generic_type   = IDENT "&lt;" type_ann ( "," type_ann )* "&gt;" ;
function_type  = "fn" "(" ( type_ann ( "," type_ann )* )? ")" "-&gt;" type_ann ;
optional_type  = type_ann "?" ;
</code></pre>
<h2 id="lexical-elements"><a class="header" href="#lexical-elements">Lexical Elements</a></h2>
<pre><code class="language-ebnf">IDENT          = ( ALPHA | "_" ) ( ALPHA | DIGIT | "_" )* ;
INT            = DIGIT+ ;
FLOAT          = DIGIT+ "." DIGIT+ ;
STRING         = '"' ( CHAR | ESCAPE | INTERP )* '"' ;
RAW_STRING     = '"""' CHAR* '"""' ;
INTERP         = "{" expr "}" ;
ESCAPE         = "\\" ( "n" | "t" | "r" | "\\" | '"' | "{" ) ;
NEWLINE        = "\n" | "\r\n" | ";" ;
COMMENT        = "//" CHAR* NEWLINE ;
</code></pre>
<h2 id="operator-summary"><a class="header" href="#operator-summary">Operator Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Precedence</th><th>Operators</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1 (lowest)</td><td><code>||</code></td><td>Left</td></tr>
<tr><td>2</td><td><code>&amp;&amp;</code></td><td>Left</td></tr>
<tr><td>3</td><td><code>==</code> <code>!=</code></td><td>Left</td></tr>
<tr><td>4</td><td><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td><td>Left</td></tr>
<tr><td>5</td><td><code>+</code> <code>-</code></td><td>Left</td></tr>
<tr><td>6</td><td><code>*</code> <code>/</code> <code>%</code></td><td>Left</td></tr>
<tr><td>7</td><td><code>!</code> <code>-</code> (unary)</td><td>Right</td></tr>
<tr><td>8</td><td><code>?</code> (postfix try)</td><td>Left</td></tr>
<tr><td>9 (highest)</td><td><code>.</code> <code>[]</code> <code>()</code></td><td>Left</td></tr>
</tbody>
</table>
</div>
<h2 id="notes-5"><a class="header" href="#notes-5">Notes</a></h2>
<ul>
<li>Newlines are significant. They terminate statements unless the line ends with an operator or open delimiter.</li>
<li>Semicolons can be used as explicit statement terminators.</li>
<li>Comments start with <code>//</code> and extend to the end of the line.</li>
<li>String interpolation uses <code>{expr}</code> inside double-quoted strings. Raw strings (<code>"""..."""</code>) do not interpolate.</li>
<li>The <code>has</code> keyword is not reserved. It is parsed contextually inside struct/thing bodies.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="keywords-1"><a class="header" href="#keywords-1">Keywords</a></h1>
<p>Alphabetical list of all reserved keywords in the Forge language. Keywords cannot be used as identifiers.</p>
<h2 id="keyword-table"><a class="header" href="#keyword-table">Keyword Table</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Category</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>any</code></td><td>Innovation</td><td>Existential check over collection</td></tr>
<tr><td><code>ask</code></td><td>Innovation</td><td>AI/LLM prompt call</td></tr>
<tr><td><code>async</code></td><td>Classic</td><td>Async function modifier</td></tr>
<tr><td><code>await</code></td><td>Classic</td><td>Await an async expression</td></tr>
<tr><td><code>break</code></td><td>Control flow</td><td>Exit the current loop</td></tr>
<tr><td><code>by</code></td><td>Innovation</td><td>Sort/order modifier (<code>sort by</code>, <code>order by</code>)</td></tr>
<tr><td><code>catch</code></td><td>Error handling</td><td>Catch block in try/catch</td></tr>
<tr><td><code>change</code></td><td>Natural</td><td>Reassign a variable (<code>change x to 10</code>)</td></tr>
<tr><td><code>check</code></td><td>Innovation</td><td>Declarative validation</td></tr>
<tr><td><code>continue</code></td><td>Control flow</td><td>Skip to next loop iteration</td></tr>
<tr><td><code>craft</code></td><td>Natural type</td><td>Constructor call (<code>craft Person { }</code>)</td></tr>
<tr><td><code>crawl</code></td><td>Innovation</td><td>Web scraping</td></tr>
<tr><td><code>define</code></td><td>Natural</td><td>Function definition (alias for <code>fn</code>)</td></tr>
<tr><td><code>download</code></td><td>Innovation</td><td>Download a file (<code>download url to path</code>)</td></tr>
<tr><td><code>each</code></td><td>Natural</td><td>Iterator keyword (<code>for each x in items</code>)</td></tr>
<tr><td><code>else</code></td><td>Control flow</td><td>Else branch in if/else</td></tr>
<tr><td><code>emit</code></td><td>Natural</td><td>Yield a value (alias for <code>yield</code>)</td></tr>
<tr><td><code>every</code></td><td>Innovation</td><td>Interval modifier (<code>schedule every 5 seconds</code>)</td></tr>
<tr><td><code>false</code></td><td>Literal</td><td>Boolean false</td></tr>
<tr><td><code>fn</code></td><td>Classic</td><td>Function definition</td></tr>
<tr><td><code>for</code></td><td>Control flow</td><td>For loop</td></tr>
<tr><td><code>forge</code></td><td>Natural</td><td>Async function modifier (alias for <code>async fn</code>)</td></tr>
<tr><td><code>freeze</code></td><td>Innovation</td><td>Make a value immutable</td></tr>
<tr><td><code>from</code></td><td>Natural</td><td>Source keyword (<code>grab x from url</code>, <code>from x import y</code>)</td></tr>
<tr><td><code>give</code></td><td>Natural type</td><td>Impl block (alias for <code>impl</code>)</td></tr>
<tr><td><code>grab</code></td><td>Natural</td><td>Fetch from URL (<code>grab resp from "url"</code>)</td></tr>
<tr><td><code>hold</code></td><td>Natural</td><td>Await expression (alias for <code>await</code>)</td></tr>
<tr><td><code>if</code></td><td>Control flow</td><td>Conditional branch</td></tr>
<tr><td><code>impl</code></td><td>Classic</td><td>Implementation block</td></tr>
<tr><td><code>import</code></td><td>Module</td><td>Import from a module</td></tr>
<tr><td><code>in</code></td><td>Control flow</td><td>Iterator membership (<code>for x in items</code>)</td></tr>
<tr><td><code>interface</code></td><td>Classic</td><td>Interface definition</td></tr>
<tr><td><code>keep</code></td><td>Innovation</td><td>Filter in pipe chain</td></tr>
<tr><td><code>let</code></td><td>Classic</td><td>Variable declaration</td></tr>
<tr><td><code>limit</code></td><td>Innovation</td><td>Limit results in query pipeline</td></tr>
<tr><td><code>loop</code></td><td>Control flow</td><td>Infinite loop</td></tr>
<tr><td><code>match</code></td><td>Control flow</td><td>Pattern matching</td></tr>
<tr><td><code>must</code></td><td>Innovation</td><td>Crash on error with clear message</td></tr>
<tr><td><code>mut</code></td><td>Classic</td><td>Mutable modifier</td></tr>
<tr><td><code>nah</code></td><td>Natural</td><td>Else branch (alias for <code>else</code>)</td></tr>
<tr><td><code>null</code></td><td>Literal</td><td>Null value</td></tr>
<tr><td><code>order</code></td><td>Innovation</td><td>Order results in query pipeline</td></tr>
<tr><td><code>otherwise</code></td><td>Natural</td><td>Else branch (alias for <code>else</code>)</td></tr>
<tr><td><code>power</code></td><td>Natural type</td><td>Interface definition (alias for <code>interface</code>)</td></tr>
<tr><td><code>prompt</code></td><td>Innovation</td><td>Prompt template definition</td></tr>
<tr><td><code>pub</code></td><td>Visibility</td><td>Public visibility modifier</td></tr>
<tr><td><code>repeat</code></td><td>Natural</td><td>Counted loop (<code>repeat 5 times { }</code>)</td></tr>
<tr><td><code>retry</code></td><td>Innovation</td><td>Automatic retry (<code>retry 3 times { }</code>)</td></tr>
<tr><td><code>return</code></td><td>Control flow</td><td>Return from function</td></tr>
<tr><td><code>safe</code></td><td>Innovation</td><td>Null-safe execution block</td></tr>
<tr><td><code>say</code></td><td>Natural</td><td>Print with newline (alias for <code>println</code>)</td></tr>
<tr><td><code>schedule</code></td><td>Innovation</td><td>Cron-style scheduling</td></tr>
<tr><td><code>seconds</code></td><td>Natural</td><td>Time unit for <code>wait</code> and <code>timeout</code></td></tr>
<tr><td><code>select</code></td><td>Innovation</td><td>Select fields in query pipeline</td></tr>
<tr><td><code>set</code></td><td>Natural</td><td>Variable declaration (alias for <code>let</code>)</td></tr>
<tr><td><code>spawn</code></td><td>Concurrency</td><td>Spawn a concurrent task</td></tr>
<tr><td><code>struct</code></td><td>Classic</td><td>Struct definition</td></tr>
<tr><td><code>table</code></td><td>Innovation</td><td>Tabular data display</td></tr>
<tr><td><code>take</code></td><td>Innovation</td><td>Take N items in pipe chain</td></tr>
<tr><td><code>the</code></td><td>Natural type</td><td>Connector (<code>give X the power Y</code>)</td></tr>
<tr><td><code>thing</code></td><td>Natural type</td><td>Struct definition (alias for <code>struct</code>)</td></tr>
<tr><td><code>timeout</code></td><td>Innovation</td><td>Time-limited execution block</td></tr>
<tr><td><code>times</code></td><td>Natural</td><td>Loop count modifier (<code>repeat 5 times</code>)</td></tr>
<tr><td><code>to</code></td><td>Natural</td><td>Assignment target (<code>set x to 5</code>, <code>download url to path</code>)</td></tr>
<tr><td><code>transform</code></td><td>Innovation</td><td>Data transformation</td></tr>
<tr><td><code>true</code></td><td>Literal</td><td>Boolean true</td></tr>
<tr><td><code>try</code></td><td>Error handling</td><td>Try block in try/catch</td></tr>
<tr><td><code>type</code></td><td>Classic</td><td>Algebraic data type definition</td></tr>
<tr><td><code>unless</code></td><td>Innovation</td><td>Postfix conditional negation</td></tr>
<tr><td><code>unpack</code></td><td>Natural</td><td>Destructuring (alias for <code>let { }</code>)</td></tr>
<tr><td><code>until</code></td><td>Innovation</td><td>Postfix loop termination</td></tr>
<tr><td><code>wait</code></td><td>Natural</td><td>Sleep with time units (<code>wait 2 seconds</code>)</td></tr>
<tr><td><code>watch</code></td><td>Innovation</td><td>File change detection block</td></tr>
<tr><td><code>when</code></td><td>Innovation</td><td>Guard-based conditional</td></tr>
<tr><td><code>where</code></td><td>Innovation</td><td>Collection filter</td></tr>
<tr><td><code>while</code></td><td>Control flow</td><td>While loop</td></tr>
<tr><td><code>whisper</code></td><td>Natural</td><td>Print in lowercase</td></tr>
<tr><td><code>yield</code></td><td>Classic</td><td>Yield a value from a generator</td></tr>
<tr><td><code>yell</code></td><td>Natural</td><td>Print in uppercase</td></tr>
</tbody>
</table>
</div>
<h2 id="built-in-type-names"><a class="header" href="#built-in-type-names">Built-in Type Names</a></h2>
<p>These identifiers are recognized as type annotations. They are reserved in type position but can be used as regular identifiers in value position.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th></tr>
</thead>
<tbody>
<tr><td><code>Int</code></td><td>64-bit integer</td></tr>
<tr><td><code>Float</code></td><td>64-bit float</td></tr>
<tr><td><code>String</code></td><td>UTF-8 string</td></tr>
<tr><td><code>Bool</code></td><td>Boolean</td></tr>
<tr><td><code>Json</code></td><td>JSON value</td></tr>
</tbody>
</table>
</div>
<h2 id="categories"><a class="header" href="#categories">Categories</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Count</th><th>Keywords</th></tr>
</thead>
<tbody>
<tr><td>Classic</td><td>10</td><td><code>async</code>, <code>await</code>, <code>fn</code>, <code>impl</code>, <code>interface</code>, <code>let</code>, <code>mut</code>, <code>struct</code>, <code>type</code>, <code>yield</code></td></tr>
<tr><td>Control flow</td><td>12</td><td><code>break</code>, <code>continue</code>, <code>else</code>, <code>for</code>, <code>if</code>, <code>in</code>, <code>loop</code>, <code>match</code>, <code>return</code>, <code>while</code>, <code>each</code>, <code>from</code></td></tr>
<tr><td>Natural</td><td>13</td><td><code>change</code>, <code>define</code>, <code>emit</code>, <code>forge</code>, <code>grab</code>, <code>hold</code>, <code>nah</code>, <code>otherwise</code>, <code>say</code>, <code>set</code>, <code>to</code>, <code>unpack</code>, <code>whisper</code>, <code>yell</code></td></tr>
<tr><td>Natural type</td><td>5</td><td><code>craft</code>, <code>give</code>, <code>power</code>, <code>the</code>, <code>thing</code></td></tr>
<tr><td>Innovation</td><td>21</td><td><code>any</code>, <code>ask</code>, <code>by</code>, <code>check</code>, <code>crawl</code>, <code>download</code>, <code>every</code>, <code>freeze</code>, <code>keep</code>, <code>limit</code>, <code>must</code>, <code>order</code>, <code>prompt</code>, <code>retry</code>, <code>safe</code>, <code>schedule</code>, <code>select</code>, <code>table</code>, <code>take</code>, <code>timeout</code>, <code>transform</code>, <code>unless</code>, <code>until</code>, <code>watch</code>, <code>when</code>, <code>where</code></td></tr>
<tr><td>Error handling</td><td>2</td><td><code>catch</code>, <code>try</code></td></tr>
<tr><td>Concurrency</td><td>1</td><td><code>spawn</code></td></tr>
<tr><td>Literal</td><td>3</td><td><code>false</code>, <code>null</code>, <code>true</code></td></tr>
<tr><td>Natural time</td><td>2</td><td><code>repeat</code>, <code>seconds</code>, <code>times</code>, <code>wait</code></td></tr>
<tr><td>Visibility</td><td>1</td><td><code>pub</code></td></tr>
<tr><td>Module</td><td>1</td><td><code>import</code></td></tr>
</tbody>
</table>
</div>
<h2 id="non-keywords"><a class="header" href="#non-keywords">Non-Keywords</a></h2>
<p>The following identifiers are <strong>not</strong> reserved keywords. They are built-in functions or contextual identifiers that can be shadowed:</p>
<ul>
<li><code>has</code> – parsed contextually inside struct/thing bodies</li>
<li><code>print</code>, <code>println</code> – built-in functions, not keywords</li>
<li><code>Ok</code>, <code>Err</code>, <code>Some</code>, <code>None</code> – built-in constructors</li>
<li><code>self</code> – not reserved; methods receive <code>self</code> as a regular parameter name</li>
<li>Module names (<code>math</code>, <code>fs</code>, <code>io</code>, etc.) – pre-loaded global variables, not keywords</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="operator-precedence-3"><a class="header" href="#operator-precedence-3">Operator Precedence</a></h1>
<p>Operators listed from lowest precedence (evaluated last) to highest precedence (evaluated first). Operators at the same precedence level are evaluated according to their associativity.</p>
<h2 id="precedence-table"><a class="header" href="#precedence-table">Precedence Table</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Operator</th><th>Description</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>||</code></td><td>Logical OR</td><td>Left</td></tr>
<tr><td>2</td><td><code>&amp;&amp;</code></td><td>Logical AND</td><td>Left</td></tr>
<tr><td>3</td><td><code>==</code> <code>!=</code></td><td>Equality</td><td>Left</td></tr>
<tr><td>4</td><td><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td><td>Comparison</td><td>Left</td></tr>
<tr><td>5</td><td><code>+</code> <code>-</code></td><td>Addition, subtraction</td><td>Left</td></tr>
<tr><td>6</td><td><code>*</code> <code>/</code> <code>%</code></td><td>Multiply, divide, modulo</td><td>Left</td></tr>
<tr><td>7</td><td><code>!</code> <code>-</code> (unary)</td><td>Logical NOT, negation</td><td>Right (unary)</td></tr>
<tr><td>8</td><td><code>?</code></td><td>Postfix try (Result)</td><td>Left</td></tr>
<tr><td>9</td><td><code>.</code> <code>[]</code> <code>()</code></td><td>Access, index, call</td><td>Left</td></tr>
</tbody>
</table>
</div>
<h2 id="special-operators-1"><a class="header" href="#special-operators-1">Special Operators</a></h2>
<p>These operators do not fit neatly into the arithmetic precedence chain.</p>
<h3 id="pipe-operator-"><a class="header" href="#pipe-operator-">Pipe Operator <code>|&gt;</code></a></h3>
<pre><code class="language-forge">let result = data |&gt; transform |&gt; validate
</code></pre>
<p>The pipe operator has lower precedence than function calls but higher than assignment. It passes the left-hand value as the first argument to the right-hand function.</p>
<h3 id="pipe-right-"><a class="header" href="#pipe-right-">Pipe Right <code>&gt;&gt;</code></a></h3>
<pre><code class="language-forge">from users &gt;&gt; keep where active &gt;&gt; sort by name &gt;&gt; take 5
</code></pre>
<p>Used in query-style pipe chains. Evaluated left to right.</p>
<h3 id="spread-"><a class="header" href="#spread-">Spread <code>...</code></a></h3>
<pre><code class="language-forge">let merged = [...arr1, ...arr2]
let combined = { ...obj1, ...obj2 }
</code></pre>
<p>Prefix operator used inside array and object literals. Not a general expression operator.</p>
<h3 id="range-"><a class="header" href="#range-">Range <code>..</code></a></h3>
<pre><code class="language-forge">let r = 1..10
</code></pre>
<p>Creates a range value. Used primarily in <code>for</code> loops and slice operations.</p>
<h3 id="arrow--"><a class="header" href="#arrow--">Arrow <code>-&gt;</code></a></h3>
<pre><code class="language-forge">match x {
    1 -&gt; "one",
    _ -&gt; "other",
}
</code></pre>
<p>Used in match arms and when arms to separate pattern from result. Not a general operator.</p>
<h3 id="fat-arrow-"><a class="header" href="#fat-arrow-">Fat Arrow <code>=&gt;</code></a></h3>
<pre><code class="language-forge">let f = (x) =&gt; x * 2
</code></pre>
<p>Lambda shorthand syntax. Separates parameters from body.</p>
<h2 id="compound-assignment-1"><a class="header" href="#compound-assignment-1">Compound Assignment</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Equivalent</th></tr>
</thead>
<tbody>
<tr><td><code>+=</code></td><td><code>x = x + value</code></td></tr>
<tr><td><code>-=</code></td><td><code>x = x - value</code></td></tr>
<tr><td><code>*=</code></td><td><code>x = x * value</code></td></tr>
<tr><td><code>/=</code></td><td><code>x = x / value</code></td></tr>
</tbody>
</table>
</div>
<p>Compound assignment operators have the same precedence as regular assignment (<code>=</code>). They are statement-level constructs, not expressions.</p>
<h2 id="type-operators"><a class="header" href="#type-operators">Type Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Context</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>:</code></td><td><code>let x: Int = 5</code></td><td>Type annotation</td></tr>
<tr><td><code>?</code></td><td><code>fn f(x: Int?) { }</code></td><td>Optional type modifier</td></tr>
<tr><td><code>&lt;&gt;</code></td><td><code>Array&lt;Int&gt;</code></td><td>Generic type parameters</td></tr>
</tbody>
</table>
</div>
<p>Type operators appear only in type annotation positions and do not participate in expression evaluation.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<pre><code class="language-forge">// Precedence determines evaluation order
let x = 2 + 3 * 4        // 14 (not 20)
let y = !true || false    // false (! binds tighter than ||)
let z = 1 &lt; 2 &amp;&amp; 3 &gt; 1   // true (&amp;&amp; binds looser than &lt; and &gt;)

// Postfix try with field access
let name = get_user()?.name  // ? applies to get_user(), then .name

// Pipe with arithmetic
let result = 5 + 3 |&gt; double  // double(8), not 5 + double(3)
</code></pre>
<h2 id="gotchas"><a class="header" href="#gotchas">Gotchas</a></h2>
<ul>
<li>Unary <code>-</code> binds tighter than binary operators: <code>-2 * 3</code> is <code>(-2) * 3 = -6</code>, not <code>-(2 * 3) = -6</code> (same result in this case, but matters for method calls).</li>
<li>The <code>?</code> operator binds tighter than <code>.</code>, so <code>expr?.field</code> works as expected: it tries <code>expr</code>, then accesses <code>.field</code> on the result.</li>
<li>There is no ternary <code>? :</code> operator. Use <code>if/else</code> expressions or <code>when</code> guards instead.</li>
<li><code>==</code> and <code>!=</code> compare by value for all types. There is no identity comparison operator.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h2 id="v033"><a class="header" href="#v033">v0.3.3</a></h2>
<p><strong>Type system – natural syntax</strong></p>
<ul>
<li>Added <code>thing</code> keyword as alias for <code>struct</code></li>
<li>Added <code>power</code> keyword as alias for <code>interface</code></li>
<li>Added <code>give</code> keyword as alias for <code>impl</code></li>
<li>Added <code>give X the power Y</code> syntax for interface implementation</li>
<li>Added <code>craft</code> keyword for struct construction</li>
<li>Added <code>has</code> contextual parsing inside struct/thing bodies (not a reserved keyword)</li>
<li>Interface satisfaction checking (Go-style structural typing)</li>
</ul>
<h2 id="v032"><a class="header" href="#v032">v0.3.2</a></h2>
<p><strong>Landing page and book</strong></p>
<ul>
<li>Added mdBook-based language specification</li>
<li>Created project landing page</li>
<li>Documentation improvements across all modules</li>
</ul>
<h2 id="v031"><a class="header" href="#v031">v0.3.1</a></h2>
<p><strong>Bug fixes and stabilization</strong></p>
<ul>
<li>Fixed production gaps identified by architecture audit</li>
<li>Comprehensive integration test suite (179 tests)</li>
<li>Stability improvements for interpreter, VM, and JIT tiers</li>
</ul>
<h2 id="v030"><a class="header" href="#v030">v0.3.0</a></h2>
<p><strong>Standard library expansion</strong></p>
<ul>
<li>Expanded stdlib to 16 modules with 230+ functions</li>
<li>Added <code>time</code> module (25 functions: now, unix, parse, format, diff, add, sub, zone, etc.)</li>
<li>Added <code>npc</code> module (16 fake data generators)</li>
<li>Added <code>csv</code> module (parse, stringify, read, write with auto type inference)</li>
<li>Added <code>term</code> module (25+ functions: colors, table, sparkline, bar, banner, box, gradient, menu, etc.)</li>
<li>Added <code>exec</code> module (run_command with stdout/stderr/status)</li>
<li>Expanded <code>http</code> module with download and crawl</li>
<li>Expanded <code>fs</code> module to 20 functions</li>
<li>Native <code>Option&lt;T&gt;</code> values (<code>Some</code>, <code>None</code>, <code>is_some</code>, <code>is_none</code>)</li>
<li>Tokio <code>spawn</code> with language-level task handles</li>
<li>Language-level channels (<code>channel</code>, <code>send</code>, <code>receive</code>, <code>try_send</code>, <code>try_receive</code>)</li>
<li>GenZ debug kit (<code>sus</code>, <code>bruh</code>, <code>bet</code>, <code>no_cap</code>, <code>ick</code>)</li>
<li>Execution helpers (<code>cook</code>, <code>yolo</code>, <code>ghost</code>, <code>slay</code>)</li>
<li>30 interactive tutorials via <code>forge learn</code></li>
<li>Shell integration (<code>sh</code>, <code>shell</code>, <code>sh_lines</code>, <code>sh_json</code>, <code>sh_ok</code>, <code>pipe_to</code>)</li>
<li>Dual syntax (natural language keywords alongside classic syntax)</li>
<li>Innovation keywords: <code>when</code>, <code>must</code>, <code>safe</code>, <code>check</code>, <code>retry</code>, <code>timeout</code>, <code>schedule</code>, <code>watch</code>, <code>ask</code>, <code>download</code>, <code>crawl</code>, <code>repeat</code>, <code>wait</code>, <code>grab</code>, <code>emit</code>, <code>hold</code></li>
<li>Pipe operator (<code>|&gt;</code>) and query-style pipe chains</li>
<li><code>where</code> filter syntax</li>
<li><code>freeze</code> for immutable values</li>
<li>Decorator system (<code>@server</code>, <code>@get</code>, <code>@post</code>, <code>@put</code>, <code>@delete</code>, <code>@ws</code>)</li>
<li>HTTP server powered by axum + tokio</li>
<li>WebSocket support</li>
<li>PostgreSQL support via <code>pg</code> module</li>
<li>Compound assignment operators (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>)</li>
<li>Spread operator (<code>...</code>) in arrays and objects</li>
<li>String interpolation (<code>"hello, {name}"</code>)</li>
<li>Raw strings (<code>"""no interpolation"""</code>)</li>
<li>Destructuring (<code>let {a, b} = obj</code> / <code>unpack {a, b} from obj</code>)</li>
<li>Default parameter values</li>
<li>12 example programs</li>
<li>13 CLI commands (run, repl, version, fmt, test, new, build, install, lsp, learn, chat, help, -e)</li>
</ul>
<h2 id="v020"><a class="header" href="#v020">v0.2.0</a></h2>
<p><strong>VM and JIT tiers</strong></p>
<ul>
<li>Register-based bytecode VM (<code>--vm</code> flag)</li>
<li>32-bit instruction encoding (ABC, ABx, AsBx formats)</li>
<li>Mark-sweep garbage collector for VM heap</li>
<li>Green thread scheduler in VM</li>
<li>Cranelift JIT compiler (<code>--jit</code> flag)</li>
<li>JIT achieves ~11x faster than Python on <code>fib(30)</code></li>
<li>Bytecode compiler from AST to VM instructions</li>
<li>VM supports core language features (variables, functions, closures, control flow, arrays, objects)</li>
<li>JIT supports integer/float arithmetic, function calls, recursion, basic control flow</li>
</ul>
<h2 id="v010"><a class="header" href="#v010">v0.1.0</a></h2>
<p><strong>Initial release</strong></p>
<ul>
<li>Tree-walking interpreter in Rust</li>
<li>Core language: variables, functions, closures, if/else, for, while, match</li>
<li>Basic type system: Int, Float, Bool, String, Array, Object, Null</li>
<li>Result type (<code>Ok</code>, <code>Err</code>) with <code>?</code> operator</li>
<li><code>math</code>, <code>fs</code>, <code>io</code>, <code>crypto</code>, <code>db</code>, <code>env</code>, <code>json</code>, <code>regex</code>, <code>log</code> modules</li>
<li>Built-in HTTP client via <code>reqwest</code></li>
<li>SQLite database access via <code>rusqlite</code></li>
<li>REPL mode</li>
<li>Formatter (<code>forge fmt</code>)</li>
<li>Test runner (<code>forge test</code>)</li>
<li>Project scaffolding (<code>forge new</code>)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/forge-9e99b408.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
